/*! For license information please see main.3dc6d0f8.js.LICENSE.txt */
(()=>{var __webpack_modules__={939:e=>{e.exports=function e(t,n){"use strict";var r,a,o=/(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi,i=/(^[ ]*|[ ]*$)/g,s=/(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,u=/^0x[0-9a-f]+$/i,c=/^0/,l=function(t){return e.insensitive&&(""+t).toLowerCase()||""+t},h=l(t).replace(i,"")||"",d=l(n).replace(i,"")||"",p=h.replace(o,"\0$1\0").replace(/\0$/,"").replace(/^\0/,"").split("\0"),f=d.replace(o,"\0$1\0").replace(/\0$/,"").replace(/^\0/,"").split("\0"),m=parseInt(h.match(u),16)||1!==p.length&&h.match(s)&&Date.parse(h),g=parseInt(d.match(u),16)||m&&d.match(s)&&Date.parse(d)||null;if(g){if(m<g)return-1;if(m>g)return 1}for(var y=0,b=Math.max(p.length,f.length);y<b;y++){if(r=!(p[y]||"").match(c)&&parseFloat(p[y])||p[y]||0,a=!(f[y]||"").match(c)&&parseFloat(f[y])||f[y]||0,isNaN(r)!==isNaN(a))return isNaN(r)?1:-1;if(typeof r!==typeof a&&(r+="",a+=""),r<a)return-1;if(r>a)return 1}return 0}},353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(S){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},o={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=o[e])?r:(n=u(e,(0|e)<0?-1:0,!0),i&&(o[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=a[e])?r:(n=u(e,e<0?-1:0,!1),i&&(a[e]=n),n)}function s(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return C;if(e+1>=f)return w}return e<0?s(-e,t).neg():u(e%d|0,e/d|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=s,n.fromBits=u;var c=Math.pow;function l(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return l(e.substring(1),t,n).neg();for(var a=s(c(n,8)),o=g,i=0;i<e.length;i+=8){var u=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+u),n);if(u<8){var d=s(c(n,u));o=o.mul(d).add(s(h))}else o=(o=o.mul(a)).add(s(h))}return o.unsigned=t,o}function h(e,t){return"number"===typeof e?s(e,t):"string"===typeof e?l(e,t):u(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=l,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var v=i(1,!0);n.UONE=v;var x=i(-1);n.NEG_ONE=x;var w=u(-1,2147483647,!1);n.MAX_VALUE=w;var k=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var C=u(0,-2147483648,!1);n.MIN_VALUE=C;var D=n.prototype;D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},D.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(C)){var t=s(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=s(c(e,6),this.unsigned),o=this,i="";;){var u=o.div(a),l=(o.sub(u.mul(a)).toInt()>>>0).toString(e);if((o=u).isZero())return l+i;for(;l.length<6;)l="0"+l;i=""+l+i}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(C)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},D.isZero=function(){return 0===this.high&&0===this.low},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return 1===(1&this.low)},D.isEven=function(){return 0===(1&this.low)},D.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},D.eq=D.equals,D.notEquals=function(e){return!this.eq(e)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(e){return this.comp(e)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(e){return this.comp(e)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(e){return this.comp(e)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(e){return this.comp(e)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(C)?C:this.not().add(b)},D.neg=D.negate,D.add=function(e){r(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,o=65535&this.low,i=e.high>>>16,s=65535&e.high,c=e.low>>>16,l=0,d=0,p=0,f=0;return p+=(f+=o+(65535&e.low))>>>16,d+=(p+=a+c)>>>16,l+=(d+=n+s)>>>16,l+=t+i,u((p&=65535)<<16|(f&=65535),(l&=65535)<<16|(d&=65535),this.unsigned)},D.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},D.sub=D.subtract,D.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=h(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(C))return e.isOdd()?C:g;if(e.eq(C))return this.isOdd()?C:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return s(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,o=this.low>>>16,i=65535&this.low,c=e.high>>>16,l=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=i*p)>>>16,y+=(b+=o*p)>>>16,b&=65535,y+=(b+=i*d)>>>16,f+=(y+=a*p)>>>16,y&=65535,f+=(y+=o*d)>>>16,y&=65535,f+=(y+=i*l)>>>16,f+=n*p+a*d+o*l+i*c,u((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},D.mul=D.multiply,D.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,a,o;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;o=y}else{if(this.eq(C))return e.eq(b)||e.eq(x)?C:e.eq(C)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:x:(a=this.sub(e.mul(n)),o=n.add(a.div(e)));if(e.eq(C))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=g}for(a=this;a.gte(e);){n=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),l=i<=48?1:c(2,i-48),d=s(n),p=d.mul(e);p.isNegative()||p.gt(a);)p=(d=s(n-=l,this.unsigned)).mul(e);d.isZero()&&(d=b),o=o.add(d),a=a.sub(p)}return o},D.div=D.divide,D.modulo=function(e){return r(e)||(e=h(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return u(~this.low,~this.high,this.unsigned)},D.and=function(e){return r(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},D.or=function(e){return r(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},D.xor=function(e){return r(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},D.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},D.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},D.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},160:e=>{"use strict";e.exports=function(e){return{size:(t,n)=>function(e,t,n){n||(n=t);let r=[];for(let a=0;a<t;a++){let t=[];for(let r=0;r<n;r++)t[r]=e;r[a]=t}return r}(e,t,n),diag:(t,n)=>function(e,t,n){n||(n=t);let r=[];for(let a=0;a<t;a++){let o=[];for(let e=0;e<n;e++)o[e]=0;r[a]=o,(a<n||t==n)&&(r[a][a]=e)}return r}(e,t,n)}}},447:(e,t,n)=>{"use strict";const r=n(881),a=n(727),o=n(160);function i(e){if(!Array.isArray(e))throw new Error("Input should be of type array");return Object.assign((function(){let t=1===arguments.length?[arguments[0]]:Array.apply(null,arguments);return function(e,t){return 0===t.length?e:function(e,t){let n=u(e);for(let r=0;r<n;r++){let n=t[r];if(void 0===n)break;Array.isArray(n)?e=c(e,n,r):Number.isInteger(n)&&(e=u(e)>1&&r>0?e.map((function(e){return[e[n]]})):e[n])}return e}(e,t)}(e,t)}),function(e){return{size:()=>s(e),add:t=>l(e,t,h),sub:t=>l(e,t,d),mul:t=>l(e,t,p),div:t=>l(e,t,f),prod:t=>function(e,t){let n=e,r=t(),a=s(n),o=s(r),i=[];if(a[1]===o[0])for(let s=0;s<a[0];s++){i[s]=[];for(let e=0;e<o[1];e++)for(let t=0;t<a[1];t++)void 0===i[s][e]&&(i[s][e]=0),i[s][e]+=p(n[s][t],r[t][e])}return i}(e,t),trans:()=>function(e){let t=e,n=s(e),r=[];for(let a=0;a<n[0];a++)for(let e=0;e<n[1];e++)Array.isArray(r[e])?r[e].push(t[a][e]):r[e]=[t[a][e]];return r}(e),set:function(){let t=1===arguments.length?[arguments[0]]:Array.apply(null,arguments);return{to:n=>function(e,t,n){let r=function(e){let t=[];for(let n=0;n<e.length;n++)t.push(e[n].slice(0));return t}(e),a=n[0],o=a[0]||0,i=a[1]&&a[1]+1||e.length;if(Array.isArray(a)||1!==n.length){if(1===n.length)for(let s=o;s<i;s++)r[s].fill(t)}else r[a].fill(t);for(let s=1;s<n.length;s++){let u=Array.isArray(n[s])?n[s][0]||0:n[s],c=Array.isArray(n[s])?n[s][1]&&n[s][1]+1||e[0].length:n[s]+1;if(Array.isArray(a))for(let e=o;e<i;e++)r[e].fill(t,u,c);else r[a].fill(t,u,c)}return r}(e,n,t)}},det:()=>function(e){let t=g(e),n=s(e),a=r(1),o=1;for(let i=0;i<n[0]-1;i++)for(let e=i+1;e<n[0];e++){if(0===t[e][i].num)continue;if(0===t[i][i].num){m(t,i,e),o=-o;continue}let a=t[e][i].div(t[i][i]);a=r(Math.abs(a.num),a.den),Math.sign(t[e][i].num)===Math.sign(t[i][i].num)&&(a=r(-a.num,a.den));for(let r=0;r<n[1];r++)t[e][r]=a.mul(t[i][r]).add(t[e][r])}return a=t.reduce(((e,t,n)=>e.mul(t[n])),r(1)),o*a.num/a.den}(e),inv:()=>function(e){let t=g(e),n=s(e),a=g(o(1).diag(n[0])),i=0,u=0;for(;u<n[0];){if(0===t[i][u].num)for(let e=i+1;e<n[0];e++)0!==t[e][u].num&&(m(t,i,e),m(a,i,e));if(0!==t[i][u].num){if(1!==t[i][u].num||1!==t[i][u].den){let e=r(t[i][u].num,t[i][u].den);for(let r=0;r<n[1];r++)t[i][r]=t[i][r].div(e),a[i][r]=a[i][r].div(e)}for(let e=i+1;e<n[0];e++){let r=t[e][u];for(let o=0;o<n[1];o++)t[e][o]=t[e][o].sub(r.mul(t[i][o])),a[e][o]=a[e][o].sub(r.mul(a[i][o]))}}i+=1,u+=1}let c=n[0]-1;if(1!==t[c][c].num||1!==t[c][c].den){let e=r(t[c][c].num,t[c][c].den);for(let r=0;r<n[1];r++)t[c][r]=t[c][r].div(e),a[c][r]=a[c][r].div(e)}for(let o=n[0]-1;o>0;o--)for(let e=o-1;e>=0;e--){let i=r(-t[e][o].num,t[e][o].den);for(let r=0;r<n[1];r++)t[e][r]=i.mul(t[o][r]).add(t[e][r]),a[e][r]=i.mul(a[o][r]).add(a[e][r])}return function(e){let t=[];return e.forEach(((e,n)=>{t.push(e.map((e=>e.num/e.den)))})),t}(a)}(e),merge:a(e),map:t=>function(e,t){const n=s(e),r=[];for(let a=0;a<n[0];a++)if(Array.isArray(e[a])){r[a]=[];for(let o=0;o<n[1];o++)r[a][o]=t(e[a][o],[a,o],e)}else r[a]=t(e[a],[a,0],e);return r}(e,t),equals:t=>function(e,t){let n=e,r=t(),a=s(n),o=s(r);if(!a.every(((e,t)=>e===o[t])))return!1;return n.every(((e,t)=>e.every(((e,n)=>Math.abs(e-r[t][n])<1e-10))))}(e,t)}}(e))}function s(e){let t=[];for(;Array.isArray(e);)t.push(e.length),e=e[0];return t}function u(e){return s(e).length}function c(e,t,n){if(!t.length)return e;if(2===t.length){let r=t[0]>t[1],a=r?t[1]:t[0],o=r?t[0]:t[1];return u(e)>1&&n>0?e.map((function(e){return r?e.slice(a,o+1).reverse():e.slice(a,o+1)})):(e=e.slice(a,o+1),r&&e.reverse()||e)}}function l(e,t,n){let r=[],a=t();for(let o=0;o<e.length;o++){let t=e[o],i=a[o];r.push(t.map((function(e,t){return n(e,i[t])})))}return r}function h(e,t){return e+t}function d(e,t){return e-t}function p(e,t){return e*t}function f(e,t){return e/t}function m(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function g(e){let t=[];return e.forEach(((e,n)=>{t.push(e.map((e=>r(e))))})),t}i.gen=o,e.exports=i},727:e=>{"use strict";e.exports=function(e){return{top:t=>function(e,t){let n=e[0].length||e.length,r=t[t.length-1].length||t.length;if(n!==r)return e;Array.isArray(e[0])||(e=[e]);Array.isArray(t[t.length-1])||(t=[t]);for(let a=t.length-1;a>=0;a--)e.unshift(t[a].map((e=>e)));return e}(e,t),bottom:t=>function(e,t){let n=e[e.length-1].length||e.length,r=t[0].length||t.length;if(n!==r)return e;Array.isArray(e[e.length-1])||(e=[e]);Array.isArray(t[0])||(t=[t]);for(let a=0;a<t.length;a++)e.push(t[a].map((e=>e)));return e}(e,t),left:t=>function(e,t){let n=e.length,r=t.length;if(!Array.isArray(e[0])&&!Array.isArray(t[0]))return e.unshift.apply(e,t),e;if(n!==r)return e;for(let a=0;a<n;a++)e[a].unshift.apply(e[a],t[a].map((e=>e)));return e}(e,t),right:t=>function(e,t){let n=e.length,r=t.length;if(!Array.isArray(e[0])&&!Array.isArray(t[0]))return e.push.apply(e,t),e;if(n!==r)return e;for(let a=0;a<n;a++)e[a].push.apply(e[a],t[a].map((e=>e)));return e}(e,t)}}},881:e=>{"use strict";function t(e,r){return r=r||1,-1===Math.sign(r)&&(e=-e,r=-r),{num:e,den:r,add:n=>t(e*n.den+r*n.num,r*n.den),sub:n=>t(e*n.den-r*n.num,r*n.den),mul:t=>n(t,e,r),div:a=>n(t(a.den,a.num),e,r)}}function n(e,n,r){let a=Math.sign(n)*Math.sign(e.num),o=Math.sign(r)*Math.sign(e.den);return Math.abs(n)===Math.abs(e.den)&&Math.abs(r)===Math.abs(e.num)||(Math.abs(r)===Math.abs(e.num)?(a*=Math.abs(n),o*=Math.abs(e.den)):Math.abs(n)===Math.abs(e.den)?(a*=Math.abs(e.num),o*=Math.abs(r)):(a=n*e.num,o=r*e.den)),t(a,o)}e.exports=t},554:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var numeric=exports;"undefined"!==typeof __webpack_require__.g&&(__webpack_require__.g.numeric=numeric),numeric.version="1.2.6",numeric.bench=function(e,t){var n,r,a;for("undefined"===typeof t&&(t=15),r=.5,n=new Date;;){for(a=r*=2;a>3;a-=4)e(),e(),e(),e();for(;a>0;)e(),a--;if(new Date-n>t)break}for(a=r;a>3;a-=4)e(),e(),e(),e();for(;a>0;)e(),a--;return 1e3*(3*r-1)/(new Date-n)},numeric._myIndexOf=function(e){var t,n=this.length;for(t=0;t<n;++t)if(this[t]===e)return t;return-1},numeric.myIndexOf=Array.prototype.indexOf?Array.prototype.indexOf:numeric._myIndexOf,numeric.Function=Function,numeric.precision=4,numeric.largeArray=50,numeric.prettyPrint=function(e){function t(e){if(0===e)return"0";if(isNaN(e))return"NaN";if(e<0)return"-"+t(-e);if(isFinite(e)){var n=Math.floor(Math.log(e)/Math.log(10)),r=e/Math.pow(10,n),a=r.toPrecision(numeric.precision);return 10===parseFloat(a)&&(n++,a=(r=1).toPrecision(numeric.precision)),parseFloat(a).toString()+"e"+n.toString()}return"Infinity"}var n=[];return function e(r){var a;if("undefined"===typeof r)return n.push(Array(numeric.precision+8).join(" ")),!1;if("string"===typeof r)return n.push('"'+r+'"'),!1;if("boolean"===typeof r)return n.push(r.toString()),!1;if("number"===typeof r){var o=t(r),i=r.toPrecision(numeric.precision),s=parseFloat(r.toString()).toString(),u=[o,i,s,parseFloat(i).toString(),parseFloat(s).toString()];for(a=1;a<u.length;a++)u[a].length<o.length&&(o=u[a]);return n.push(Array(numeric.precision+8-o.length).join(" ")+o),!1}if(null===r)return n.push("null"),!1;if("function"===typeof r){n.push(r.toString());var c=!1;for(a in r)r.hasOwnProperty(a)&&(c?n.push(",\n"):n.push("\n{"),c=!0,n.push(a),n.push(": \n"),e(r[a]));return c&&n.push("}\n"),!0}if(r instanceof Array){if(r.length>numeric.largeArray)return n.push("...Large Array..."),!0;c=!1;for(n.push("["),a=0;a<r.length;a++)a>0&&(n.push(","),c&&n.push("\n ")),c=e(r[a]);return n.push("]"),!0}for(a in n.push("{"),c=!1,r)r.hasOwnProperty(a)&&(c&&n.push(",\n"),c=!0,n.push(a),n.push(": \n"),e(r[a]));return n.push("}"),!0}(e),n.join("")},numeric.parseDate=function(e){return function e(t){if("string"===typeof t)return Date.parse(t.replace(/-/g,"/"));if(!(t instanceof Array))throw new Error("parseDate: parameter must be arrays of strings");var n,r=[];for(n=0;n<t.length;n++)r[n]=e(t[n]);return r}(e)},numeric.parseFloat=function(e){return function e(t){if("string"===typeof t)return parseFloat(t);if(!(t instanceof Array))throw new Error("parseFloat: parameter must be arrays of strings");var n,r=[];for(n=0;n<t.length;n++)r[n]=e(t[n]);return r}(e)},numeric.parseCSV=function(e){var t,n,r,a=e.split("\n"),o=[],i=/(([^'",]*)|('[^']*')|("[^"]*")),/g,s=/^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/,u=0;for(n=0;n<a.length;n++){var c,l=(a[n]+",").match(i);if(l.length>0){for(o[u]=[],t=0;t<l.length;t++)c=(r=l[t]).substr(0,r.length-1),s.test(c)?o[u][t]=parseFloat(c):o[u][t]=c;u++}}return o},numeric.toCSV=function(e){var t,n,r,a,o,i=numeric.dim(e);for(r=i[0],i[1],o=[],t=0;t<r;t++){for(a=[],n=0;n<r;n++)a[n]=e[t][n].toString();o[t]=a.join(", ")}return o.join("\n")+"\n"},numeric.getURL=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(),t},numeric.imageURL=function(e){function t(e,t,n){"undefined"===typeof t&&(t=0),"undefined"===typeof n&&(n=e.length);var r,a=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],o=-1;e.length;for(r=t;r<n;r++)o=o>>>8^a[255&(o^e[r])];return~o}var n,r,a,o,i,s,u,c,l,h,d=e[0].length,p=e[0][0].length,f=[137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,p>>24&255,p>>16&255,p>>8&255,255&p,d>>24&255,d>>16&255,d>>8&255,255&d,8,2,0,0,0,-1,-2,-3,-4,-5,-6,-7,-8,73,68,65,84,8,29];for(h=t(f,12,29),f[29]=h>>24&255,f[30]=h>>16&255,f[31]=h>>8&255,f[32]=255&h,n=1,r=0,u=0;u<d;u++){for(u<d-1?f.push(0):f.push(1),i=3*p+1+(0===u)&255,s=3*p+1+(0===u)>>8&255,f.push(i),f.push(s),f.push(255&~i),f.push(255&~s),0===u&&f.push(0),c=0;c<p;c++)for(a=0;a<3;a++)r=(r+(n=(n+(i=(i=e[a][u][c])>255?255:i<0?0:Math.round(i)))%65521))%65521,f.push(i);f.push(0)}return l=(r<<16)+n,f.push(l>>24&255),f.push(l>>16&255),f.push(l>>8&255),f.push(255&l),o=f.length-41,f[33]=o>>24&255,f[34]=o>>16&255,f[35]=o>>8&255,f[36]=255&o,h=t(f,37),f.push(h>>24&255),f.push(h>>16&255),f.push(h>>8&255),f.push(255&h),f.push(0),f.push(0),f.push(0),f.push(0),f.push(73),f.push(69),f.push(78),f.push(68),f.push(174),f.push(66),f.push(96),f.push(130),"data:image/png;base64,"+function(e){var t,n,r,a,o,i,s,u=e.length,c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",l="";for(t=0;t<u;t+=3)o=((3&(n=e[t]))<<4)+((r=e[t+1])>>4),i=((15&r)<<2)+((a=e[t+2])>>6),s=63&a,t+1>=u?i=s=64:t+2>=u&&(s=64),l+=c.charAt(n>>2)+c.charAt(o)+c.charAt(i)+c.charAt(s);return l}(f)},numeric._dim=function(e){for(var t=[];"object"===typeof e;)t.push(e.length),e=e[0];return t},numeric.dim=function(e){var t;return"object"===typeof e?"object"===typeof(t=e[0])?"object"===typeof t[0]?numeric._dim(e):[e.length,t.length]:[e.length]:[]},numeric.mapreduce=function(e,t){return Function("x","accum","_s","_k",'if(typeof accum === "undefined") accum = '+t+';\nif(typeof x === "number") { var xi = x; '+e+'; return accum; }\nif(typeof _s === "undefined") _s = numeric.dim(x);\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i,xi;\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) {\n        accum = arguments.callee(x[i],accum,_s,_k+1);\n    }    return accum;\n}\nfor(i=_n-1;i>=1;i-=2) { \n    xi = x[i];\n    '+e+";\n    xi = x[i-1];\n    "+e+";\n}\nif(i === 0) {\n    xi = x[i];\n    "+e+"\n}\nreturn accum;")},numeric.mapreduce2=function(e,t){return Function("x","var n = x.length;\nvar i,xi;\n"+t+";\nfor(i=n-1;i!==-1;--i) { \n    xi = x[i];\n    "+e+";\n}\nreturn accum;")},numeric.same=function e(t,n){var r,a;if(!(t instanceof Array)||!(n instanceof Array))return!1;if((a=t.length)!==n.length)return!1;for(r=0;r<a;r++)if(t[r]!==n[r]){if("object"!==typeof t[r])return!1;if(!e(t[r],n[r]))return!1}return!0},numeric.rep=function(e,t,n){"undefined"===typeof n&&(n=0);var r,a=e[n],o=Array(a);if(n===e.length-1){for(r=a-2;r>=0;r-=2)o[r+1]=t,o[r]=t;return-1===r&&(o[0]=t),o}for(r=a-1;r>=0;r--)o[r]=numeric.rep(e,t,n+1);return o},numeric.dotMMsmall=function(e,t){var n,r,a,o,i,s,u,c,l,h,d;for(o=e.length,i=t.length,s=t[0].length,u=Array(o),n=o-1;n>=0;n--){for(c=Array(s),l=e[n],a=s-1;a>=0;a--){for(h=l[i-1]*t[i-1][a],r=i-2;r>=1;r-=2)d=r-1,h+=l[r]*t[r][a]+l[d]*t[d][a];0===r&&(h+=l[0]*t[0][a]),c[a]=h}u[n]=c}return u},numeric._getCol=function(e,t,n){var r;for(r=e.length-1;r>0;--r)n[r]=e[r][t],n[--r]=e[r][t];0===r&&(n[0]=e[0][t])},numeric.dotMMbig=function(e,t){var n,r,a,o=numeric._getCol,i=t.length,s=Array(i),u=e.length,c=t[0].length,l=new Array(u),h=numeric.dotVV;for(--i,r=--u;-1!==r;--r)l[r]=Array(c);for(r=--c;-1!==r;--r)for(o(t,r,s),a=u;-1!==a;--a)n=e[a],l[a][r]=h(n,s);return l},numeric.dotMV=function(e,t){var n,r=e.length,a=(t.length,Array(r)),o=numeric.dotVV;for(n=r-1;n>=0;n--)a[n]=o(e[n],t);return a},numeric.dotVM=function(e,t){var n,r,a,o,i,s,u;for(a=e.length,o=t[0].length,i=Array(o),r=o-1;r>=0;r--){for(s=e[a-1]*t[a-1][r],n=a-2;n>=1;n-=2)u=n-1,s+=e[n]*t[n][r]+e[u]*t[u][r];0===n&&(s+=e[0]*t[0][r]),i[r]=s}return i},numeric.dotVV=function(e,t){var n,r,a=e.length,o=e[a-1]*t[a-1];for(n=a-2;n>=1;n-=2)r=n-1,o+=e[n]*t[n]+e[r]*t[r];return 0===n&&(o+=e[0]*t[0]),o},numeric.dot=function(e,t){var n=numeric.dim;switch(1e3*n(e).length+n(t).length){case 2002:return t.length<10?numeric.dotMMsmall(e,t):numeric.dotMMbig(e,t);case 2001:return numeric.dotMV(e,t);case 1002:return numeric.dotVM(e,t);case 1001:return numeric.dotVV(e,t);case 1e3:return numeric.mulVS(e,t);case 1:return numeric.mulSV(e,t);case 0:return e*t;default:throw new Error("numeric.dot only works on vectors and matrices")}},numeric.diag=function(e){var t,n,r,a,o=e.length,i=Array(o);for(t=o-1;t>=0;t--){for(a=Array(o),n=t+2,r=o-1;r>=n;r-=2)a[r]=0,a[r-1]=0;for(r>t&&(a[r]=0),a[t]=e[t],r=t-1;r>=1;r-=2)a[r]=0,a[r-1]=0;0===r&&(a[0]=0),i[t]=a}return i},numeric.getDiag=function(e){var t,n=Math.min(e.length,e[0].length),r=Array(n);for(t=n-1;t>=1;--t)r[t]=e[t][t],r[--t]=e[t][t];return 0===t&&(r[0]=e[0][0]),r},numeric.identity=function(e){return numeric.diag(numeric.rep([e],1))},numeric.pointwise=function(e,t,n){"undefined"===typeof n&&(n="");var r,a,o=[],i=/\[i\]$/,s="",u=!1;for(r=0;r<e.length;r++)i.test(e[r])?s=a=e[r].substring(0,e[r].length-3):a=e[r],"ret"===a&&(u=!0),o.push(a);return o[e.length]="_s",o[e.length+1]="_k",o[e.length+2]='if(typeof _s === "undefined") _s = numeric.dim('+s+');\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i'+(u?"":", ret = Array(_n)")+";\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee("+e.join(",")+",_s,_k+1);\n    return ret;\n}\n"+n+"\nfor(i=_n-1;i!==-1;--i) {\n    "+t+"\n}\nreturn ret;",Function.apply(null,o)},numeric.pointwise2=function(e,t,n){"undefined"===typeof n&&(n="");var r,a,o=[],i=/\[i\]$/,s="",u=!1;for(r=0;r<e.length;r++)i.test(e[r])?s=a=e[r].substring(0,e[r].length-3):a=e[r],"ret"===a&&(u=!0),o.push(a);return o[e.length]="var _n = "+s+".length;\nvar i"+(u?"":", ret = Array(_n)")+";\n"+n+"\nfor(i=_n-1;i!==-1;--i) {\n"+t+"\n}\nreturn ret;",Function.apply(null,o)},numeric._biforeach=function e(t,n,r,a,o){var i;if(a!==r.length-1)for(i=r[a]-1;i>=0;i--)e("object"===typeof t?t[i]:t,"object"===typeof n?n[i]:n,r,a+1,o);else o(t,n)},numeric._biforeach2=function e(t,n,r,a,o){if(a===r.length-1)return o(t,n);var i,s=r[a],u=Array(s);for(i=s-1;i>=0;--i)u[i]=e("object"===typeof t?t[i]:t,"object"===typeof n?n[i]:n,r,a+1,o);return u},numeric._foreach=function e(t,n,r,a){var o;if(r!==n.length-1)for(o=n[r]-1;o>=0;o--)e(t[o],n,r+1,a);else a(t)},numeric._foreach2=function e(t,n,r,a){if(r===n.length-1)return a(t);var o,i=n[r],s=Array(i);for(o=i-1;o>=0;o--)s[o]=e(t[o],n,r+1,a);return s},numeric.ops2={add:"+",sub:"-",mul:"*",div:"/",mod:"%",and:"&&",or:"||",eq:"===",neq:"!==",lt:"<",gt:">",leq:"<=",geq:">=",band:"&",bor:"|",bxor:"^",lshift:"<<",rshift:">>",rrshift:">>>"},numeric.opseq={addeq:"+=",subeq:"-=",muleq:"*=",diveq:"/=",modeq:"%=",lshifteq:"<<=",rshifteq:">>=",rrshifteq:">>>=",bandeq:"&=",boreq:"|=",bxoreq:"^="},numeric.mathfuns=["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan","isNaN","isFinite"],numeric.mathfuns2=["atan2","pow","max","min"],numeric.ops1={neg:"-",not:"!",bnot:"~",clone:""},numeric.mapreducers={any:["if(xi) return true;","var accum = false;"],all:["if(!xi) return false;","var accum = true;"],sum:["accum += xi;","var accum = 0;"],prod:["accum *= xi;","var accum = 1;"],norm2Squared:["accum += xi*xi;","var accum = 0;"],norminf:["accum = max(accum,abs(xi));","var accum = 0, max = Math.max, abs = Math.abs;"],norm1:["accum += abs(xi)","var accum = 0, abs = Math.abs;"],sup:["accum = max(accum,xi);","var accum = -Infinity, max = Math.max;"],inf:["accum = min(accum,xi);","var accum = Infinity, min = Math.min;"]},function(){var e,t;for(e=0;e<numeric.mathfuns2.length;++e)t=numeric.mathfuns2[e],numeric.ops2[t]=t;for(e in numeric.ops2)if(numeric.ops2.hasOwnProperty(e)){t=numeric.ops2[e];var n,r,a="";-1!==numeric.myIndexOf.call(numeric.mathfuns2,e)?(a="var "+t+" = Math."+t+";\n",n=function(e,n,r){return e+" = "+t+"("+n+","+r+")"},r=function(e,n){return e+" = "+t+"("+e+","+n+")"}):(n=function(e,n,r){return e+" = "+n+" "+t+" "+r},r=numeric.opseq.hasOwnProperty(e+"eq")?function(e,n){return e+" "+t+"= "+n}:function(e,n){return e+" = "+e+" "+t+" "+n}),numeric[e+"VV"]=numeric.pointwise2(["x[i]","y[i]"],n("ret[i]","x[i]","y[i]"),a),numeric[e+"SV"]=numeric.pointwise2(["x","y[i]"],n("ret[i]","x","y[i]"),a),numeric[e+"VS"]=numeric.pointwise2(["x[i]","y"],n("ret[i]","x[i]","y"),a),numeric[e]=Function("var n = arguments.length, i, x = arguments[0], y;\nvar VV = numeric."+e+"VV, VS = numeric."+e+"VS, SV = numeric."+e+'SV;\nvar dim = numeric.dim;\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof x === "object") {\n      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n  else '+r("x","y")+"\n}\nreturn x;\n"),numeric[t]=numeric[e],numeric[e+"eqV"]=numeric.pointwise2(["ret[i]","x[i]"],r("ret[i]","x[i]"),a),numeric[e+"eqS"]=numeric.pointwise2(["ret[i]","x"],r("ret[i]","x"),a),numeric[e+"eq"]=Function("var n = arguments.length, i, x = arguments[0], y;\nvar V = numeric."+e+"eqV, S = numeric."+e+'eqS\nvar s = numeric.dim(x);\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n  else numeric._biforeach(x,y,s,0,S);\n}\nreturn x;\n')}for(e=0;e<numeric.mathfuns2.length;++e)t=numeric.mathfuns2[e],delete numeric.ops2[t];for(e=0;e<numeric.mathfuns.length;++e)t=numeric.mathfuns[e],numeric.ops1[t]=t;for(e in numeric.ops1)numeric.ops1.hasOwnProperty(e)&&(a="",t=numeric.ops1[e],-1!==numeric.myIndexOf.call(numeric.mathfuns,e)&&Math.hasOwnProperty(t)&&(a="var "+t+" = Math."+t+";\n"),numeric[e+"eqV"]=numeric.pointwise2(["ret[i]"],"ret[i] = "+t+"(ret[i]);",a),numeric[e+"eq"]=Function("x",'if(typeof x !== "object") return '+t+"x\nvar i;\nvar V = numeric."+e+"eqV;\nvar s = numeric.dim(x);\nnumeric._foreach(x,s,0,V);\nreturn x;\n"),numeric[e+"V"]=numeric.pointwise2(["x[i]"],"ret[i] = "+t+"(x[i]);",a),numeric[e]=Function("x",'if(typeof x !== "object") return '+t+"(x)\nvar i;\nvar V = numeric."+e+"V;\nvar s = numeric.dim(x);\nreturn numeric._foreach2(x,s,0,V);\n"));for(e=0;e<numeric.mathfuns.length;++e)t=numeric.mathfuns[e],delete numeric.ops1[t];for(e in numeric.mapreducers)numeric.mapreducers.hasOwnProperty(e)&&(t=numeric.mapreducers[e],numeric[e+"V"]=numeric.mapreduce2(t[0],t[1]),numeric[e]=Function("x","s","k",t[1]+'if(typeof x !== "object") {    xi = x;\n'+t[0]+';\n    return accum;\n}if(typeof s === "undefined") s = numeric.dim(x);\nif(typeof k === "undefined") k = 0;\nif(k === s.length-1) return numeric.'+e+"V(x);\nvar xi;\nvar n = x.length, i;\nfor(i=n-1;i!==-1;--i) {\n   xi = arguments.callee(x[i]);\n"+t[0]+";\n}\nreturn accum;\n"))}(),numeric.truncVV=numeric.pointwise(["x[i]","y[i]"],"ret[i] = round(x[i]/y[i])*y[i];","var round = Math.round;"),numeric.truncVS=numeric.pointwise(["x[i]","y"],"ret[i] = round(x[i]/y)*y;","var round = Math.round;"),numeric.truncSV=numeric.pointwise(["x","y[i]"],"ret[i] = round(x/y[i])*y[i];","var round = Math.round;"),numeric.trunc=function(e,t){return"object"===typeof e?"object"===typeof t?numeric.truncVV(e,t):numeric.truncVS(e,t):"object"===typeof t?numeric.truncSV(e,t):Math.round(e/t)*t},numeric.inv=function(e){var t,n,r,a,o,i,s,u=numeric.dim(e),c=Math.abs,l=u[0],h=u[1],d=numeric.clone(e),p=numeric.identity(l);for(i=0;i<h;++i){var f=-1,m=-1;for(o=i;o!==l;++o)(s=c(d[o][i]))>m&&(f=o,m=s);for(n=d[f],d[f]=d[i],d[i]=n,a=p[f],p[f]=p[i],p[i]=a,e=n[i],s=i;s!==h;++s)n[s]/=e;for(s=h-1;-1!==s;--s)a[s]/=e;for(o=l-1;-1!==o;--o)if(o!==i){for(t=d[o],r=p[o],e=t[i],s=i+1;s!==h;++s)t[s]-=n[s]*e;for(s=h-1;s>0;--s)r[s]-=a[s]*e,r[--s]-=a[s]*e;0===s&&(r[0]-=a[0]*e)}}return p},numeric.det=function(e){var t=numeric.dim(e);if(2!==t.length||t[0]!==t[1])throw new Error("numeric: det() only works on square matrices");var n,r,a,o,i,s,u,c,l=t[0],h=1,d=numeric.clone(e);for(r=0;r<l-1;r++){for(a=r,n=r+1;n<l;n++)Math.abs(d[n][r])>Math.abs(d[a][r])&&(a=n);for(a!==r&&(u=d[a],d[a]=d[r],d[r]=u,h*=-1),o=d[r],n=r+1;n<l;n++){for(s=(i=d[n])[r]/o[r],a=r+1;a<l-1;a+=2)c=a+1,i[a]-=o[a]*s,i[c]-=o[c]*s;a!==l&&(i[a]-=o[a]*s)}if(0===o[r])return 0;h*=o[r]}return h*d[r][r]},numeric.transpose=function(e){var t,n,r,a,o,i=e.length,s=e[0].length,u=Array(s);for(n=0;n<s;n++)u[n]=Array(i);for(t=i-1;t>=1;t-=2){for(a=e[t],r=e[t-1],n=s-1;n>=1;--n)(o=u[n])[t]=a[n],o[t-1]=r[n],(o=u[--n])[t]=a[n],o[t-1]=r[n];0===n&&((o=u[0])[t]=a[0],o[t-1]=r[0])}if(0===t){for(r=e[0],n=s-1;n>=1;--n)u[n][0]=r[n],u[--n][0]=r[n];0===n&&(u[0][0]=r[0])}return u},numeric.negtranspose=function(e){var t,n,r,a,o,i=e.length,s=e[0].length,u=Array(s);for(n=0;n<s;n++)u[n]=Array(i);for(t=i-1;t>=1;t-=2){for(a=e[t],r=e[t-1],n=s-1;n>=1;--n)(o=u[n])[t]=-a[n],o[t-1]=-r[n],(o=u[--n])[t]=-a[n],o[t-1]=-r[n];0===n&&((o=u[0])[t]=-a[0],o[t-1]=-r[0])}if(0===t){for(r=e[0],n=s-1;n>=1;--n)u[n][0]=-r[n],u[--n][0]=-r[n];0===n&&(u[0][0]=-r[0])}return u},numeric._random=function e(t,n){var r,a,o=t[n],i=Array(o);if(n===t.length-1){for(a=Math.random,r=o-1;r>=1;r-=2)i[r]=a(),i[r-1]=a();return 0===r&&(i[0]=a()),i}for(r=o-1;r>=0;r--)i[r]=e(t,n+1);return i},numeric.random=function(e){return numeric._random(e,0)},numeric.norm2=function(e){return Math.sqrt(numeric.norm2Squared(e))},numeric.linspace=function(e,t,n){if("undefined"===typeof n&&(n=Math.max(Math.round(t-e)+1,1)),n<2)return 1===n?[e]:[];var r,a=Array(n);for(r=--n;r>=0;r--)a[r]=(r*t+(n-r)*e)/n;return a},numeric.getBlock=function(e,t,n){var r=numeric.dim(e);return function e(a,o){var i,s=t[o],u=n[o]-s,c=Array(u);if(o===r.length-1){for(i=u;i>=0;i--)c[i]=a[i+s];return c}for(i=u;i>=0;i--)c[i]=e(a[i+s],o+1);return c}(e,0)},numeric.setBlock=function(e,t,n,r){var a=numeric.dim(e);return function e(r,o,i){var s,u=t[i],c=n[i]-u;if(i===a.length-1)for(s=c;s>=0;s--)r[s+u]=o[s];for(s=c;s>=0;s--)e(r[s+u],o[s],i+1)}(e,r,0),e},numeric.getRange=function(e,t,n){var r,a,o,i,s=t.length,u=n.length,c=Array(s);for(r=s-1;-1!==r;--r)for(c[r]=Array(u),o=c[r],i=e[t[r]],a=u-1;-1!==a;--a)o[a]=i[n[a]];return c},numeric.blockMatrix=function(e){var t=numeric.dim(e);if(t.length<4)return numeric.blockMatrix([e]);var n,r,a,o,i,s=t[0],u=t[1];for(n=0,r=0,a=0;a<s;++a)n+=e[a][0].length;for(o=0;o<u;++o)r+=e[0][o][0].length;var c=Array(n);for(a=0;a<n;++a)c[a]=Array(r);var l,h,d,p,f,m=0;for(a=0;a<s;++a){for(l=r,o=u-1;-1!==o;--o)for(l-=(i=e[a][o])[0].length,d=i.length-1;-1!==d;--d)for(f=i[d],h=c[m+d],p=f.length-1;-1!==p;--p)h[l+p]=f[p];m+=e[a][0].length}return c},numeric.tensor=function(e,t){if("number"===typeof e||"number"===typeof t)return numeric.mul(e,t);var n=numeric.dim(e),r=numeric.dim(t);if(1!==n.length||1!==r.length)throw new Error("numeric: tensor product is only defined for vectors");var a,o,i,s,u=n[0],c=r[0],l=Array(u);for(o=u-1;o>=0;o--){for(a=Array(c),s=e[o],i=c-1;i>=3;--i)a[i]=s*t[i],a[--i]=s*t[i],a[--i]=s*t[i],a[--i]=s*t[i];for(;i>=0;)a[i]=s*t[i],--i;l[o]=a}return l},numeric.T=function(e,t){this.x=e,this.y=t},numeric.t=function(e,t){return new numeric.T(e,t)},numeric.Tbinop=function(e,t,n,r,a){var o;numeric.indexOf;if("string"!==typeof a)for(o in a="",numeric)numeric.hasOwnProperty(o)&&(e.indexOf(o)>=0||t.indexOf(o)>=0||n.indexOf(o)>=0||r.indexOf(o)>=0)&&o.length>1&&(a+="var "+o+" = numeric."+o+";\n");return Function(["y"],"var x = this;\nif(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n"+a+"\nif(x.y) {  if(y.y) {    return new numeric.T("+r+");\n  }\n  return new numeric.T("+n+");\n}\nif(y.y) {\n  return new numeric.T("+t+");\n}\nreturn new numeric.T("+e+");\n")},numeric.T.prototype.add=numeric.Tbinop("add(x.x,y.x)","add(x.x,y.x),y.y","add(x.x,y.x),x.y","add(x.x,y.x),add(x.y,y.y)"),numeric.T.prototype.sub=numeric.Tbinop("sub(x.x,y.x)","sub(x.x,y.x),neg(y.y)","sub(x.x,y.x),x.y","sub(x.x,y.x),sub(x.y,y.y)"),numeric.T.prototype.mul=numeric.Tbinop("mul(x.x,y.x)","mul(x.x,y.x),mul(x.x,y.y)","mul(x.x,y.x),mul(x.y,y.x)","sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))"),numeric.T.prototype.reciprocal=function(){var e=numeric.mul,t=numeric.div;if(this.y){var n=numeric.add(e(this.x,this.x),e(this.y,this.y));return new numeric.T(t(this.x,n),t(numeric.neg(this.y),n))}return new T(t(1,this.x))},numeric.T.prototype.div=function(e){if(e instanceof numeric.T||(e=new numeric.T(e)),e.y)return this.mul(e.reciprocal());var t=numeric.div;return this.y?new numeric.T(t(this.x,e.x),t(this.y,e.x)):new numeric.T(t(this.x,e.x))},numeric.T.prototype.dot=numeric.Tbinop("dot(x.x,y.x)","dot(x.x,y.x),dot(x.x,y.y)","dot(x.x,y.x),dot(x.y,y.x)","sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))"),numeric.T.prototype.transpose=function(){var e=numeric.transpose,t=this.x,n=this.y;return n?new numeric.T(e(t),e(n)):new numeric.T(e(t))},numeric.T.prototype.transjugate=function(){var e=numeric.transpose,t=this.x,n=this.y;return n?new numeric.T(e(t),numeric.negtranspose(n)):new numeric.T(e(t))},numeric.Tunop=function(e,t,n){return"string"!==typeof n&&(n=""),Function("var x = this;\n"+n+"\nif(x.y) {  "+t+";\n}\n"+e+";\n")},numeric.T.prototype.exp=numeric.Tunop("return new numeric.T(ex)","return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))","var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;"),numeric.T.prototype.conj=numeric.Tunop("return new numeric.T(x.x);","return new numeric.T(x.x,numeric.neg(x.y));"),numeric.T.prototype.neg=numeric.Tunop("return new numeric.T(neg(x.x));","return new numeric.T(neg(x.x),neg(x.y));","var neg = numeric.neg;"),numeric.T.prototype.sin=numeric.Tunop("return new numeric.T(numeric.sin(x.x))","return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));"),numeric.T.prototype.cos=numeric.Tunop("return new numeric.T(numeric.cos(x.x))","return x.exp().add(x.neg().exp()).div(2);"),numeric.T.prototype.abs=numeric.Tunop("return new numeric.T(numeric.abs(x.x));","return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));","var mul = numeric.mul;"),numeric.T.prototype.log=numeric.Tunop("return new numeric.T(numeric.log(x.x));","var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\nreturn new numeric.T(numeric.log(r.x),theta.x);"),numeric.T.prototype.norm2=numeric.Tunop("return numeric.norm2(x.x);","var f = numeric.norm2Squared;\nreturn Math.sqrt(f(x.x)+f(x.y));"),numeric.T.prototype.inv=function(){var e=this;if("undefined"===typeof e.y)return new numeric.T(numeric.inv(e.x));var t,n,r,a,o,i,s,u,c,l,h,d,p,f,m,g,y,b,v=e.x.length,x=numeric.identity(v),w=numeric.rep([v,v],0),k=numeric.clone(e.x),C=numeric.clone(e.y);for(c=0;c<v;c++){for(d=(f=k[c][c])*f+(m=C[c][c])*m,h=c,l=c+1;l<v;l++)(p=(f=k[l][c])*f+(m=C[l][c])*m)>d&&(h=l,d=p);for(h!==c&&(b=k[c],k[c]=k[h],k[h]=b,b=C[c],C[c]=C[h],C[h]=b,b=x[c],x[c]=x[h],x[h]=b,b=w[c],w[c]=w[h],w[h]=b),t=k[c],n=C[c],o=x[c],i=w[c],f=t[c],m=n[c],l=c+1;l<v;l++)g=t[l],y=n[l],t[l]=(g*f+y*m)/d,n[l]=(y*f-g*m)/d;for(l=0;l<v;l++)g=o[l],y=i[l],o[l]=(g*f+y*m)/d,i[l]=(y*f-g*m)/d;for(l=c+1;l<v;l++){for(r=k[l],a=C[l],s=x[l],u=w[l],f=r[c],m=a[c],h=c+1;h<v;h++)g=t[h],y=n[h],r[h]-=g*f-y*m,a[h]-=y*f+g*m;for(h=0;h<v;h++)g=o[h],y=i[h],s[h]-=g*f-y*m,u[h]-=y*f+g*m}}for(c=v-1;c>0;c--)for(o=x[c],i=w[c],l=c-1;l>=0;l--)for(s=x[l],u=w[l],f=k[l][c],m=C[l][c],h=v-1;h>=0;h--)g=o[h],y=i[h],s[h]-=f*g-m*y,u[h]-=f*y+m*g;return new numeric.T(x,w)},numeric.T.prototype.get=function(e){var t,n=this.x,r=this.y,a=0,o=e.length;if(r){for(;a<o;)n=n[t=e[a]],r=r[t],a++;return new numeric.T(n,r)}for(;a<o;)n=n[t=e[a]],a++;return new numeric.T(n)},numeric.T.prototype.set=function(e,t){var n,r=this.x,a=this.y,o=0,i=e.length,s=t.x,u=t.y;if(0===i)return u?this.y=u:a&&(this.y=void 0),this.x=r,this;if(u){for(a||(a=numeric.rep(numeric.dim(r),0),this.y=a);o<i-1;)r=r[n=e[o]],a=a[n],o++;return r[n=e[o]]=s,a[n]=u,this}if(a){for(;o<i-1;)r=r[n=e[o]],a=a[n],o++;return r[n=e[o]]=s,a[n]=s instanceof Array?numeric.rep(numeric.dim(s),0):0,this}for(;o<i-1;)r=r[n=e[o]],o++;return r[n=e[o]]=s,this},numeric.T.prototype.getRows=function(e,t){var n,r,a=t-e+1,o=Array(a),i=this.x,s=this.y;for(n=e;n<=t;n++)o[n-e]=i[n];if(s){for(r=Array(a),n=e;n<=t;n++)r[n-e]=s[n];return new numeric.T(o,r)}return new numeric.T(o)},numeric.T.prototype.setRows=function(e,t,n){var r,a=this.x,o=this.y,i=n.x,s=n.y;for(r=e;r<=t;r++)a[r]=i[r-e];if(s)for(o||(o=numeric.rep(numeric.dim(a),0),this.y=o),r=e;r<=t;r++)o[r]=s[r-e];else if(o)for(r=e;r<=t;r++)o[r]=numeric.rep([i[r-e].length],0);return this},numeric.T.prototype.getRow=function(e){var t=this.x,n=this.y;return n?new numeric.T(t[e],n[e]):new numeric.T(t[e])},numeric.T.prototype.setRow=function(e,t){var n=this.x,r=this.y,a=t.x,o=t.y;return n[e]=a,o?(r||(r=numeric.rep(numeric.dim(n),0),this.y=r),r[e]=o):r&&(r=numeric.rep([a.length],0)),this},numeric.T.prototype.getBlock=function(e,t){var n=this.x,r=this.y,a=numeric.getBlock;return r?new numeric.T(a(n,e,t),a(r,e,t)):new numeric.T(a(n,e,t))},numeric.T.prototype.setBlock=function(e,t,n){n instanceof numeric.T||(n=new numeric.T(n));var r=this.x,a=this.y,o=numeric.setBlock,i=n.x,s=n.y;if(s)return a||(this.y=numeric.rep(numeric.dim(this),0),a=this.y),o(r,e,t,i),o(a,e,t,s),this;o(r,e,t,i),a&&o(a,e,t,numeric.rep(numeric.dim(i),0))},numeric.T.rep=function(e,t){var n=numeric.T;t instanceof n||(t=new n(t));var r=t.x,a=t.y,o=numeric.rep;return a?new n(o(e,r),o(e,a)):new n(o(e,r))},numeric.T.diag=function(e){e instanceof numeric.T||(e=new numeric.T(e));var t=e.x,n=e.y,r=numeric.diag;return n?new numeric.T(r(t),r(n)):new numeric.T(r(t))},numeric.T.eig=function(){if(this.y)throw new Error("eig: not implemented for complex matrices.");return numeric.eig(this.x)},numeric.T.identity=function(e){return new numeric.T(numeric.identity(e))},numeric.T.prototype.getDiag=function(){var e=numeric,t=this.x,n=this.y;return n?new e.T(e.getDiag(t),e.getDiag(n)):new e.T(e.getDiag(t))},numeric.house=function(e){var t=numeric.clone(e),n=(e[0]>=0?1:-1)*numeric.norm2(e);t[0]+=n;var r=numeric.norm2(t);if(0===r)throw new Error("eig: internal error");return numeric.div(t,r)},numeric.toUpperHessenberg=function(e){var t=numeric.dim(e);if(2!==t.length||t[0]!==t[1])throw new Error("numeric: toUpperHessenberg() only works on square matrices");var n,r,a,o,i,s,u,c,l,h,d=t[0],p=numeric.clone(e),f=numeric.identity(d);for(r=0;r<d-2;r++){for(o=Array(d-r-1),n=r+1;n<d;n++)o[n-r-1]=p[n][r];if(numeric.norm2(o)>0){for(i=numeric.house(o),s=numeric.getBlock(p,[r+1,r],[d-1,d-1]),u=numeric.tensor(i,numeric.dot(i,s)),n=r+1;n<d;n++)for(c=p[n],l=u[n-r-1],a=r;a<d;a++)c[a]-=2*l[a-r];for(s=numeric.getBlock(p,[0,r+1],[d-1,d-1]),u=numeric.tensor(numeric.dot(s,i),i),n=0;n<d;n++)for(c=p[n],l=u[n],a=r+1;a<d;a++)c[a]-=2*l[a-r-1];for(s=Array(d-r-1),n=r+1;n<d;n++)s[n-r-1]=f[n];for(u=numeric.tensor(i,numeric.dot(i,s)),n=r+1;n<d;n++)for(h=f[n],l=u[n-r-1],a=0;a<d;a++)h[a]-=2*l[a]}}return{H:p,Q:f}},numeric.epsilon=2220446049250313e-31,numeric.QRFrancis=function(e,t){"undefined"===typeof t&&(t=1e4),e=numeric.clone(e);numeric.clone(e);var n,r,a,o,i,s,u,c,l,h,d,p,f,m,g,y,b,v,x=numeric.dim(e)[0],w=numeric.identity(x);if(x<3)return{Q:w,B:[[0,x-1]]};var k=numeric.epsilon;for(v=0;v<t;v++){for(y=0;y<x-1;y++)if(Math.abs(e[y+1][y])<k*(Math.abs(e[y][y])+Math.abs(e[y+1][y+1]))){var C=numeric.QRFrancis(numeric.getBlock(e,[0,0],[y,y]),t),D=numeric.QRFrancis(numeric.getBlock(e,[y+1,y+1],[x-1,x-1]),t);for(p=Array(y+1),g=0;g<=y;g++)p[g]=w[g];for(f=numeric.dot(C.Q,p),g=0;g<=y;g++)w[g]=f[g];for(p=Array(x-y-1),g=y+1;g<x;g++)p[g-y-1]=w[g];for(f=numeric.dot(D.Q,p),g=y+1;g<x;g++)w[g]=f[g-y-1];return{Q:w,B:C.B.concat(numeric.add(D.B,y+1))}}var S,E,I;if(a=e[x-2][x-2],o=e[x-2][x-1],i=e[x-1][x-2],c=a+(s=e[x-1][x-1]),u=a*s-o*i,l=numeric.getBlock(e,[0,0],[2,2]),c*c>=4*u)S=.5*(c+Math.sqrt(c*c-4*u)),E=.5*(c-Math.sqrt(c*c-4*u)),l=numeric.add(numeric.sub(numeric.dot(l,l),numeric.mul(l,S+E)),numeric.diag(numeric.rep([3],S*E)));else l=numeric.add(numeric.sub(numeric.dot(l,l),numeric.mul(l,c)),numeric.diag(numeric.rep([3],u)));for(n=[l[0][0],l[1][0],l[2][0]],r=numeric.house(n),p=[e[0],e[1],e[2]],f=numeric.tensor(r,numeric.dot(r,p)),g=0;g<3;g++)for(d=e[g],m=f[g],b=0;b<x;b++)d[b]-=2*m[b];for(p=numeric.getBlock(e,[0,0],[x-1,2]),f=numeric.tensor(numeric.dot(p,r),r),g=0;g<x;g++)for(d=e[g],m=f[g],b=0;b<3;b++)d[b]-=2*m[b];for(p=[w[0],w[1],w[2]],f=numeric.tensor(r,numeric.dot(r,p)),g=0;g<3;g++)for(h=w[g],m=f[g],b=0;b<x;b++)h[b]-=2*m[b];for(y=0;y<x-2;y++){for(b=y;b<=y+1;b++)if(Math.abs(e[b+1][b])<k*(Math.abs(e[b][b])+Math.abs(e[b+1][b+1]))){C=numeric.QRFrancis(numeric.getBlock(e,[0,0],[b,b]),t),D=numeric.QRFrancis(numeric.getBlock(e,[b+1,b+1],[x-1,x-1]),t);for(p=Array(b+1),g=0;g<=b;g++)p[g]=w[g];for(f=numeric.dot(C.Q,p),g=0;g<=b;g++)w[g]=f[g];for(p=Array(x-b-1),g=b+1;g<x;g++)p[g-b-1]=w[g];for(f=numeric.dot(D.Q,p),g=b+1;g<x;g++)w[g]=f[g-b-1];return{Q:w,B:C.B.concat(numeric.add(D.B,b+1))}}for(I=Math.min(x-1,y+3),n=Array(I-y),g=y+1;g<=I;g++)n[g-y-1]=e[g][y];for(r=numeric.house(n),p=numeric.getBlock(e,[y+1,y],[I,x-1]),f=numeric.tensor(r,numeric.dot(r,p)),g=y+1;g<=I;g++)for(d=e[g],m=f[g-y-1],b=y;b<x;b++)d[b]-=2*m[b-y];for(p=numeric.getBlock(e,[0,y+1],[x-1,I]),f=numeric.tensor(numeric.dot(p,r),r),g=0;g<x;g++)for(d=e[g],m=f[g],b=y+1;b<=I;b++)d[b]-=2*m[b-y-1];for(p=Array(I-y),g=y+1;g<=I;g++)p[g-y-1]=w[g];for(f=numeric.tensor(r,numeric.dot(r,p)),g=y+1;g<=I;g++)for(h=w[g],m=f[g-y-1],b=0;b<x;b++)h[b]-=2*m[b]}}throw new Error("numeric: eigenvalue iteration does not converge -- increase maxiter?")},numeric.eig=function(e,t){var n,r,a,o,i,s,u,c,l,h,d,p,f,m,g,y,b=numeric.toUpperHessenberg(e),v=numeric.QRFrancis(b.H,t),x=numeric.T,w=e.length,k=v.B,C=numeric.dot(v.Q,numeric.dot(b.H,numeric.transpose(v.Q))),D=new x(numeric.dot(v.Q,b.Q)),S=k.length,E=Math.sqrt;for(r=0;r<S;r++)if((n=k[r][0])===k[r][1]);else{if(o=n+1,i=C[n][n],s=C[n][o],u=C[o][n],c=C[o][o],0===s&&0===u)continue;(h=(l=-i-c)*l-4*(i*c-s*u))>=0?((g=(i-(d=l<0?-.5*(l-E(h)):-.5*(l+E(h))))*(i-d)+s*s)>(y=u*u+(c-d)*(c-d))?(f=(i-d)/(g=E(g)),m=s/g):(f=u/(y=E(y)),m=(c-d)/y),a=new x([[m,-f],[f,m]]),D.setRows(n,o,a.dot(D.getRows(n,o)))):(d=-.5*l,p=.5*E(-h),(g=(i-d)*(i-d)+s*s)>(y=u*u+(c-d)*(c-d))?(f=(i-d)/(g=E(g+p*p)),m=s/g,d=0,p/=g):(f=u/(y=E(y+p*p)),m=(c-d)/y,d=p/y,p=0),a=new x([[m,-f],[f,m]],[[d,p],[p,-d]]),D.setRows(n,o,a.dot(D.getRows(n,o))))}var I=D.dot(e).dot(D.transjugate()),N=(w=e.length,numeric.T.identity(w));for(o=0;o<w;o++)if(o>0)for(r=o-1;r>=0;r--){var T=I.get([r,r]),A=I.get([o,o]);numeric.neq(T.x,A.x)||numeric.neq(T.y,A.y)?(d=I.getRow(r).getBlock([r],[o-1]),p=N.getRow(o).getBlock([r],[o-1]),N.set([o,r],I.get([r,o]).neg().sub(d.dot(p)).div(T.sub(A)))):N.setRow(o,N.getRow(r))}for(o=0;o<w;o++)d=N.getRow(o),N.setRow(o,d.div(d.norm2()));return N=N.transpose(),N=D.transjugate().dot(N),{lambda:I.getDiag(),E:N}},numeric.ccsSparse=function(e){var t,n,r,a=e.length,o=[];for(n=a-1;-1!==n;--n)for(r in t=e[n]){for(r=parseInt(r);r>=o.length;)o[o.length]=0;0!==t[r]&&o[r]++}var i=o.length,s=Array(i+1);for(s[0]=0,n=0;n<i;++n)s[n+1]=s[n]+o[n];var u=Array(s[i]),c=Array(s[i]);for(n=a-1;-1!==n;--n)for(r in t=e[n])0!==t[r]&&(o[r]--,u[s[r]+o[r]]=n,c[s[r]+o[r]]=t[r]);return[s,u,c]},numeric.ccsFull=function(e){var t,n,r,a,o=e[0],i=e[1],s=e[2],u=numeric.ccsDim(e),c=u[0],l=u[1],h=numeric.rep([c,l],0);for(t=0;t<l;t++)for(r=o[t],a=o[t+1],n=r;n<a;++n)h[i[n]][t]=s[n];return h},numeric.ccsTSolve=function(e,t,n,r,a){var o,i,s,u,c,l,h,d=e[0],p=e[1],f=e[2],m=d.length-1,g=Math.max,y=0;function b(e){var t;if(0===n[e]){for(n[e]=1,t=d[e];t<d[e+1];++t)b(p[t]);a[y]=e,++y}}for("undefined"===typeof r&&(n=numeric.rep([m],0)),"undefined"===typeof r&&(r=numeric.linspace(0,n.length-1)),"undefined"===typeof a&&(a=[]),o=r.length-1;-1!==o;--o)b(r[o]);for(a.length=y,o=a.length-1;-1!==o;--o)n[a[o]]=0;for(o=r.length-1;-1!==o;--o)i=r[o],n[i]=t[i];for(o=a.length-1;-1!==o;--o){for(i=a[o],s=d[i],u=g(d[i+1],s),c=s;c!==u;++c)if(p[c]===i){n[i]/=f[c];break}for(h=n[i],c=s;c!==u;++c)(l=p[c])!==i&&(n[l]-=h*f[c])}return n},numeric.ccsDFS=function(e){this.k=Array(e),this.k1=Array(e),this.j=Array(e)},numeric.ccsDFS.prototype.dfs=function(e,t,n,r,a,o){var i,s,u,c=0,l=a.length,h=this.k,d=this.k1,p=this.j;if(0===r[e])for(r[e]=1,p[0]=e,h[0]=s=t[e],d[0]=u=t[e+1];;)if(s>=u){if(a[l]=p[c],0===c)return;++l,s=h[--c],u=d[c]}else 0===r[i=o[n[s]]]?(r[i]=1,h[c]=s,p[++c]=i,s=t[i],d[c]=u=t[i+1]):++s},numeric.ccsLPSolve=function(e,t,n,r,a,o,i){var s,u,c,l,h,d,p,f,m,g=e[0],y=e[1],b=e[2],v=(g.length,t[0]),x=t[1],w=t[2];for(u=v[a],c=v[a+1],r.length=0,s=u;s<c;++s)i.dfs(o[x[s]],g,y,n,r,o);for(s=r.length-1;-1!==s;--s)n[r[s]]=0;for(s=u;s!==c;++s)n[l=o[x[s]]]=w[s];for(s=r.length-1;-1!==s;--s){for(h=g[l=r[s]],d=g[l+1],p=h;p<d;++p)if(o[y[p]]===l){n[l]/=b[p];break}for(m=n[l],p=h;p<d;++p)(f=o[y[p]])!==l&&(n[f]-=m*b[p])}return n},numeric.ccsLUP1=function(e,t){var n,r,a,o,i,s,u,c=e[0].length-1,l=[numeric.rep([c+1],0),[],[]],h=[numeric.rep([c+1],0),[],[]],d=l[0],p=l[1],f=l[2],m=h[0],g=h[1],y=h[2],b=numeric.rep([c],0),v=numeric.rep([c],0),x=numeric.ccsLPSolve,w=(Math.max,Math.abs),k=numeric.linspace(0,c-1),C=numeric.linspace(0,c-1),D=new numeric.ccsDFS(c);for("undefined"===typeof t&&(t=1),n=0;n<c;++n){for(x(l,e,b,v,n,C,D),o=-1,i=-1,r=v.length-1;-1!==r;--r)(a=v[r])<=n||(s=w(b[a]))>o&&(i=a,o=s);for(w(b[n])<t*o&&(r=k[n],o=k[i],k[n]=o,C[o]=n,k[i]=r,C[r]=i,o=b[n],b[n]=b[i],b[i]=o),o=d[n],i=m[n],u=b[n],p[o]=k[n],f[o]=1,++o,r=v.length-1;-1!==r;--r)s=b[a=v[r]],v[r]=0,b[a]=0,a<=n?(g[i]=a,y[i]=s,++i):(p[o]=k[a],f[o]=s/u,++o);d[n+1]=o,m[n+1]=i}for(r=p.length-1;-1!==r;--r)p[r]=C[p[r]];return{L:l,U:h,P:k,Pinv:C}},numeric.ccsDFS0=function(e){this.k=Array(e),this.k1=Array(e),this.j=Array(e)},numeric.ccsDFS0.prototype.dfs=function(e,t,n,r,a,o,i){var s,u,c,l=0,h=a.length,d=this.k,p=this.k1,f=this.j;if(0===r[e])for(r[e]=1,f[0]=e,d[0]=u=t[o[e]],p[0]=c=t[o[e]+1];;){if(isNaN(u))throw new Error("Ow!");if(u>=c){if(a[h]=o[f[l]],0===l)return;++h,u=d[--l],c=p[l]}else 0===r[s=n[u]]?(r[s]=1,d[l]=u,f[++l]=s,u=t[s=o[s]],p[l]=c=t[s+1]):++u}},numeric.ccsLPSolve0=function(e,t,n,r,a,o,i,s){var u,c,l,h,d,p,f,m,g,y=e[0],b=e[1],v=e[2],x=(y.length,t[0]),w=t[1],k=t[2];for(c=x[a],l=x[a+1],r.length=0,u=c;u<l;++u)s.dfs(w[u],y,b,n,r,o,i);for(u=r.length-1;-1!==u;--u)n[i[h=r[u]]]=0;for(u=c;u!==l;++u)n[h=w[u]]=k[u];for(u=r.length-1;-1!==u;--u){for(m=i[h=r[u]],d=y[h],p=y[h+1],f=d;f<p;++f)if(b[f]===m){n[m]/=v[f];break}for(g=n[m],f=d;f<p;++f)n[b[f]]-=g*v[f];n[m]=g}},numeric.ccsLUP0=function(e,t){var n,r,a,o,i,s,u,c=e[0].length-1,l=[numeric.rep([c+1],0),[],[]],h=[numeric.rep([c+1],0),[],[]],d=l[0],p=l[1],f=l[2],m=h[0],g=h[1],y=h[2],b=numeric.rep([c],0),v=numeric.rep([c],0),x=numeric.ccsLPSolve0,w=(Math.max,Math.abs),k=numeric.linspace(0,c-1),C=numeric.linspace(0,c-1),D=new numeric.ccsDFS0(c);for("undefined"===typeof t&&(t=1),n=0;n<c;++n){for(x(l,e,b,v,n,C,k,D),o=-1,i=-1,r=v.length-1;-1!==r;--r)(a=v[r])<=n||(s=w(b[k[a]]))>o&&(i=a,o=s);for(w(b[k[n]])<t*o&&(r=k[n],o=k[i],k[n]=o,C[o]=n,k[i]=r,C[r]=i),o=d[n],i=m[n],u=b[k[n]],p[o]=k[n],f[o]=1,++o,r=v.length-1;-1!==r;--r)s=b[k[a=v[r]]],v[r]=0,b[k[a]]=0,a<=n?(g[i]=a,y[i]=s,++i):(p[o]=k[a],f[o]=s/u,++o);d[n+1]=o,m[n+1]=i}for(r=p.length-1;-1!==r;--r)p[r]=C[p[r]];return{L:l,U:h,P:k,Pinv:C}},numeric.ccsLUP=numeric.ccsLUP0,numeric.ccsDim=function(e){return[numeric.sup(e[1])+1,e[0].length-1]},numeric.ccsGetBlock=function(e,t,n){var r=numeric.ccsDim(e),a=r[0],o=r[1];"undefined"===typeof t?t=numeric.linspace(0,a-1):"number"===typeof t&&(t=[t]),"undefined"===typeof n?n=numeric.linspace(0,o-1):"number"===typeof n&&(n=[n]);var i,s,u,c,l=t.length,h=n.length,d=numeric.rep([o],0),p=[],f=[],m=[d,p,f],g=e[0],y=e[1],b=e[2],v=numeric.rep([a],0),x=0,w=numeric.rep([a],0);for(s=0;s<h;++s){var k=g[c=n[s]],C=g[c+1];for(i=k;i<C;++i)w[u=y[i]]=1,v[u]=b[i];for(i=0;i<l;++i)w[t[i]]&&(p[x]=i,f[x]=v[t[i]],++x);for(i=k;i<C;++i)w[u=y[i]]=0;d[s+1]=x}return m},numeric.ccsDot=function(e,t){var n,r,a,o,i,s,u,c,l,h,d,p=e[0],f=e[1],m=e[2],g=t[0],y=t[1],b=t[2],v=numeric.ccsDim(e),x=numeric.ccsDim(t),w=v[0],k=(v[1],x[1]),C=numeric.rep([w],0),D=numeric.rep([w],0),S=Array(w),E=numeric.rep([k],0),I=[],N=[],T=[E,I,N];for(a=0;a!==k;++a){for(o=g[a],i=g[a+1],l=0,r=o;r<i;++r)for(h=y[r],d=b[r],s=p[h],u=p[h+1],n=s;n<u;++n)0===D[c=f[n]]&&(S[l]=c,D[c]=1,l+=1),C[c]=C[c]+m[n]*d;for(i=(o=E[a])+l,E[a+1]=i,r=l-1;-1!==r;--r)d=o+r,n=S[r],I[d]=n,N[d]=C[n],D[n]=0,C[n]=0;E[a+1]=E[a]+l}return T},numeric.ccsLUPSolve=function(e,t){var n=e.L,r=e.U,a=(e.P,t[0]),o=!1;"object"!==typeof a&&(a=(t=[[0,t.length],numeric.linspace(0,t.length-1),t])[0],o=!0);var i,s,u,c,l,h,d=t[1],p=t[2],f=n[0].length-1,m=a.length-1,g=numeric.rep([f],0),y=Array(f),b=numeric.rep([f],0),v=Array(f),x=numeric.rep([m+1],0),w=[],k=[],C=numeric.ccsTSolve,D=0;for(i=0;i<m;++i){for(l=0,u=a[i],c=a[i+1],s=u;s<c;++s)h=e.Pinv[d[s]],v[l]=h,b[h]=p[s],++l;for(v.length=l,C(n,b,g,v,y),s=v.length-1;-1!==s;--s)b[v[s]]=0;if(C(r,g,b,y,v),o)return b;for(s=y.length-1;-1!==s;--s)g[y[s]]=0;for(s=v.length-1;-1!==s;--s)h=v[s],w[D]=h,k[D]=b[h],b[h]=0,++D;x[i+1]=D}return[x,w,k]},numeric.ccsbinop=function(e,t){return"undefined"===typeof t&&(t=""),Function("X","Y","var Xi = X[0], Xj = X[1], Xv = X[2];\nvar Yi = Y[0], Yj = Y[1], Yv = Y[2];\nvar n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\nvar Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\nvar x = numeric.rep([m],0),y = numeric.rep([m],0);\nvar xk,yk,zk;\nvar i,j,j0,j1,k,p=0;\n"+t+"for(i=0;i<n;++i) {\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Xj[j];\n    x[k] = 1;\n    Zj[p] = k;\n    ++p;\n  }\n  j0 = Yi[i]; j1 = Yi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Yj[j];\n    y[k] = Yv[j];\n    if(x[k] === 0) {\n      Zj[p] = k;\n      ++p;\n    }\n  }\n  Zi[i+1] = p;\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n  j0 = Zi[i]; j1 = Zi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Zj[j];\n    xk = x[k];\n    yk = y[k];\n"+e+"\n    Zv[j] = zk;\n  }\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n  j0 = Yi[i]; j1 = Yi[i+1];\n  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n}\nreturn [Zi,Zj,Zv];")},function(){var k,A,B,C;for(k in numeric.ops2)A=isFinite(eval("1"+numeric.ops2[k]+"0"))?"[Y[0],Y[1],numeric."+k+"(X,Y[2])]":"NaN",B=isFinite(eval("0"+numeric.ops2[k]+"1"))?"[X[0],X[1],numeric."+k+"(X[2],Y)]":"NaN",C=isFinite(eval("1"+numeric.ops2[k]+"0"))&&isFinite(eval("0"+numeric.ops2[k]+"1"))?"numeric.ccs"+k+"MM(X,Y)":"NaN",numeric["ccs"+k+"MM"]=numeric.ccsbinop("zk = xk "+numeric.ops2[k]+"yk;"),numeric["ccs"+k]=Function("X","Y",'if(typeof X === "number") return '+A+';\nif(typeof Y === "number") return '+B+";\nreturn "+C+";\n")}(),numeric.ccsScatter=function(e){var t,n=e[0],r=e[1],a=e[2],o=numeric.sup(r)+1,i=n.length,s=numeric.rep([o],0),u=Array(i),c=Array(i),l=numeric.rep([o],0);for(t=0;t<i;++t)l[r[t]]++;for(t=0;t<o;++t)s[t+1]=s[t]+l[t];var h,d,p=s.slice(0);for(t=0;t<i;++t)u[h=p[d=r[t]]]=n[t],c[h]=a[t],p[d]=p[d]+1;return[s,u,c]},numeric.ccsGather=function(e){var t,n,r,a,o,i=e[0],s=e[1],u=e[2],c=i.length-1,l=s.length,h=Array(l),d=Array(l),p=Array(l);for(o=0,t=0;t<c;++t)for(r=i[t],a=i[t+1],n=r;n!==a;++n)d[o]=t,h[o]=s[n],p[o]=u[n],++o;return[h,d,p]},numeric.sdim=function e(t,n,r){if("undefined"===typeof n&&(n=[]),"object"!==typeof t)return n;var a;for(a in"undefined"===typeof r&&(r=0),r in n||(n[r]=0),t.length>n[r]&&(n[r]=t.length),t)t.hasOwnProperty(a)&&e(t[a],n,r+1);return n},numeric.sclone=function e(t,n,r){"undefined"===typeof n&&(n=0),"undefined"===typeof r&&(r=numeric.sdim(t).length);var a,o=Array(t.length);if(n===r-1){for(a in t)t.hasOwnProperty(a)&&(o[a]=t[a]);return o}for(a in t)t.hasOwnProperty(a)&&(o[a]=e(t[a],n+1,r));return o},numeric.sdiag=function(e){var t,n,r=e.length,a=Array(r);for(t=r-1;t>=1;t-=2)n=t-1,a[t]=[],a[t][t]=e[t],a[n]=[],a[n][n]=e[n];return 0===t&&(a[0]=[],a[0][0]=e[t]),a},numeric.sidentity=function(e){return numeric.sdiag(numeric.rep([e],1))},numeric.stranspose=function(e){var t,n,r,a=[];e.length;for(t in e)if(e.hasOwnProperty(t))for(n in r=e[t])r.hasOwnProperty(n)&&("object"!==typeof a[n]&&(a[n]=[]),a[n][t]=r[n]);return a},numeric.sLUP=function(e,t){throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.")},numeric.sdotMM=function(e,t){var n,r,a,o,i,s,u,c=e.length,l=(t.length,numeric.stranspose(t)),h=l.length,d=Array(c);for(a=c-1;a>=0;a--){for(u=[],n=e[a],i=h-1;i>=0;i--){for(o in s=0,r=l[i],n)n.hasOwnProperty(o)&&o in r&&(s+=n[o]*r[o]);s&&(u[i]=s)}d[a]=u}return d},numeric.sdotMV=function(e,t){var n,r,a,o,i=e.length,s=Array(i);for(r=i-1;r>=0;r--){for(a in o=0,n=e[r])n.hasOwnProperty(a)&&t[a]&&(o+=n[a]*t[a]);o&&(s[r]=o)}return s},numeric.sdotVM=function(e,t){var n,r,a,o,i=[];for(n in e)if(e.hasOwnProperty(n))for(r in a=t[n],o=e[n],a)a.hasOwnProperty(r)&&(i[r]||(i[r]=0),i[r]+=o*a[r]);return i},numeric.sdotVV=function(e,t){var n,r=0;for(n in e)e[n]&&t[n]&&(r+=e[n]*t[n]);return r},numeric.sdot=function(e,t){var n=numeric.sdim(e).length,r=numeric.sdim(t).length;switch(1e3*n+r){case 0:return e*t;case 1001:return numeric.sdotVV(e,t);case 2001:return numeric.sdotMV(e,t);case 1002:return numeric.sdotVM(e,t);case 2002:return numeric.sdotMM(e,t);default:throw new Error("numeric.sdot not implemented for tensors of order "+n+" and "+r)}},numeric.sscatter=function(e){var t,n,r,a,o=e[0].length,i=e.length,s=[];for(n=o-1;n>=0;--n)if(e[i-1][n]){for(a=s,r=0;r<i-2;r++)a[t=e[r][n]]||(a[t]=[]),a=a[t];a[e[r][n]]=e[r+1][n]}return s},numeric.sgather=function e(t,n,r){var a,o,i;for(o in"undefined"===typeof n&&(n=[]),"undefined"===typeof r&&(r=[]),a=r.length,t)if(t.hasOwnProperty(o))if(r[a]=parseInt(o),"number"===typeof(i=t[o])){if(i){if(0===n.length)for(o=a+1;o>=0;--o)n[o]=[];for(o=a;o>=0;--o)n[o].push(r[o]);n[a+1].push(i)}}else e(i,n,r);return r.length>a&&r.pop(),n},numeric.cLU=function(e){var t,n,r,a,o,i,s=e[0],u=e[1],c=e[2],l=s.length,h=0;for(t=0;t<l;t++)s[t]>h&&(h=s[t]);h++;var d,p=Array(h),f=Array(h),m=numeric.rep([h],1/0),g=numeric.rep([h],-1/0);for(r=0;r<l;r++)t=s[r],(n=u[r])<m[t]&&(m[t]=n),n>g[t]&&(g[t]=n);for(t=0;t<h-1;t++)g[t]>g[t+1]&&(g[t+1]=g[t]);for(t=h-1;t>=1;t--)m[t]<m[t-1]&&(m[t-1]=m[t]);for(t=0;t<h;t++)f[t]=numeric.rep([g[t]-m[t]+1],0),p[t]=numeric.rep([t-m[t]],0),t-m[t]+1,g[t]-t+1;for(r=0;r<l;r++)f[t=s[r]][u[r]-m[t]]=c[r];for(t=0;t<h-1;t++)for(a=t-m[t],v=f[t],n=t+1;m[n]<=t&&n<h;n++)if(o=t-m[n],i=g[t]-t,d=(x=f[n])[o]/v[a]){for(r=1;r<=i;r++)x[r+o]-=d*v[r+a];p[n][t-m[n]]=d}var y,b,v=[],x=[],w=[],k=[],C=[],D=[];for(l=0,y=0,t=0;t<h;t++){for(a=m[t],o=g[t],b=f[t],n=t;n<=o;n++)b[n-a]&&(v[l]=t,x[l]=n,w[l]=b[n-a],l++);for(b=p[t],n=a;n<t;n++)b[n-a]&&(k[y]=t,C[y]=n,D[y]=b[n-a],y++);k[y]=t,C[y]=t,D[y]=1,y++}return{U:[v,x,w],L:[k,C,D]}},numeric.cLUsolve=function(e,t){var n,r,a=e.L,o=e.U,i=numeric.clone(t),s=a[0],u=a[1],c=a[2],l=o[0],h=o[1],d=o[2],p=l.length,f=(s.length,i.length);for(r=0,n=0;n<f;n++){for(;u[r]<n;)i[n]-=c[r]*i[u[r]],r++;r++}for(r=p-1,n=f-1;n>=0;n--){for(;h[r]>n;)i[n]-=d[r]*i[h[r]],r--;i[n]/=d[r],r--}return i},numeric.cgrid=function(e,t){"number"===typeof e&&(e=[e,e]);var n,r,a,o=numeric.rep(e,-1);if("function"!==typeof t)if("L"===t)t=function(t,n){return t>=e[0]/2||n<e[1]/2};else t=function(e,t){return!0};for(a=0,n=1;n<e[0]-1;n++)for(r=1;r<e[1]-1;r++)t(n,r)&&(o[n][r]=a,a++);return o},numeric.cdelsq=function(e){var t,n,r,a,o,i=[[-1,0],[0,-1],[0,1],[1,0]],s=numeric.dim(e),u=s[0],c=s[1],l=[],h=[],d=[];for(t=1;t<u-1;t++)for(n=1;n<c-1;n++)if(!(e[t][n]<0)){for(r=0;r<4;r++)a=t+i[r][0],o=n+i[r][1],e[a][o]<0||(l.push(e[t][n]),h.push(e[a][o]),d.push(-1));l.push(e[t][n]),h.push(e[t][n]),d.push(4)}return[l,h,d]},numeric.cdotMV=function(e,t){var n,r,a,o=e[0],i=e[1],s=e[2],u=o.length;for(a=0,r=0;r<u;r++)o[r]>a&&(a=o[r]);for(a++,n=numeric.rep([a],0),r=0;r<u;r++)n[o[r]]+=s[r]*t[i[r]];return n},numeric.Spline=function(e,t,n,r,a){this.x=e,this.yl=t,this.yr=n,this.kl=r,this.kr=a},numeric.Spline.prototype._at=function(e,t){var n,r,a,o=this.x,i=this.yl,s=this.yr,u=this.kl,c=this.kr,l=numeric.add,h=numeric.sub,d=numeric.mul;n=h(d(u[t],o[t+1]-o[t]),h(s[t+1],i[t])),r=l(d(c[t+1],o[t]-o[t+1]),h(s[t+1],i[t]));var p=(a=(e-o[t])/(o[t+1]-o[t]))*(1-a);return l(l(l(d(1-a,i[t]),d(a,s[t+1])),d(n,p*(1-a))),d(r,p*a))},numeric.Spline.prototype.at=function(e){if("number"===typeof e){var t,n,r,a=this.x,o=a.length,i=Math.floor;for(t=0,n=o-1;n-t>1;)a[r=i((t+n)/2)]<=e?t=r:n=r;return this._at(e,t)}o=e.length;var s,u=Array(o);for(s=o-1;-1!==s;--s)u[s]=this.at(e[s]);return u},numeric.Spline.prototype.diff=function(){var e,t,n,r=this.x,a=this.yl,o=this.yr,i=this.kl,s=this.kr,u=a.length,c=i,l=s,h=Array(u),d=Array(u),p=numeric.add,f=numeric.mul,m=numeric.div,g=numeric.sub;for(e=u-1;-1!==e;--e)t=r[e+1]-r[e],n=g(o[e+1],a[e]),h[e]=m(p(f(n,6),f(i[e],-4*t),f(s[e+1],-2*t)),t*t),d[e+1]=m(p(f(n,-6),f(i[e],2*t),f(s[e+1],4*t)),t*t);return new numeric.Spline(r,c,l,h,d)},numeric.Spline.prototype.roots=function(){function e(e){return e*e}var t=[],n=this.x,r=this.yl,a=this.yr,o=this.kl,i=this.kr;"number"===typeof r[0]&&(r=[r],a=[a],o=[o],i=[i]);var s,u,c,l,h,d,p,f,m,g,y,b,v,x,w,k,C,D,S,E,I,N,T,A=r.length,F=n.length-1,_=(t=Array(A),Math.sqrt);for(s=0;s!==A;++s){for(l=r[s],h=a[s],d=o[s],p=i[s],f=[],u=0;u!==F;u++){for(u>0&&h[u]*l[u]<0&&f.push(n[u]),k=n[u+1]-n[u],n[u],y=l[u],b=h[u+1],m=d[u]/k,v=(g=p[u+1]/k)+3*y+2*m-3*b,x=3*(g+m+2*(y-b)),(w=e(m-g+3*(y-b))+12*g*y)<=0?C=(D=v/x)>n[u]&&D<n[u+1]?[n[u],D,n[u+1]]:[n[u],n[u+1]]:(D=(v-_(w))/x,S=(v+_(w))/x,C=[n[u]],D>n[u]&&D<n[u+1]&&C.push(D),S>n[u]&&S<n[u+1]&&C.push(S),C.push(n[u+1])),I=C[0],D=this._at(I,u),c=0;c<C.length-1;c++)if(N=C[c+1],S=this._at(N,u),0!==D)if(0===S||D*S>0)I=N,D=S;else{for(var R=0;!((T=(D*N-S*I)/(D-S))<=I||T>=N);)if((E=this._at(T,u))*S>0)N=T,S=E,-1===R&&(D*=.5),R=-1;else{if(!(E*D>0))break;I=T,D=E,1===R&&(S*=.5),R=1}f.push(T),I=C[c+1],D=this._at(I,u)}else f.push(I),I=N,D=S;0===S&&f.push(N)}t[s]=f}return"number"===typeof this.yl[0]?t[0]:t},numeric.spline=function(e,t,n,r){var a,o=e.length,i=[],s=[],u=[],c=numeric.sub,l=numeric.mul,h=numeric.add;for(a=o-2;a>=0;a--)s[a]=e[a+1]-e[a],u[a]=c(t[a+1],t[a]);"string"!==typeof n&&"string"!==typeof r||(n=r="periodic");var d=[[],[],[]];switch(typeof n){case"undefined":i[0]=l(3/(s[0]*s[0]),u[0]),d[0].push(0,0),d[1].push(0,1),d[2].push(2/s[0],1/s[0]);break;case"string":i[0]=h(l(3/(s[o-2]*s[o-2]),u[o-2]),l(3/(s[0]*s[0]),u[0])),d[0].push(0,0,0),d[1].push(o-2,0,1),d[2].push(1/s[o-2],2/s[o-2]+2/s[0],1/s[0]);break;default:i[0]=n,d[0].push(0),d[1].push(0),d[2].push(1)}for(a=1;a<o-1;a++)i[a]=h(l(3/(s[a-1]*s[a-1]),u[a-1]),l(3/(s[a]*s[a]),u[a])),d[0].push(a,a,a),d[1].push(a-1,a,a+1),d[2].push(1/s[a-1],2/s[a-1]+2/s[a],1/s[a]);switch(typeof r){case"undefined":i[o-1]=l(3/(s[o-2]*s[o-2]),u[o-2]),d[0].push(o-1,o-1),d[1].push(o-2,o-1),d[2].push(1/s[o-2],2/s[o-2]);break;case"string":d[1][d[1].length-1]=0;break;default:i[o-1]=r,d[0].push(o-1),d[1].push(o-1),d[2].push(1)}i="number"!==typeof i[0]?numeric.transpose(i):[i];var p=Array(i.length);if("string"===typeof n)for(a=p.length-1;-1!==a;--a)p[a]=numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(d)),i[a]),p[a][o-1]=p[a][0];else for(a=p.length-1;-1!==a;--a)p[a]=numeric.cLUsolve(numeric.cLU(d),i[a]);return p="number"===typeof t[0]?p[0]:numeric.transpose(p),new numeric.Spline(e,t,t,p,p)},numeric.fftpow2=function e(t,n){var r=t.length;if(1!==r){var a,o,i=Math.cos,s=Math.sin,u=Array(r/2),c=Array(r/2),l=Array(r/2),h=Array(r/2);for(o=r/2,a=r-1;-1!==a;--a)l[--o]=t[a],h[o]=n[a],--a,u[o]=t[a],c[o]=n[a];e(u,c),e(l,h),o=r/2;var d,p,f,m=-6.283185307179586/r;for(a=r-1;-1!==a;--a)-1===--o&&(o=r/2-1),p=i(d=m*a),f=s(d),t[a]=u[o]+p*l[o]-f*h[o],n[a]=c[o]+p*h[o]+f*l[o]}},numeric._ifftpow2=function e(t,n){var r=t.length;if(1!==r){var a,o,i=Math.cos,s=Math.sin,u=Array(r/2),c=Array(r/2),l=Array(r/2),h=Array(r/2);for(o=r/2,a=r-1;-1!==a;--a)l[--o]=t[a],h[o]=n[a],--a,u[o]=t[a],c[o]=n[a];e(u,c),e(l,h),o=r/2;var d,p,f,m=6.283185307179586/r;for(a=r-1;-1!==a;--a)-1===--o&&(o=r/2-1),p=i(d=m*a),f=s(d),t[a]=u[o]+p*l[o]-f*h[o],n[a]=c[o]+p*h[o]+f*l[o]}},numeric.ifftpow2=function(e,t){numeric._ifftpow2(e,t),numeric.diveq(e,e.length),numeric.diveq(t,t.length)},numeric.convpow2=function(e,t,n,r){var a,o,i,s,u;for(numeric.fftpow2(e,t),numeric.fftpow2(n,r),a=e.length-1;-1!==a;--a)o=e[a],s=t[a],i=n[a],u=r[a],e[a]=o*i-s*u,t[a]=o*u+s*i;numeric.ifftpow2(e,t)},numeric.T.prototype.fft=function(){var e,t,n=this.x,r=this.y,a=n.length,o=Math.log,i=o(2),s=Math.ceil(o(2*a-1)/i),u=Math.pow(2,s),c=numeric.rep([u],0),l=numeric.rep([u],0),h=Math.cos,d=Math.sin,p=-3.141592653589793/a,f=numeric.rep([u],0),m=numeric.rep([u],0);Math.floor(a/2);for(e=0;e<a;e++)f[e]=n[e];if("undefined"!==typeof r)for(e=0;e<a;e++)m[e]=r[e];for(c[0]=1,e=1;e<=u/2;e++)t=p*e*e,c[e]=h(t),l[e]=d(t),c[u-e]=h(t),l[u-e]=d(t);var g=new numeric.T(f,m),y=new numeric.T(c,l);return g=g.mul(y),numeric.convpow2(g.x,g.y,numeric.clone(y.x),numeric.neg(y.y)),(g=g.mul(y)).x.length=a,g.y.length=a,g},numeric.T.prototype.ifft=function(){var e,t,n=this.x,r=this.y,a=n.length,o=Math.log,i=o(2),s=Math.ceil(o(2*a-1)/i),u=Math.pow(2,s),c=numeric.rep([u],0),l=numeric.rep([u],0),h=Math.cos,d=Math.sin,p=3.141592653589793/a,f=numeric.rep([u],0),m=numeric.rep([u],0);Math.floor(a/2);for(e=0;e<a;e++)f[e]=n[e];if("undefined"!==typeof r)for(e=0;e<a;e++)m[e]=r[e];for(c[0]=1,e=1;e<=u/2;e++)t=p*e*e,c[e]=h(t),l[e]=d(t),c[u-e]=h(t),l[u-e]=d(t);var g=new numeric.T(f,m),y=new numeric.T(c,l);return g=g.mul(y),numeric.convpow2(g.x,g.y,numeric.clone(y.x),numeric.neg(y.y)),(g=g.mul(y)).x.length=a,g.y.length=a,g.div(a)},numeric.gradient=function(e,t){var n=t.length,r=e(t);if(isNaN(r))throw new Error("gradient: f(x) is a NaN!");var a,o,i,s,u,c,l,h,d,p=Math.max,f=numeric.clone(t),m=Array(n),g=(numeric.div,numeric.sub,p=Math.max,Math.abs),y=Math.min,b=0;for(a=0;a<n;a++)for(var v=p(1e-6*r,1e-8);;){if(++b>20)throw new Error("Numerical gradient fails");if(f[a]=t[a]+v,o=e(f),f[a]=t[a]-v,i=e(f),f[a]=t[a],isNaN(o)||isNaN(i))v/=16;else{if(m[a]=(o-i)/(2*v),s=t[a]-v,u=t[a],c=t[a]+v,l=(o-r)/v,h=(r-i)/v,d=p(g(m[a]),g(r),g(o),g(i),g(s),g(u),g(c),1e-8),!(y(p(g(l-m[a]),g(h-m[a]),g(l-h))/d,v/d)>.001))break;v/=16}}return m},numeric.uncmin=function(e,t,n,r,a,o,i){var s=numeric.gradient;"undefined"===typeof i&&(i={}),"undefined"===typeof n&&(n=1e-8),"undefined"===typeof r&&(r=function(t){return s(e,t)}),"undefined"===typeof a&&(a=1e3);var u,c,l=(t=numeric.clone(t)).length,h=e(t);if(isNaN(h))throw new Error("uncmin: f(x0) is a NaN!");var d=Math.max,p=numeric.norm2;n=d(n,numeric.epsilon);var f,m,g,y,b,v,x,w,k,C,D=i.Hinv||numeric.identity(l),S=numeric.dot,E=(numeric.inv,numeric.sub),I=numeric.add,N=numeric.tensor,T=numeric.div,A=numeric.mul,F=numeric.all,_=numeric.isFinite,R=numeric.neg,M=0,O="";for(m=r(t);M<a;){if("function"===typeof o&&o(M,t,h,m,D)){O="Callback returned true";break}if(!F(_(m))){O="Gradient has Infinity or NaN";break}if(!F(_(f=R(S(D,m))))){O="Search direction has Infinity or NaN";break}if((C=p(f))<n){O="Newton step smaller than tol";break}for(k=1,c=S(m,f),b=t;M<a&&!(k*C<n)&&(b=I(t,y=A(f,k)),(u=e(b))-h>=.1*k*c||isNaN(u));)k*=.5,++M;if(k*C<n){O="Line search step size smaller than tol";break}if(M===a){O="maxit reached during line search";break}w=S(v=E(g=r(b),m),y),x=S(D,v),D=E(I(D,A((w+S(v,x))/(w*w),N(y,y))),T(I(N(x,y),N(y,x)),w)),t=b,h=u,m=g,++M}return{solution:t,f:h,gradient:m,invHessian:D,iterations:M,message:O}},numeric.Dopri=function(e,t,n,r,a,o,i){this.x=e,this.y=t,this.f=n,this.ymid=r,this.iterations=a,this.events=i,this.message=o},numeric.Dopri.prototype._at=function(e,t){function n(e){return e*e}var r,a,o,i,s,u,c,l,h,d=this,p=d.x,f=d.y,m=d.f,g=d.ymid,y=(p.length,Math.floor,numeric.add),b=numeric.mul,v=numeric.sub;return r=p[t],a=p[t+1],i=f[t],s=f[t+1],o=r+.5*(a-r),u=g[t],c=v(m[t],b(i,1/(r-o)+2/(r-a))),l=v(m[t+1],b(s,1/(a-o)+2/(a-r))),y(y(y(y(b(i,(h=[n(e-a)*(e-o)/n(r-a)/(r-o),n(e-r)*n(e-a)/n(r-o)/n(a-o),n(e-r)*(e-o)/n(a-r)/(a-o),(e-r)*n(e-a)*(e-o)/n(r-a)/(r-o),(e-a)*n(e-r)*(e-o)/n(r-a)/(a-o)])[0]),b(u,h[1])),b(s,h[2])),b(c,h[3])),b(l,h[4]))},numeric.Dopri.prototype.at=function(e){var t,n,r,a=Math.floor;if("number"!==typeof e){var o=e.length,i=Array(o);for(t=o-1;-1!==t;--t)i[t]=this.at(e[t]);return i}var s=this.x;for(t=0,n=s.length-1;n-t>1;)s[r=a(.5*(t+n))]<=e?t=r:n=r;return this._at(e,t)},numeric.dopri=function(e,t,n,r,a,o,i){"undefined"===typeof a&&(a=1e-6),"undefined"===typeof o&&(o=1e3);var s,u,c,l,h,d,p,f,m,g,y,b,v,x=[e],w=[n],k=[r(e,n)],C=[],D=[3/40,9/40],S=[44/45,-56/15,32/9],E=[19372/6561,-25360/2187,64448/6561,-212/729],I=[9017/3168,-355/33,46732/5247,49/176,-5103/18656],N=[35/384,0,500/1113,125/192,-2187/6784,11/84],T=[.10013431883002395,0,.3918321794184259,-.02982460176594817,.05893268337240795,-.04497888809104361,5618549.5/235043384],A=[.2,.3,.8,8/9,1,1],F=[-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40],_=0,R=(t-e)/10,M=0,O=numeric.add,z=numeric.mul,L=(Math.max,Math.min),B=Math.abs,P=numeric.norminf,W=Math.pow,U=numeric.any,V=numeric.lt,G=numeric.and,j=(numeric.sub,new numeric.Dopri(x,w,k,C,-1,""));for("function"===typeof i&&(y=i(e,n));e<t&&M<o;)if(++M,e+R>t&&(R=t-e),s=r(e+A[0]*R,O(n,z(.2*R,k[_]))),u=r(e+A[1]*R,O(O(n,z(D[0]*R,k[_])),z(D[1]*R,s))),c=r(e+A[2]*R,O(O(O(n,z(S[0]*R,k[_])),z(S[1]*R,s)),z(S[2]*R,u))),l=r(e+A[3]*R,O(O(O(O(n,z(E[0]*R,k[_])),z(E[1]*R,s)),z(E[2]*R,u)),z(E[3]*R,c))),h=r(e+A[4]*R,O(O(O(O(O(n,z(I[0]*R,k[_])),z(I[1]*R,s)),z(I[2]*R,u)),z(I[3]*R,c)),z(I[4]*R,l))),d=r(e+R,m=O(O(O(O(O(n,z(k[_],R*N[0])),z(u,R*N[2])),z(c,R*N[3])),z(l,R*N[4])),z(h,R*N[5]))),(g="number"===typeof(p=O(O(O(O(O(z(k[_],R*F[0]),z(u,R*F[2])),z(c,R*F[3])),z(l,R*F[4])),z(h,R*F[5])),z(d,R*F[6])))?B(p):P(p))>a){if(e+(R=.2*R*W(a/g,.25))===e){j.msg="Step size became too small";break}}else{if(C[_]=O(O(O(O(O(O(n,z(k[_],R*T[0])),z(u,R*T[2])),z(c,R*T[3])),z(l,R*T[4])),z(h,R*T[5])),z(d,R*T[6])),x[++_]=e+R,w[_]=m,k[_]=d,"function"===typeof i){var H,q,K=e,X=e+.5*R;if(b=i(X,C[_-1]),U(v=G(V(y,0),V(0,b)))||(K=X,y=b,b=i(X=e+R,m),v=G(V(y,0),V(0,b))),U(v)){for(var Y,Q,Z=0,J=1,$=1;;){if("number"===typeof y)q=($*b*K-J*y*X)/($*b-J*y);else for(q=X,f=y.length-1;-1!==f;--f)y[f]<0&&b[f]>0&&(q=L(q,($*b[f]*K-J*y[f]*X)/($*b[f]-J*y[f])));if(q<=K||q>=X)break;Q=i(q,H=j._at(q,_-1)),U(Y=G(V(y,0),V(0,Q)))?(X=q,b=Q,v=Y,$=1,-1===Z?J*=.5:J=1,Z=-1):(K=q,y=Q,J=1,1===Z?$*=.5:$=1,Z=1)}return m=j._at(.5*(e+q),_-1),j.f[_]=r(q,H),j.x[_]=q,j.y[_]=H,j.ymid[_-1]=m,j.events=v,j.iterations=M,j}}e+=R,n=m,y=b,R=L(.8*R*W(a/g,.25),4*R)}return j.iterations=M,j},numeric.LU=function(e,t){t=t||!1;var n,r,a,o,i,s,u,c,l,h=Math.abs,d=e.length,p=d-1,f=new Array(d);for(t||(e=numeric.clone(e)),a=0;a<d;++a){for(u=a,l=h((s=e[a])[a]),r=a+1;r<d;++r)l<(o=h(e[r][a]))&&(l=o,u=r);for(f[a]=u,u!=a&&(e[a]=e[u],e[u]=s,s=e[a]),i=s[a],n=a+1;n<d;++n)e[n][a]/=i;for(n=a+1;n<d;++n){for(c=e[n],r=a+1;r<p;++r)c[r]-=c[a]*s[r],c[++r]-=c[a]*s[r];r===p&&(c[r]-=c[a]*s[r])}}return{LU:e,P:f}},numeric.LUsolve=function(e,t){var n,r,a,o,i,s=e.LU,u=s.length,c=numeric.clone(t),l=e.P;for(n=u-1;-1!==n;--n)c[n]=t[n];for(n=0;n<u;++n)for(a=l[n],l[n]!==n&&(i=c[n],c[n]=c[a],c[a]=i),o=s[n],r=0;r<n;++r)c[n]-=c[r]*o[r];for(n=u-1;n>=0;--n){for(o=s[n],r=n+1;r<u;++r)c[n]-=c[r]*o[r];c[n]/=o[n]}return c},numeric.solve=function(e,t,n){return numeric.LUsolve(numeric.LU(e,n),t)},numeric.echelonize=function(e){var t,n,r,a,o,i,s,u,c=numeric.dim(e),l=c[0],h=c[1],d=numeric.identity(l),p=Array(l),f=Math.abs,m=numeric.diveq;for(e=numeric.clone(e),t=0;t<l;++t){for(r=0,o=e[t],i=d[t],n=1;n<h;++n)f(o[r])<f(o[n])&&(r=n);for(p[t]=r,m(i,o[r]),m(o,o[r]),n=0;n<l;++n)if(n!==t){for(u=(s=e[n])[r],a=h-1;-1!==a;--a)s[a]-=o[a]*u;for(s=d[n],a=l-1;-1!==a;--a)s[a]-=i[a]*u}}return{I:d,A:e,P:p}},numeric.__solveLP=function(e,t,n,r,a,o,i){var s,u,c,l,h=numeric.sum,d=(numeric.log,numeric.mul),p=numeric.sub,f=numeric.dot,m=numeric.div,g=numeric.add,y=e.length,b=n.length,v=!1,x=1,w=(numeric.transpose(t),numeric.svd,numeric.transpose),k=(numeric.leq,Math.sqrt),C=Math.abs,D=(numeric.muleq,numeric.norminf,numeric.any,Math.min),S=numeric.all,E=numeric.gt,I=Array(y),N=Array(b),T=(numeric.rep([b],1),numeric.solve),A=p(n,f(t,o)),F=f(e,e);for(c=0;c<a;++c){var _,R;for(_=b-1;-1!==_;--_)N[_]=m(t[_],A[_]);var M=w(N);for(_=y-1;-1!==_;--_)I[_]=h(M[_]);x=.25*C(F/f(e,I));var O=100*k(F/f(I,I));for((!isFinite(x)||x>O)&&(x=O),l=g(e,d(x,I)),u=f(M,N),_=y-1;-1!==_;--_)u[_][_]+=1;R=T(u,m(l,x),!0);var z=m(A,f(t,R)),L=1;for(_=b-1;-1!==_;--_)z[_]<0&&(L=D(L,-.999*z[_]));if(s=p(o,d(R,L)),!S(E(A=p(n,f(t,s)),0)))return{solution:o,message:"",iterations:c};if(o=s,x<r)return{solution:s,message:"",iterations:c};if(i){var B=f(e,l),P=f(t,l);for(v=!0,_=b-1;-1!==_;--_)if(B*P[_]<0){v=!1;break}}else v=!(o[y-1]>=0);if(v)return{solution:s,message:"Unbounded",iterations:c}}return{solution:o,message:"maximum iteration count exceeded",iterations:c}},numeric._solveLP=function(e,t,n,r,a){var o=e.length,i=n.length,s=(numeric.sum,numeric.log,numeric.mul,numeric.sub),u=numeric.dot,c=(numeric.div,numeric.add,numeric.rep([o],0).concat([1])),l=numeric.rep([i,1],-1),h=numeric.blockMatrix([[t,l]]),d=n,p=numeric.rep([o],0).concat(Math.max(0,numeric.sup(numeric.neg(n)))+1),f=numeric.__solveLP(c,h,d,r,a,p,!1),m=numeric.clone(f.solution);if(m.length=o,numeric.inf(s(n,u(t,m)))<0)return{solution:NaN,message:"Infeasible",iterations:f.iterations};var g=numeric.__solveLP(e,t,n,r,a-f.iterations,m,!0);return g.iterations+=f.iterations,g},numeric.solveLP=function(e,t,n,r,a,o,i){if("undefined"===typeof i&&(i=1e3),"undefined"===typeof o&&(o=numeric.epsilon),"undefined"===typeof r)return numeric._solveLP(e,t,n,o,i);var s,u=r.length,c=r[0].length,l=t.length,h=numeric.echelonize(r),d=numeric.rep([c],0),p=h.P,f=[];for(s=p.length-1;-1!==s;--s)d[p[s]]=1;for(s=c-1;-1!==s;--s)0===d[s]&&f.push(s);var m=numeric.getRange,g=numeric.linspace(0,u-1),y=numeric.linspace(0,l-1),b=m(r,g,f),v=m(t,y,p),x=m(t,y,f),w=numeric.dot,k=numeric.sub,C=w(v,h.I),D=k(x,w(C,b)),S=k(n,w(C,a)),E=Array(p.length),I=Array(f.length);for(s=p.length-1;-1!==s;--s)E[s]=e[p[s]];for(s=f.length-1;-1!==s;--s)I[s]=e[f[s]];var N=k(I,w(E,w(h.I,b))),T=numeric._solveLP(N,D,S,o,i),A=T.solution;if(A!==A)return T;var F=w(h.I,k(a,w(b,A))),_=Array(e.length);for(s=p.length-1;-1!==s;--s)_[p[s]]=F[s];for(s=f.length-1;-1!==s;--s)_[f[s]]=A[s];return{solution:_,message:T.message,iterations:T.iterations}},numeric.MPStoLP=function(e){e instanceof String&&e.split("\n");var t,n,r,a,o=0,i=["Initial state","NAME","ROWS","COLUMNS","RHS","BOUNDS","ENDATA"],s=e.length,u=0,c={},l=[],h=0,d={},p=0,f=[],m=[],g=[];function y(n){throw new Error("MPStoLP: "+n+"\nLine "+t+": "+e[t]+"\nCurrent state: "+i[o]+"\n")}for(t=0;t<s;++t){var b=(r=e[t]).match(/\S*/g),v=[];for(n=0;n<b.length;++n)""!==b[n]&&v.push(b[n]);if(0!==v.length){for(n=0;n<i.length&&r.substr(0,i[n].length)!==i[n];++n);if(n<i.length){if(o=n,1===n&&(a=v[1]),6===n)return{name:a,c:f,A:numeric.transpose(m),b:g,rows:c,vars:d}}else switch(o){case 0:case 1:y("Unexpected line");case 2:switch(v[0]){case"N":0===u?u=v[1]:y("Two or more N rows");break;case"L":c[v[1]]=h,l[h]=1,g[h]=0,++h;break;case"G":c[v[1]]=h,l[h]=-1,g[h]=0,++h;break;case"E":c[v[1]]=h,l[h]=0,g[h]=0,++h;break;default:y("Parse error "+numeric.prettyPrint(v))}break;case 3:d.hasOwnProperty(v[0])||(d[v[0]]=p,f[p]=0,m[p]=numeric.rep([h],0),++p);var x=d[v[0]];for(n=1;n<v.length;n+=2)if(v[n]!==u){var w=c[v[n]];m[x][w]=(l[w]<0?-1:1)*parseFloat(v[n+1])}else f[x]=parseFloat(v[n+1]);break;case 4:for(n=1;n<v.length;n+=2)g[c[v[n]]]=(l[c[v[n]]]<0?-1:1)*parseFloat(v[n+1]);break;case 5:break;case 6:y("Internal error")}}}y("Reached end of file without ENDATA")},numeric.seedrandom={pow:Math.pow,random:Math.random},function(e,t,n,r,a,o,i){function s(e){var t,r,a=this,o=e.length,i=0,s=a.i=a.j=a.m=0;for(a.S=[],a.c=[],o||(e=[o++]);i<n;)a.S[i]=i++;for(i=0;i<n;i++)s=l(s+(t=a.S[i])+e[i%o]),r=a.S[s],a.S[i]=r,a.S[s]=t;a.g=function(e){var t=a.S,r=l(a.i+1),o=t[r],i=l(a.j+o),s=t[i];t[r]=s,t[i]=o;for(var u=t[l(o+s)];--e;)r=l(r+1),s=t[i=l(i+(o=t[r]))],t[r]=s,t[i]=o,u=u*n+t[l(o+s)];return a.i=r,a.j=i,u},a.g(n)}function u(e,t,n,r,a){if(n=[],a=typeof e,t&&"object"==a)for(r in e)if(r.indexOf("S")<5)try{n.push(u(e[r],t-1))}catch(o){}return n.length?n:e+("string"!=a?"\0":"")}function c(e,t,n,r){for(e+="",n=0,r=0;r<e.length;r++)t[l(r)]=l((n^=19*t[l(r)])+e.charCodeAt(r));for(r in e="",t)e+=String.fromCharCode(t[r]);return e}function l(e){return 255&e}t.seedrandom=function(r,l){var h,d=[];return r=c(u(l?[r,e]:arguments.length?r:[(new Date).getTime(),e,window],3),d),c((h=new s(d)).S,e),t.random=function(){for(var e=h.g(6),t=i,r=0;e<a;)e=(e+r)*n,t*=n,r=h.g(1);for(;e>=o;)e/=2,t/=2,r>>>=1;return(e+r)/t},r},i=t.pow(n,6),a=t.pow(2,a),o=2*a,c(t.random(),e)}([],numeric.seedrandom,256,0,52),function(e){function t(e){if("object"!==typeof e)return e;var n,r=[],a=e.length;for(n=0;n<a;n++)r[n+1]=t(e[n]);return r}function n(e){if("object"!==typeof e)return e;var t,r=[],a=e.length;for(t=1;t<a;t++)r[t-1]=n(e[t]);return r}function r(e,t,n,r,a,o,i,s,u,c,l,h,d,p,f,m){var g,y,b,v,x,w,k,C,D,S,E,I,N,T,A,F,_,R,M,O,z,L,B,P,W,U,V;N=Math.min(r,c),b=2*r+N*(N+5)/2+2*c+1,P=1e-60;do{W=1+.1*(P+=P),U=1+.2*P}while(W<=1||U<=1);for(g=1;g<=r;g+=1)f[g]=t[g];for(g=r+1;g<=b;g+=1)f[g]=0;for(g=1;g<=c;g+=1)h[g]=0;if(x=[],0===m[1]){if(function(e,t,n,r){var a,o,i,s,u,c;for(o=1;o<=n;o+=1){if(r[1]=o,c=0,(i=o-1)<1){if((c=e[o][o]-c)<=0)break;e[o][o]=Math.sqrt(c)}else{for(s=1;s<=i;s+=1){for(u=e[s][o],a=1;a<s;a+=1)u-=e[a][o]*e[a][s];u/=e[s][s],e[s][o]=u,c+=u*u}if((c=e[o][o]-c)<=0)break;e[o][o]=Math.sqrt(c)}r[1]=0}}(e,0,r,x),0!==x[1])return void(m[1]=2);!function(e,t,n,r){var a,o,i,s;for(o=1;o<=n;o+=1){for(s=0,a=1;a<o;a+=1)s+=e[a][o]*r[a];r[o]=(r[o]-s)/e[o][o]}for(i=1;i<=n;i+=1)for(r[o=n+1-i]=r[o]/e[o][o],s=-r[o],a=1;a<o;a+=1)r[a]=r[a]+s*e[a][o]}(e,0,r,t),function(e,t,n){var r,a,o,i,s;for(o=1;o<=n;o+=1){for(e[o][o]=1/e[o][o],s=-e[o][o],r=1;r<o;r+=1)e[r][o]=s*e[r][o];if(n<(i=o+1))break;for(a=i;a<=n;a+=1)for(s=e[o][a],e[o][a]=0,r=1;r<=o;r+=1)e[r][a]=e[r][a]+s*e[r][o]}}(e,0,r)}else{for(y=1;y<=r;y+=1)for(a[y]=0,g=1;g<=y;g+=1)a[y]=a[y]+e[g][y]*t[g];for(y=1;y<=r;y+=1)for(t[y]=0,g=y;g<=r;g+=1)t[y]=t[y]+e[y][g]*a[g]}for(o[1]=0,y=1;y<=r;y+=1)for(a[y]=t[y],o[1]=o[1]+f[y]*a[y],f[y]=0,g=y+1;g<=r;g+=1)e[g][y]=0;for(o[1]=-o[1]/2,m[1]=0,T=(S=(D=(E=(C=(k=r)+r)+N)+N+1)+N*(N+1)/2)+c,g=1;g<=c;g+=1){for(F=0,y=1;y<=r;y+=1)F+=i[y][g]*i[y][g];f[T+g]=Math.sqrt(F)}function G(){for(p[1]=p[1]+1,b=S,g=1;g<=c;g+=1){for(b+=1,F=-s[g],y=1;y<=r;y+=1)F+=i[y][g]*a[y];if(Math.abs(F)<P&&(F=0),g>l)f[b]=F;else if(f[b]=-Math.abs(F),F>0){for(y=1;y<=r;y+=1)i[y][g]=-i[y][g];s[g]=-s[g]}}for(g=1;g<=d;g+=1)f[S+h[g]]=0;for(I=0,A=0,g=1;g<=c;g+=1)f[S+g]<A*f[T+g]&&(I=g,A=f[S+g]/f[T+g]);return 0===I?999:0}function j(){for(g=1;g<=r;g+=1){for(F=0,y=1;y<=r;y+=1)F+=e[y][g]*i[y][I];f[g]=F}for(v=k,g=1;g<=r;g+=1)f[v+g]=0;for(y=d+1;y<=r;y+=1)for(g=1;g<=r;g+=1)f[v+g]=f[v+g]+e[g][y]*f[y];for(L=!0,g=d;g>=1;g-=1){for(F=f[g],v=(b=D+g*(g+3)/2)-g,y=g+1;y<=d;y+=1)F-=f[b]*f[C+y],b+=y;if(F/=f[v],f[C+g]=F,h[g]<l)break;if(F<0)break;L=!1,w=g}if(!L)for(_=f[E+w]/f[C+w],g=1;g<=d&&!(h[g]<l)&&!(f[C+g]<0);g+=1)(A=f[E+g]/f[C+g])<_&&(_=A,w=g);for(F=0,g=k+1;g<=k+r;g+=1)F+=f[g]*f[g];if(Math.abs(F)<=P){if(L)return m[1]=1,999;for(g=1;g<=d;g+=1)f[E+g]=f[E+g]-_*f[C+g];return f[E+d+1]=f[E+d+1]+_,700}for(F=0,g=1;g<=r;g+=1)F+=f[k+g]*i[g][I];for(R=-f[S+I]/F,B=!0,L||_<R&&(R=_,B=!1),g=1;g<=r;g+=1)a[g]=a[g]+R*f[k+g],Math.abs(a[g])<P&&(a[g]=0);for(o[1]=o[1]+R*F*(R/2+f[E+d+1]),g=1;g<=d;g+=1)f[E+g]=f[E+g]-R*f[C+g];if(f[E+d+1]=f[E+d+1]+R,!B){for(F=-s[I],y=1;y<=r;y+=1)F+=a[y]*i[y][I];if(I>l)f[S+I]=F;else if(f[S+I]=-Math.abs(F),F>0){for(y=1;y<=r;y+=1)i[y][I]=-i[y][I];s[I]=-s[I]}return 700}for(h[d+=1]=I,b=D+(d-1)*d/2+1,g=1;g<=d-1;g+=1)f[b]=f[g],b+=1;if(d===r)f[b]=f[r];else{for(g=r;g>=d+1&&0!==f[g]&&(M=Math.max(Math.abs(f[g-1]),Math.abs(f[g])),O=Math.min(Math.abs(f[g-1]),Math.abs(f[g])),A=f[g-1]>=0?Math.abs(M*Math.sqrt(1+O*O/(M*M))):-Math.abs(M*Math.sqrt(1+O*O/(M*M))),M=f[g-1]/A,O=f[g]/A,1!==M);g-=1)if(0===M)for(f[g-1]=O*A,y=1;y<=r;y+=1)A=e[y][g-1],e[y][g-1]=e[y][g],e[y][g]=A;else for(f[g-1]=A,z=O/(1+M),y=1;y<=r;y+=1)A=M*e[y][g-1]+O*e[y][g],e[y][g]=z*(e[y][g-1]+A)-e[y][g],e[y][g-1]=A;f[b]=f[d]}return 0}function H(){if(0===f[v=(b=D+w*(w+1)/2+1)+w])return 798;if(M=Math.max(Math.abs(f[v-1]),Math.abs(f[v])),O=Math.min(Math.abs(f[v-1]),Math.abs(f[v])),A=f[v-1]>=0?Math.abs(M*Math.sqrt(1+O*O/(M*M))):-Math.abs(M*Math.sqrt(1+O*O/(M*M))),M=f[v-1]/A,O=f[v]/A,1===M)return 798;if(0===M){for(g=w+1;g<=d;g+=1)A=f[v-1],f[v-1]=f[v],f[v]=A,v+=g;for(g=1;g<=r;g+=1)A=e[g][w],e[g][w]=e[g][w+1],e[g][w+1]=A}else{for(z=O/(1+M),g=w+1;g<=d;g+=1)A=M*f[v-1]+O*f[v],f[v]=z*(f[v-1]+A)-f[v],f[v-1]=A,v+=g;for(g=1;g<=r;g+=1)A=M*e[g][w]+O*e[g][w+1],e[g][w+1]=z*(e[g][w]+A)-e[g][w+1],e[g][w]=A}return 0}function q(){for(v=b-w,g=1;g<=w;g+=1)f[v]=f[b],b+=1,v+=1;return f[E+w]=f[E+w+1],h[w]=h[w+1],(w+=1)<d?797:0}function K(){return f[E+d]=f[E+d+1],f[E+d+1]=0,h[d]=0,d-=1,p[2]=p[2]+1,0}for(d=0,p[1]=0,p[2]=0,V=0;;){if(999===(V=G()))return;for(;0!==(V=j());){if(999===V)return;if(700===V)if(w===d)K();else{for(;H(),797===(V=q()););K()}}}}e.solveQP=function(e,a,o,i,s,u){e=t(e),a=t(a),o=t(o);var c,l,h,d,p,f=[],m=[],g=[],y=[],b=[];if(s=s||0,u=u?t(u):[void 0,0],i=i?t(i):[],l=e.length-1,h=o[1].length-1,!i)for(c=1;c<=h;c+=1)i[c]=0;for(c=1;c<=h;c+=1)m[c]=0;for(d=Math.min(l,h),c=1;c<=l;c+=1)g[c]=0;for(f[1]=0,c=1;c<=2*l+d*(d+5)/2+2*h+1;c+=1)y[c]=0;for(c=1;c<=2;c+=1)b[c]=0;return r(e,a,0,l,g,f,o,i,0,h,s,m,0,b,y,u),p="",1===u[1]&&(p="constraints are inconsistent, no solution!"),2===u[1]&&(p="matrix D in quadratic function is not positive definite!"),{solution:n(g),value:n(f),unconstrained_solution:n(a),iterations:n(b),iact:n(m),message:p}}}(numeric),numeric.svd=function(e){var t,n=numeric.epsilon,r=1e-64/n,a=0,o=0,i=0,s=0,u=0,c=numeric.clone(e),l=c.length,h=c[0].length;if(l<h)throw"Need more rows than columns";var d=new Array(h),p=new Array(h);for(o=0;o<h;o++)d[o]=p[o]=0;var f=numeric.rep([h,h],0);function m(e,t){return(e=Math.abs(e))>(t=Math.abs(t))?e*Math.sqrt(1+t*t/e/e):0==t?e:t*Math.sqrt(1+e*e/t/t)}var g=0,y=0,b=0,v=0,x=0,w=0,k=0;for(o=0;o<h;o++){for(d[o]=y,k=0,u=o+1,i=o;i<l;i++)k+=c[i][o]*c[i][o];if(k<=r)y=0;else for(g=c[o][o],y=Math.sqrt(k),g>=0&&(y=-y),b=g*y-k,c[o][o]=g-y,i=u;i<h;i++){for(k=0,s=o;s<l;s++)k+=c[s][o]*c[s][i];for(g=k/b,s=o;s<l;s++)c[s][i]+=g*c[s][o]}for(p[o]=y,k=0,i=u;i<h;i++)k+=c[o][i]*c[o][i];if(k<=r)y=0;else{for(g=c[o][o+1],y=Math.sqrt(k),g>=0&&(y=-y),b=g*y-k,c[o][o+1]=g-y,i=u;i<h;i++)d[i]=c[o][i]/b;for(i=u;i<l;i++){for(k=0,s=u;s<h;s++)k+=c[i][s]*c[o][s];for(s=u;s<h;s++)c[i][s]+=k*d[s]}}(x=Math.abs(p[o])+Math.abs(d[o]))>v&&(v=x)}for(o=h-1;-1!=o;o+=-1){if(0!=y){for(b=y*c[o][o+1],i=u;i<h;i++)f[i][o]=c[o][i]/b;for(i=u;i<h;i++){for(k=0,s=u;s<h;s++)k+=c[o][s]*f[s][i];for(s=u;s<h;s++)f[s][i]+=k*f[s][o]}}for(i=u;i<h;i++)f[o][i]=0,f[i][o]=0;f[o][o]=1,y=d[o],u=o}for(o=h-1;-1!=o;o+=-1){for(u=o+1,y=p[o],i=u;i<h;i++)c[o][i]=0;if(0!=y){for(b=c[o][o]*y,i=u;i<h;i++){for(k=0,s=u;s<l;s++)k+=c[s][o]*c[s][i];for(g=k/b,s=o;s<l;s++)c[s][i]+=g*c[s][o]}for(i=o;i<l;i++)c[i][o]=c[i][o]/y}else for(i=o;i<l;i++)c[i][o]=0;c[o][o]+=1}for(n*=v,s=h-1;-1!=s;s+=-1)for(var C=0;C<50;C++){var D=!1;for(u=s;-1!=u;u+=-1){if(Math.abs(d[u])<=n){D=!0;break}if(Math.abs(p[u-1])<=n)break}if(!D){a=0,k=1;var S=u-1;for(o=u;o<s+1&&(g=k*d[o],d[o]=a*d[o],!(Math.abs(g)<=n));o++)for(b=m(g,y=p[o]),p[o]=b,a=y/b,k=-g/b,i=0;i<l;i++)x=c[i][S],w=c[i][o],c[i][S]=x*a+w*k,c[i][o]=-x*k+w*a}if(w=p[s],u==s){if(w<0)for(p[s]=-w,i=0;i<h;i++)f[i][s]=-f[i][s];break}if(C>=49)throw"Error: no convergence.";for(v=p[u],y=m(g=(((x=p[s-1])-w)*(x+w)+((y=d[s-1])-(b=d[s]))*(y+b))/(2*b*x),1),g=g<0?((v-w)*(v+w)+b*(x/(g-y)-b))/v:((v-w)*(v+w)+b*(x/(g+y)-b))/v,a=1,k=1,o=u+1;o<s+1;o++){for(y=d[o],x=p[o],b=k*y,y*=a,w=m(g,b),d[o-1]=w,g=v*(a=g/w)+y*(k=b/w),y=-v*k+y*a,b=x*k,x*=a,i=0;i<h;i++)v=f[i][o-1],w=f[i][o],f[i][o-1]=v*a+w*k,f[i][o]=-v*k+w*a;for(w=m(g,b),p[o-1]=w,g=(a=g/w)*y+(k=b/w)*x,v=-k*y+a*x,i=0;i<l;i++)x=c[i][o-1],w=c[i][o],c[i][o-1]=x*a+w*k,c[i][o]=-x*k+w*a}d[u]=0,d[s]=g,p[s]=v}for(o=0;o<p.length;o++)p[o]<n&&(p[o]=0);for(o=0;o<h;o++)for(i=o-1;i>=0;i--)if(p[i]<p[o]){for(a=p[i],p[i]=p[o],p[o]=a,s=0;s<c.length;s++)t=c[s][o],c[s][o]=c[s][i],c[s][i]=t;for(s=0;s<f.length;s++)t=f[s][o],f[s][o]=f[s][i],f[s][i]=t;o=i}return{U:c,S:p,V:f}}},4:(e,t,n)=>{"use strict";var r=n(853),a=n(43),o=n(950);function i(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function s(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}var u=Symbol.for("react.element"),c=Symbol.for("react.transitional.element"),l=Symbol.for("react.portal"),h=Symbol.for("react.fragment"),d=Symbol.for("react.strict_mode"),p=Symbol.for("react.profiler"),f=Symbol.for("react.provider"),m=Symbol.for("react.consumer"),g=Symbol.for("react.context"),y=Symbol.for("react.forward_ref"),b=Symbol.for("react.suspense"),v=Symbol.for("react.suspense_list"),x=Symbol.for("react.memo"),w=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var k=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.tracing_marker");var C=Symbol.for("react.memo_cache_sentinel"),D=Symbol.iterator;function S(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=D&&e[D]||e["@@iterator"])?e:null}var E=Symbol.for("react.client.reference");function I(e){if(null==e)return null;if("function"===typeof e)return e.$$typeof===E?null:e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case h:return"Fragment";case l:return"Portal";case p:return"Profiler";case d:return"StrictMode";case b:return"Suspense";case v:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case g:return(e.displayName||"Context")+".Provider";case m:return(e._context.displayName||"Context")+".Consumer";case y:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case x:return null!==(t=e.displayName||null)?t:I(e.type)||"Memo";case w:t=e._payload,e=e._init;try{return I(e(t))}catch(n){}}return null}var N,T,A=a.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,F=Object.assign;function _(e){if(void 0===N)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);N=t&&t[1]||"",T=-1<n.stack.indexOf("\n    at")?" (<anonymous>)":-1<n.stack.indexOf("@")?"@unknown:0:0":""}return"\n"+N+e+T}var R=!1;function M(e,t){if(!e||R)return"";R=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var r={DetermineComponentFrameRoot:function(){try{if(t){var n=function(){throw Error()};if(Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(n,[])}catch(a){var r=a}Reflect.construct(e,[],n)}else{try{n.call()}catch(o){r=o}e.call(n.prototype)}}else{try{throw Error()}catch(i){r=i}(n=e())&&"function"===typeof n.catch&&n.catch((function(){}))}}catch(s){if(s&&r&&"string"===typeof s.stack)return[s.stack,r.stack]}return[null,null]}};r.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var a=Object.getOwnPropertyDescriptor(r.DetermineComponentFrameRoot,"name");a&&a.configurable&&Object.defineProperty(r.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var o=r.DetermineComponentFrameRoot(),i=o[0],s=o[1];if(i&&s){var u=i.split("\n"),c=s.split("\n");for(a=r=0;r<u.length&&!u[r].includes("DetermineComponentFrameRoot");)r++;for(;a<c.length&&!c[a].includes("DetermineComponentFrameRoot");)a++;if(r===u.length||a===c.length)for(r=u.length-1,a=c.length-1;1<=r&&0<=a&&u[r]!==c[a];)a--;for(;1<=r&&0<=a;r--,a--)if(u[r]!==c[a]){if(1!==r||1!==a)do{if(r--,0>--a||u[r]!==c[a]){var l="\n"+u[r].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=r&&0<=a);break}}}finally{R=!1,Error.prepareStackTrace=n}return(n=e?e.displayName||e.name:"")?_(n):""}function O(e){switch(e.tag){case 26:case 27:case 5:return _(e.type);case 16:return _("Lazy");case 13:return _("Suspense");case 19:return _("SuspenseList");case 0:case 15:return e=M(e.type,!1);case 11:return e=M(e.type.render,!1);case 1:return e=M(e.type,!0);default:return""}}function z(e){try{var t="";do{t+=O(e),e=e.return}while(e);return t}catch(n){return"\nError generating stack: "+n.message+"\n"+n.stack}}function L(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function B(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function P(e){if(L(e)!==e)throw Error(i(188))}function W(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e;for(e=e.child;null!==e;){if(null!==(t=W(e)))return t;e=e.sibling}return null}var U=Array.isArray,V=o.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,G={pending:!1,data:null,method:null,action:null},j=[],H=-1;function q(e){return{current:e}}function K(e){0>H||(e.current=j[H],j[H]=null,H--)}function X(e,t){H++,j[H]=e.current,e.current=t}var Y=q(null),Q=q(null),Z=q(null),J=q(null);function $(e,t){switch(X(Z,t),X(Q,e),X(Y,null),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)&&(t=t.namespaceURI)?Ql(t):0;break;default:if(t=(e=8===e?t.parentNode:t).tagName,e=e.namespaceURI)t=Zl(e=Ql(e),t);else switch(t){case"svg":t=1;break;case"math":t=2;break;default:t=0}}K(Y),X(Y,t)}function ee(){K(Y),K(Q),K(Z)}function te(e){null!==e.memoizedState&&X(J,e);var t=Y.current,n=Zl(t,e.type);t!==n&&(X(Q,e),X(Y,n))}function ne(e){Q.current===e&&(K(Y),K(Q)),J.current===e&&(K(J),zh._currentValue=G)}var re=Object.prototype.hasOwnProperty,ae=r.unstable_scheduleCallback,oe=r.unstable_cancelCallback,ie=r.unstable_shouldYield,se=r.unstable_requestPaint,ue=r.unstable_now,ce=r.unstable_getCurrentPriorityLevel,le=r.unstable_ImmediatePriority,he=r.unstable_UserBlockingPriority,de=r.unstable_NormalPriority,pe=r.unstable_LowPriority,fe=r.unstable_IdlePriority,me=r.log,ge=r.unstable_setDisableYieldValue,ye=null,be=null;function ve(e){if("function"===typeof me&&ge(e),be&&"function"===typeof be.setStrictMode)try{be.setStrictMode(ye,e)}catch(t){}}var xe=Math.clz32?Math.clz32:function(e){return 0===(e>>>=0)?32:31-(we(e)/ke|0)|0},we=Math.log,ke=Math.LN2;var Ce=128,De=4194304;function Se(e){var t=42&e;if(0!==t)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194176&e;case 4194304:case 8388608:case 16777216:case 33554432:return 62914560&e;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function Ee(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,a=e.suspendedLanes,o=e.pingedLanes,i=e.warmLanes;e=0!==e.finishedLanes;var s=134217727&n;return 0!==s?0!==(n=s&~a)?r=Se(n):0!==(o&=s)?r=Se(o):e||0!==(i=s&~i)&&(r=Se(i)):0!==(s=n&~a)?r=Se(s):0!==o?r=Se(o):e||0!==(i=n&~i)&&(r=Se(i)),0===r?0:0!==t&&t!==r&&0===(t&a)&&((a=r&-r)>=(i=t&-t)||32===a&&0!==(4194176&i))?t:r}function Ie(e,t){return 0===(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)}function Ne(e,t){switch(e){case 1:case 2:case 4:case 8:return t+250;case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function Te(){var e=Ce;return 0===(4194176&(Ce<<=1))&&(Ce=128),e}function Ae(){var e=De;return 0===(62914560&(De<<=1))&&(De=4194304),e}function Fe(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function _e(e,t){e.pendingLanes|=t,268435456!==t&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function Re(e,t,n){e.pendingLanes|=t,e.suspendedLanes&=~t;var r=31-xe(t);e.entangledLanes|=t,e.entanglements[r]=1073741824|e.entanglements[r]|4194218&n}function Me(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-xe(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}function Oe(e){return 2<(e&=-e)?8<e?0!==(134217727&e)?32:268435456:8:2}function ze(){var e=V.p;return 0!==e?e:void 0===(e=window.event)?32:Zh(e.type)}var Le=Math.random().toString(36).slice(2),Be="__reactFiber$"+Le,Pe="__reactProps$"+Le,We="__reactContainer$"+Le,Ue="__reactEvents$"+Le,Ve="__reactListeners$"+Le,Ge="__reactHandles$"+Le,je="__reactResources$"+Le,He="__reactMarker$"+Le;function qe(e){delete e[Be],delete e[Pe],delete e[Ue],delete e[Ve],delete e[Ge]}function Ke(e){var t=e[Be];if(t)return t;for(var n=e.parentNode;n;){if(t=n[We]||n[Be]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=uh(e);null!==e;){if(n=e[Be])return n;e=uh(e)}return t}n=(e=n).parentNode}return null}function Xe(e){if(e=e[Be]||e[We]){var t=e.tag;if(5===t||6===t||13===t||26===t||27===t||3===t)return e}return null}function Ye(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e.stateNode;throw Error(i(33))}function Qe(e){var t=e[je];return t||(t=e[je]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function Ze(e){e[He]=!0}var Je=new Set,$e={};function et(e,t){tt(e,t),tt(e+"Capture",t)}function tt(e,t){for($e[e]=t,e=0;e<t.length;e++)Je.add(t[e])}var nt=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),rt=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),at={},ot={};function it(e,t,n){if(a=t,re.call(ot,a)||!re.call(at,a)&&(rt.test(a)?ot[a]=!0:(at[a]=!0,0)))if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":return void e.removeAttribute(t);case"boolean":var r=t.toLowerCase().slice(0,5);if("data-"!==r&&"aria-"!==r)return void e.removeAttribute(t)}e.setAttribute(t,""+n)}var a}function st(e,t,n){if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(t)}e.setAttribute(t,""+n)}}function ut(e,t,n,r){if(null===r)e.removeAttribute(n);else{switch(typeof r){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(n)}e.setAttributeNS(t,n,""+r)}}function ct(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function lt(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function ht(e){e._valueTracker||(e._valueTracker=function(e){var t=lt(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,o=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(e){r=""+e,o.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function dt(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=lt(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function pt(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}var ft=/[\n"\\]/g;function mt(e){return e.replace(ft,(function(e){return"\\"+e.charCodeAt(0).toString(16)+" "}))}function gt(e,t,n,r,a,o,i,s){e.name="",null!=i&&"function"!==typeof i&&"symbol"!==typeof i&&"boolean"!==typeof i?e.type=i:e.removeAttribute("type"),null!=t?"number"===i?(0===t&&""===e.value||e.value!=t)&&(e.value=""+ct(t)):e.value!==""+ct(t)&&(e.value=""+ct(t)):"submit"!==i&&"reset"!==i||e.removeAttribute("value"),null!=t?bt(e,i,ct(t)):null!=n?bt(e,i,ct(n)):null!=r&&e.removeAttribute("value"),null==a&&null!=o&&(e.defaultChecked=!!o),null!=a&&(e.checked=a&&"function"!==typeof a&&"symbol"!==typeof a),null!=s&&"function"!==typeof s&&"symbol"!==typeof s&&"boolean"!==typeof s?e.name=""+ct(s):e.removeAttribute("name")}function yt(e,t,n,r,a,o,i,s){if(null!=o&&"function"!==typeof o&&"symbol"!==typeof o&&"boolean"!==typeof o&&(e.type=o),null!=t||null!=n){if(!("submit"!==o&&"reset"!==o||void 0!==t&&null!==t))return;n=null!=n?""+ct(n):"",t=null!=t?""+ct(t):n,s||t===e.value||(e.value=t),e.defaultValue=t}r="function"!==typeof(r=null!=r?r:a)&&"symbol"!==typeof r&&!!r,e.checked=s?e.checked:!!r,e.defaultChecked=!!r,null!=i&&"function"!==typeof i&&"symbol"!==typeof i&&"boolean"!==typeof i&&(e.name=i)}function bt(e,t,n){"number"===t&&pt(e.ownerDocument)===e||e.defaultValue===""+n||(e.defaultValue=""+n)}function vt(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+ct(n),t=null,a=0;a<e.length;a++){if(e[a].value===n)return e[a].selected=!0,void(r&&(e[a].defaultSelected=!0));null!==t||e[a].disabled||(t=e[a])}null!==t&&(t.selected=!0)}}function xt(e,t,n){null==t||((t=""+ct(t))!==e.value&&(e.value=t),null!=n)?e.defaultValue=null!=n?""+ct(n):"":e.defaultValue!==t&&(e.defaultValue=t)}function wt(e,t,n,r){if(null==t){if(null!=r){if(null!=n)throw Error(i(92));if(U(r)){if(1<r.length)throw Error(i(93));r=r[0]}n=r}null==n&&(n=""),t=n}n=ct(t),e.defaultValue=n,(r=e.textContent)===n&&""!==r&&null!==r&&(e.value=r)}function kt(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var Ct=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Dt(e,t,n){var r=0===t.indexOf("--");null==n||"boolean"===typeof n||""===n?r?e.setProperty(t,""):"float"===t?e.cssFloat="":e[t]="":r?e.setProperty(t,n):"number"!==typeof n||0===n||Ct.has(t)?"float"===t?e.cssFloat=n:e[t]=(""+n).trim():e[t]=n+"px"}function St(e,t,n){if(null!=t&&"object"!==typeof t)throw Error(i(62));if(e=e.style,null!=n){for(var r in n)!n.hasOwnProperty(r)||null!=t&&t.hasOwnProperty(r)||(0===r.indexOf("--")?e.setProperty(r,""):"float"===r?e.cssFloat="":e[r]="");for(var a in t)r=t[a],t.hasOwnProperty(a)&&n[a]!==r&&Dt(e,a,r)}else for(var o in t)t.hasOwnProperty(o)&&Dt(e,o,t[o])}function Et(e){if(-1===e.indexOf("-"))return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var It=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Nt=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Tt(e){return Nt.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}var At=null;function Ft(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var _t=null,Rt=null;function Mt(e){var t=Xe(e);if(t&&(e=t.stateNode)){var n=e[Pe]||null;e:switch(e=t.stateNode,t.type){case"input":if(gt(e,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll('input[name="'+mt(""+t)+'"][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=r[Pe]||null;if(!a)throw Error(i(90));gt(r,a.value,a.defaultValue,a.defaultValue,a.checked,a.defaultChecked,a.type,a.name)}}for(t=0;t<n.length;t++)(r=n[t]).form===e.form&&dt(r)}break e;case"textarea":xt(e,n.value,n.defaultValue);break e;case"select":null!=(t=n.value)&&vt(e,!!n.multiple,t,!1)}}}var Ot=!1;function zt(e,t,n){if(Ot)return e(t,n);Ot=!0;try{return e(t)}finally{if(Ot=!1,(null!==_t||null!==Rt)&&(Bc(),_t&&(t=_t,e=Rt,Rt=_t=null,Mt(t),e)))for(t=0;t<e.length;t++)Mt(e[t])}}function Lt(e,t){var n=e.stateNode;if(null===n)return null;var r=n[Pe]||null;if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(i(231,t,typeof n));return n}var Bt=!1;if(nt)try{var Pt={};Object.defineProperty(Pt,"passive",{get:function(){Bt=!0}}),window.addEventListener("test",Pt,Pt),window.removeEventListener("test",Pt,Pt)}catch(wd){Bt=!1}var Wt=null,Ut=null,Vt=null;function Gt(){if(Vt)return Vt;var e,t,n=Ut,r=n.length,a="value"in Wt?Wt.value:Wt.textContent,o=a.length;for(e=0;e<r&&n[e]===a[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===a[o-t];t++);return Vt=a.slice(e,1<t?1-t:void 0)}function jt(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function Ht(){return!0}function qt(){return!1}function Kt(e){function t(t,n,r,a,o){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=o,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(a):a[i]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?Ht:qt,this.isPropagationStopped=qt,this}return F(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=Ht)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=Ht)},persist:function(){},isPersistent:Ht}),t}var Xt,Yt,Qt,Zt={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Jt=Kt(Zt),$t=F({},Zt,{view:0,detail:0}),en=Kt($t),tn=F({},$t,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:pn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Qt&&(Qt&&"mousemove"===e.type?(Xt=e.screenX-Qt.screenX,Yt=e.screenY-Qt.screenY):Yt=Xt=0,Qt=e),Xt)},movementY:function(e){return"movementY"in e?e.movementY:Yt}}),nn=Kt(tn),rn=Kt(F({},tn,{dataTransfer:0})),an=Kt(F({},$t,{relatedTarget:0})),on=Kt(F({},Zt,{animationName:0,elapsedTime:0,pseudoElement:0})),sn=Kt(F({},Zt,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}})),un=Kt(F({},Zt,{data:0})),cn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},ln={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},hn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function dn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=hn[e])&&!!t[e]}function pn(){return dn}var fn=Kt(F({},$t,{key:function(e){if(e.key){var t=cn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=jt(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?ln[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:pn,charCode:function(e){return"keypress"===e.type?jt(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?jt(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}})),mn=Kt(F({},tn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),gn=Kt(F({},$t,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:pn})),yn=Kt(F({},Zt,{propertyName:0,elapsedTime:0,pseudoElement:0})),bn=Kt(F({},tn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0})),vn=Kt(F({},Zt,{newState:0,oldState:0})),xn=[9,13,27,32],wn=nt&&"CompositionEvent"in window,kn=null;nt&&"documentMode"in document&&(kn=document.documentMode);var Cn=nt&&"TextEvent"in window&&!kn,Dn=nt&&(!wn||kn&&8<kn&&11>=kn),Sn=String.fromCharCode(32),En=!1;function In(e,t){switch(e){case"keyup":return-1!==xn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Nn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Tn=!1;var An={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Fn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!An[e.type]:"textarea"===t}function _n(e,t,n,r){_t?Rt?Rt.push(r):Rt=[r]:_t=r,0<(t=zl(t,"onChange")).length&&(n=new Jt("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Rn=null,Mn=null;function On(e){Nl(e,0)}function zn(e){if(dt(Ye(e)))return e}function Ln(e,t){if("change"===e)return t}var Bn=!1;if(nt){var Pn;if(nt){var Wn="oninput"in document;if(!Wn){var Un=document.createElement("div");Un.setAttribute("oninput","return;"),Wn="function"===typeof Un.oninput}Pn=Wn}else Pn=!1;Bn=Pn&&(!document.documentMode||9<document.documentMode)}function Vn(){Rn&&(Rn.detachEvent("onpropertychange",Gn),Mn=Rn=null)}function Gn(e){if("value"===e.propertyName&&zn(Mn)){var t=[];_n(t,Mn,e,Ft(e)),zt(On,t)}}function jn(e,t,n){"focusin"===e?(Vn(),Mn=n,(Rn=t).attachEvent("onpropertychange",Gn)):"focusout"===e&&Vn()}function Hn(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return zn(Mn)}function qn(e,t){if("click"===e)return zn(t)}function Kn(e,t){if("input"===e||"change"===e)return zn(t)}var Xn="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function Yn(e,t){if(Xn(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!re.call(t,a)||!Xn(e[a],t[a]))return!1}return!0}function Qn(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Zn(e,t){var n,r=Qn(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=Qn(r)}}function Jn(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?Jn(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function $n(e){for(var t=pt((e=null!=e&&null!=e.ownerDocument&&null!=e.ownerDocument.defaultView?e.ownerDocument.defaultView:window).document);t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=pt((e=t.contentWindow).document)}return t}function er(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function tr(e,t){var n=$n(t);t=e.focusedElem;var r=e.selectionRange;if(n!==t&&t&&t.ownerDocument&&Jn(t.ownerDocument.documentElement,t)){if(null!==r&&er(t))if(e=r.start,void 0===(n=r.end)&&(n=e),"selectionStart"in t)t.selectionStart=e,t.selectionEnd=Math.min(n,t.value.length);else if((n=(e=t.ownerDocument||document)&&e.defaultView||window).getSelection){n=n.getSelection();var a=t.textContent.length,o=Math.min(r.start,a);r=void 0===r.end?o:Math.min(r.end,a),!n.extend&&o>r&&(a=r,r=o,o=a),a=Zn(t,o);var i=Zn(t,r);a&&i&&(1!==n.rangeCount||n.anchorNode!==a.node||n.anchorOffset!==a.offset||n.focusNode!==i.node||n.focusOffset!==i.offset)&&((e=e.createRange()).setStart(a.node,a.offset),n.removeAllRanges(),o>r?(n.addRange(e),n.extend(i.node,i.offset)):(e.setEnd(i.node,i.offset),n.addRange(e)))}for(e=[],n=t;n=n.parentNode;)1===n.nodeType&&e.push({element:n,left:n.scrollLeft,top:n.scrollTop});for("function"===typeof t.focus&&t.focus(),t=0;t<e.length;t++)(n=e[t]).element.scrollLeft=n.left,n.element.scrollTop=n.top}}var nr=nt&&"documentMode"in document&&11>=document.documentMode,rr=null,ar=null,or=null,ir=!1;function sr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;ir||null==rr||rr!==pt(r)||("selectionStart"in(r=rr)&&er(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},or&&Yn(or,r)||(or=r,0<(r=zl(ar,"onSelect")).length&&(t=new Jt("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=rr)))}function ur(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var cr={animationend:ur("Animation","AnimationEnd"),animationiteration:ur("Animation","AnimationIteration"),animationstart:ur("Animation","AnimationStart"),transitionrun:ur("Transition","TransitionRun"),transitionstart:ur("Transition","TransitionStart"),transitioncancel:ur("Transition","TransitionCancel"),transitionend:ur("Transition","TransitionEnd")},lr={},hr={};function dr(e){if(lr[e])return lr[e];if(!cr[e])return e;var t,n=cr[e];for(t in n)if(n.hasOwnProperty(t)&&t in hr)return lr[e]=n[t];return e}nt&&(hr=document.createElement("div").style,"AnimationEvent"in window||(delete cr.animationend.animation,delete cr.animationiteration.animation,delete cr.animationstart.animation),"TransitionEvent"in window||delete cr.transitionend.transition);var pr=dr("animationend"),fr=dr("animationiteration"),mr=dr("animationstart"),gr=dr("transitionrun"),yr=dr("transitionstart"),br=dr("transitioncancel"),vr=dr("transitionend"),xr=new Map,wr="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" ");function kr(e,t){xr.set(e,t),et(t,[e])}var Cr=[],Dr=0,Sr=0;function Er(){for(var e=Dr,t=Sr=Dr=0;t<e;){var n=Cr[t];Cr[t++]=null;var r=Cr[t];Cr[t++]=null;var a=Cr[t];Cr[t++]=null;var o=Cr[t];if(Cr[t++]=null,null!==r&&null!==a){var i=r.pending;null===i?a.next=a:(a.next=i.next,i.next=a),r.pending=a}0!==o&&Ar(n,a,o)}}function Ir(e,t,n,r){Cr[Dr++]=e,Cr[Dr++]=t,Cr[Dr++]=n,Cr[Dr++]=r,Sr|=r,e.lanes|=r,null!==(e=e.alternate)&&(e.lanes|=r)}function Nr(e,t,n,r){return Ir(e,t,n,r),Fr(e)}function Tr(e,t){return Ir(e,null,null,t),Fr(e)}function Ar(e,t,n){e.lanes|=n;var r=e.alternate;null!==r&&(r.lanes|=n);for(var a=!1,o=e.return;null!==o;)o.childLanes|=n,null!==(r=o.alternate)&&(r.childLanes|=n),22===o.tag&&(null===(e=o.stateNode)||1&e._visibility||(a=!0)),e=o,o=o.return;a&&null!==t&&3===e.tag&&(o=e.stateNode,a=31-xe(n),null===(e=(o=o.hiddenUpdates)[a])?o[a]=[t]:e.push(t),t.lane=536870912|n)}function Fr(e){if(50<Nc)throw Nc=0,Tc=null,Error(i(185));for(var t=e.return;null!==t;)t=(e=t).return;return 3===e.tag?e.stateNode:null}var _r={},Rr=new WeakMap;function Mr(e,t){if("object"===typeof e&&null!==e){var n=Rr.get(e);return void 0!==n?n:(t={value:e,source:t,stack:z(t)},Rr.set(e,t),t)}return{value:e,source:t,stack:z(t)}}var Or=[],zr=0,Lr=null,Br=0,Pr=[],Wr=0,Ur=null,Vr=1,Gr="";function jr(e,t){Or[zr++]=Br,Or[zr++]=Lr,Lr=e,Br=t}function Hr(e,t,n){Pr[Wr++]=Vr,Pr[Wr++]=Gr,Pr[Wr++]=Ur,Ur=e;var r=Vr;e=Gr;var a=32-xe(r)-1;r&=~(1<<a),n+=1;var o=32-xe(t)+a;if(30<o){var i=a-a%5;o=(r&(1<<i)-1).toString(32),r>>=i,a-=i,Vr=1<<32-xe(t)+a|n<<a|r,Gr=o+e}else Vr=1<<o|n<<a|r,Gr=e}function qr(e){null!==e.return&&(jr(e,1),Hr(e,1,0))}function Kr(e){for(;e===Lr;)Lr=Or[--zr],Or[zr]=null,Br=Or[--zr],Or[zr]=null;for(;e===Ur;)Ur=Pr[--Wr],Pr[Wr]=null,Gr=Pr[--Wr],Pr[Wr]=null,Vr=Pr[--Wr],Pr[Wr]=null}var Xr=null,Yr=null,Qr=!1,Zr=null,Jr=!1,$r=Error(i(519));function ea(e){throw oa(Mr(Error(i(418,"")),e)),$r}function ta(e){var t=e.stateNode,n=e.type,r=e.memoizedProps;switch(t[Be]=e,t[Pe]=r,n){case"dialog":Tl("cancel",t),Tl("close",t);break;case"iframe":case"object":case"embed":Tl("load",t);break;case"video":case"audio":for(n=0;n<El.length;n++)Tl(El[n],t);break;case"source":Tl("error",t);break;case"img":case"image":case"link":Tl("error",t),Tl("load",t);break;case"details":Tl("toggle",t);break;case"input":Tl("invalid",t),yt(t,r.value,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name,!0),ht(t);break;case"select":Tl("invalid",t);break;case"textarea":Tl("invalid",t),wt(t,r.value,r.defaultValue,r.children),ht(t)}"string"!==typeof(n=r.children)&&"number"!==typeof n&&"bigint"!==typeof n||t.textContent===""+n||!0===r.suppressHydrationWarning||Vl(t.textContent,n)?(null!=r.popover&&(Tl("beforetoggle",t),Tl("toggle",t)),null!=r.onScroll&&Tl("scroll",t),null!=r.onScrollEnd&&Tl("scrollend",t),null!=r.onClick&&(t.onclick=Gl),t=!0):t=!1,t||ea(e)}function na(e){for(Xr=e.return;Xr;)switch(Xr.tag){case 3:case 27:return void(Jr=!0);case 5:case 13:return void(Jr=!1);default:Xr=Xr.return}}function ra(e){if(e!==Xr)return!1;if(!Qr)return na(e),Qr=!0,!1;var t,n=!1;if((t=3!==e.tag&&27!==e.tag)&&((t=5===e.tag)&&(t=!("form"!==(t=e.type)&&"button"!==t)||Jl(e.type,e.memoizedProps)),t=!t),t&&(n=!0),n&&Yr&&ea(e),na(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(i(317));e:{for(e=e.nextSibling,n=0;e;){if(8===e.nodeType)if("/$"===(t=e.data)){if(0===n){Yr=sh(e.nextSibling);break e}n--}else"$"!==t&&"$!"!==t&&"$?"!==t||n++;e=e.nextSibling}Yr=null}}else Yr=Xr?sh(e.stateNode.nextSibling):null;return!0}function aa(){Yr=Xr=null,Qr=!1}function oa(e){null===Zr?Zr=[e]:Zr.push(e)}var ia=Error(i(460)),sa=Error(i(474)),ua={then:function(){}};function ca(e){return"fulfilled"===(e=e.status)||"rejected"===e}function la(){}function ha(e,t,n){switch(void 0===(n=e[n])?e.push(t):n!==t&&(t.then(la,la),t=n),t.status){case"fulfilled":return t.value;case"rejected":if((e=t.reason)===ia)throw Error(i(483));throw e;default:if("string"===typeof t.status)t.then(la,la);else{if(null!==(e=tc)&&100<e.shellSuspendCounter)throw Error(i(482));(e=t).status="pending",e.then((function(e){if("pending"===t.status){var n=t;n.status="fulfilled",n.value=e}}),(function(e){if("pending"===t.status){var n=t;n.status="rejected",n.reason=e}}))}switch(t.status){case"fulfilled":return t.value;case"rejected":if((e=t.reason)===ia)throw Error(i(483));throw e}throw da=t,ia}}var da=null;function pa(){if(null===da)throw Error(i(459));var e=da;return da=null,e}var fa=null,ma=0;function ga(e){var t=ma;return ma+=1,null===fa&&(fa=[]),ha(fa,e,t)}function ya(e,t){t=t.props.ref,e.ref=void 0!==t?t:null}function ba(e,t){if(t.$$typeof===u)throw Error(i(525));throw e=Object.prototype.toString.call(t),Error(i(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function va(e){return(0,e._init)(e._payload)}function xa(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e){for(var t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function a(e,t){return(e=Lu(e,t)).index=0,e.sibling=null,e}function o(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=33554434,n):r:(t.flags|=33554434,n):(t.flags|=1048576,n)}function s(t){return e&&null===t.alternate&&(t.flags|=33554434),t}function u(e,t,n,r){return null===t||6!==t.tag?((t=Vu(n,e.mode,r)).return=e,t):((t=a(t,n)).return=e,t)}function d(e,t,n,r){var o=n.type;return o===h?f(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===o||"object"===typeof o&&null!==o&&o.$$typeof===w&&va(o)===t.type)?(ya(t=a(t,n.props),n),t.return=e,t):(ya(t=Pu(n.type,n.key,n.props,null,e.mode,r),n),t.return=e,t)}function p(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Gu(n,e.mode,r)).return=e,t):((t=a(t,n.children||[])).return=e,t)}function f(e,t,n,r,o){return null===t||7!==t.tag?((t=Wu(n,e.mode,r,o)).return=e,t):((t=a(t,n)).return=e,t)}function m(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t||"bigint"===typeof t)return(t=Vu(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case c:return ya(n=Pu(t.type,t.key,t.props,null,e.mode,n),t),n.return=e,n;case l:return(t=Gu(t,e.mode,n)).return=e,t;case w:return m(e,t=(0,t._init)(t._payload),n)}if(U(t)||S(t))return(t=Wu(t,e.mode,n,null)).return=e,t;if("function"===typeof t.then)return m(e,ga(t),n);if(t.$$typeof===g)return m(e,Es(e,t),n);ba(e,t)}return null}function y(e,t,n,r){var a=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n||"bigint"===typeof n)return null!==a?null:u(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case c:return n.key===a?d(e,t,n,r):null;case l:return n.key===a?p(e,t,n,r):null;case w:return y(e,t,n=(a=n._init)(n._payload),r)}if(U(n)||S(n))return null!==a?null:f(e,t,n,r,null);if("function"===typeof n.then)return y(e,t,ga(n),r);if(n.$$typeof===g)return y(e,t,Es(e,n),r);ba(e,n)}return null}function b(e,t,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r||"bigint"===typeof r)return u(t,e=e.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case c:return d(t,e=e.get(null===r.key?n:r.key)||null,r,a);case l:return p(t,e=e.get(null===r.key?n:r.key)||null,r,a);case w:return b(e,t,n,r=(0,r._init)(r._payload),a)}if(U(r)||S(r))return f(t,e=e.get(n)||null,r,a,null);if("function"===typeof r.then)return b(e,t,n,ga(r),a);if(r.$$typeof===g)return b(e,t,n,Es(t,r),a);ba(t,r)}return null}function v(u,d,p,f){if("object"===typeof p&&null!==p&&p.type===h&&null===p.key&&(p=p.props.children),"object"===typeof p&&null!==p){switch(p.$$typeof){case c:e:{for(var x=p.key;null!==d;){if(d.key===x){if((x=p.type)===h){if(7===d.tag){n(u,d.sibling),(f=a(d,p.props.children)).return=u,u=f;break e}}else if(d.elementType===x||"object"===typeof x&&null!==x&&x.$$typeof===w&&va(x)===d.type){n(u,d.sibling),ya(f=a(d,p.props),p),f.return=u,u=f;break e}n(u,d);break}t(u,d),d=d.sibling}p.type===h?((f=Wu(p.props.children,u.mode,f,p.key)).return=u,u=f):(ya(f=Pu(p.type,p.key,p.props,null,u.mode,f),p),f.return=u,u=f)}return s(u);case l:e:{for(x=p.key;null!==d;){if(d.key===x){if(4===d.tag&&d.stateNode.containerInfo===p.containerInfo&&d.stateNode.implementation===p.implementation){n(u,d.sibling),(f=a(d,p.children||[])).return=u,u=f;break e}n(u,d);break}t(u,d),d=d.sibling}(f=Gu(p,u.mode,f)).return=u,u=f}return s(u);case w:return v(u,d,p=(x=p._init)(p._payload),f)}if(U(p))return function(a,i,s,u){for(var c=null,l=null,h=i,d=i=0,p=null;null!==h&&d<s.length;d++){h.index>d?(p=h,h=null):p=h.sibling;var f=y(a,h,s[d],u);if(null===f){null===h&&(h=p);break}e&&h&&null===f.alternate&&t(a,h),i=o(f,i,d),null===l?c=f:l.sibling=f,l=f,h=p}if(d===s.length)return n(a,h),Qr&&jr(a,d),c;if(null===h){for(;d<s.length;d++)null!==(h=m(a,s[d],u))&&(i=o(h,i,d),null===l?c=h:l.sibling=h,l=h);return Qr&&jr(a,d),c}for(h=r(h);d<s.length;d++)null!==(p=b(h,a,d,s[d],u))&&(e&&null!==p.alternate&&h.delete(null===p.key?d:p.key),i=o(p,i,d),null===l?c=p:l.sibling=p,l=p);return e&&h.forEach((function(e){return t(a,e)})),Qr&&jr(a,d),c}(u,d,p,f);if(S(p)){if("function"!==typeof(x=S(p)))throw Error(i(150));return function(a,s,u,c){if(null==u)throw Error(i(151));for(var l=null,h=null,d=s,p=s=0,f=null,g=u.next();null!==d&&!g.done;p++,g=u.next()){d.index>p?(f=d,d=null):f=d.sibling;var v=y(a,d,g.value,c);if(null===v){null===d&&(d=f);break}e&&d&&null===v.alternate&&t(a,d),s=o(v,s,p),null===h?l=v:h.sibling=v,h=v,d=f}if(g.done)return n(a,d),Qr&&jr(a,p),l;if(null===d){for(;!g.done;p++,g=u.next())null!==(g=m(a,g.value,c))&&(s=o(g,s,p),null===h?l=g:h.sibling=g,h=g);return Qr&&jr(a,p),l}for(d=r(d);!g.done;p++,g=u.next())null!==(g=b(d,a,p,g.value,c))&&(e&&null!==g.alternate&&d.delete(null===g.key?p:g.key),s=o(g,s,p),null===h?l=g:h.sibling=g,h=g);return e&&d.forEach((function(e){return t(a,e)})),Qr&&jr(a,p),l}(u,d,p=x.call(p),f)}if("function"===typeof p.then)return v(u,d,ga(p),f);if(p.$$typeof===g)return v(u,d,Es(u,p),f);ba(u,p)}return"string"===typeof p&&""!==p||"number"===typeof p||"bigint"===typeof p?(p=""+p,null!==d&&6===d.tag?(n(u,d.sibling),(f=a(d,p)).return=u,u=f):(n(u,d),(f=Vu(p,u.mode,f)).return=u,u=f),s(u)):n(u,d)}return function(e,t,n,r){try{ma=0;var a=v(e,t,n,r);return fa=null,a}catch(i){if(i===ia)throw i;var o=Ou(29,i,null,e.mode);return o.lanes=r,o.return=e,o}}}var wa=xa(!0),ka=xa(!1),Ca=q(null),Da=q(0);function Sa(e,t){X(Da,e=cc),X(Ca,t),cc=e|t.baseLanes}function Ea(){X(Da,cc),X(Ca,Ca.current)}function Ia(){cc=Da.current,K(Ca),K(Da)}var Na=q(null),Ta=null;function Aa(e){var t=e.alternate;X(Ma,1&Ma.current),X(Na,e),null===Ta&&(null===t||null!==Ca.current||null!==t.memoizedState)&&(Ta=e)}function Fa(e){if(22===e.tag){if(X(Ma,Ma.current),X(Na,e),null===Ta){var t=e.alternate;null!==t&&null!==t.memoizedState&&(Ta=e)}}else _a()}function _a(){X(Ma,Ma.current),X(Na,Na.current)}function Ra(e){K(Na),Ta===e&&(Ta=null),K(Ma)}var Ma=q(0);function Oa(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var za="undefined"!==typeof AbortController?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(t,n){e.push(n)}};this.abort=function(){t.aborted=!0,e.forEach((function(e){return e()}))}},La=r.unstable_scheduleCallback,Ba=r.unstable_NormalPriority,Pa={$$typeof:g,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Wa(){return{controller:new za,data:new Map,refCount:0}}function Ua(e){e.refCount--,0===e.refCount&&La(Ba,(function(){e.controller.abort()}))}var Va=null,Ga=0,ja=0,Ha=null;function qa(){if(0===--Ga&&null!==Va){null!==Ha&&(Ha.status="fulfilled");var e=Va;Va=null,ja=0,Ha=null;for(var t=0;t<e.length;t++)(0,e[t])()}}var Ka=A.S;A.S=function(e,t){"object"===typeof t&&null!==t&&"function"===typeof t.then&&function(e,t){if(null===Va){var n=Va=[];Ga=0,ja=wl(),Ha={status:"pending",value:void 0,then:function(e){n.push(e)}}}Ga++,t.then(qa,qa)}(0,t),null!==Ka&&Ka(e,t)};var Xa=q(null);function Ya(){var e=Xa.current;return null!==e?e:tc.pooledCache}function Qa(e,t){X(Xa,null===t?Xa.current:t.pool)}function Za(){var e=Ya();return null===e?null:{parent:Pa._currentValue,pool:e}}var Ja=0,$a=null,eo=null,to=null,no=!1,ro=!1,ao=!1,oo=0,io=0,so=null,uo=0;function co(){throw Error(i(321))}function lo(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Xn(e[n],t[n]))return!1;return!0}function ho(e,t,n,r,a,o){return Ja=o,$a=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,A.H=null===e||null===e.memoizedState?Ei:Ii,ao=!1,o=n(r,a),ao=!1,ro&&(o=fo(t,n,r,a)),po(e),o}function po(e){A.H=Si;var t=null!==eo&&null!==eo.next;if(Ja=0,to=eo=$a=null,no=!1,io=0,so=null,t)throw Error(i(300));null===e||ji||null!==(e=e.dependencies)&&Cs(e)&&(ji=!0)}function fo(e,t,n,r){$a=e;var a=0;do{if(ro&&(so=null),io=0,ro=!1,25<=a)throw Error(i(301));if(a+=1,to=eo=null,null!=e.updateQueue){var o=e.updateQueue;o.lastEffect=null,o.events=null,o.stores=null,null!=o.memoCache&&(o.memoCache.index=0)}A.H=Ni,o=t(n,r)}while(ro);return o}function mo(){var e=A.H,t=e.useState()[0];return t="function"===typeof t.then?wo(t):t,e=e.useState()[0],(null!==eo?eo.memoizedState:null)!==e&&($a.flags|=1024),t}function go(){var e=0!==oo;return oo=0,e}function yo(e,t,n){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~n}function bo(e){if(no){for(e=e.memoizedState;null!==e;){var t=e.queue;null!==t&&(t.pending=null),e=e.next}no=!1}Ja=0,to=eo=$a=null,ro=!1,io=oo=0,so=null}function vo(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===to?$a.memoizedState=to=e:to=to.next=e,to}function xo(){if(null===eo){var e=$a.alternate;e=null!==e?e.memoizedState:null}else e=eo.next;var t=null===to?$a.memoizedState:to.next;if(null!==t)to=t,eo=e;else{if(null===e){if(null===$a.alternate)throw Error(i(467));throw Error(i(310))}e={memoizedState:(eo=e).memoizedState,baseState:eo.baseState,baseQueue:eo.baseQueue,queue:eo.queue,next:null},null===to?$a.memoizedState=to=e:to=to.next=e}return to}function wo(e){var t=io;return io+=1,null===so&&(so=[]),e=ha(so,e,t),t=$a,null===(null===to?t.memoizedState:to.next)&&(t=t.alternate,A.H=null===t||null===t.memoizedState?Ei:Ii),e}function ko(e){if(null!==e&&"object"===typeof e){if("function"===typeof e.then)return wo(e);if(e.$$typeof===g)return Ss(e)}throw Error(i(438,String(e)))}function Co(e){var t=null,n=$a.updateQueue;if(null!==n&&(t=n.memoCache),null==t){var r=$a.alternate;null!==r&&(null!==(r=r.updateQueue)&&(null!=(r=r.memoCache)&&(t={data:r.data.map((function(e){return e.slice()})),index:0})))}if(null==t&&(t={data:[],index:0}),null===n&&(n={lastEffect:null,events:null,stores:null,memoCache:null},$a.updateQueue=n),n.memoCache=t,void 0===(n=t.data[t.index]))for(n=t.data[t.index]=Array(e),r=0;r<e;r++)n[r]=C;return t.index++,n}function Do(e,t){return"function"===typeof t?t(e):t}function So(e){return Eo(xo(),eo,e)}function Eo(e,t,n){var r=e.queue;if(null===r)throw Error(i(311));r.lastRenderedReducer=n;var a=e.baseQueue,o=r.pending;if(null!==o){if(null!==a){var s=a.next;a.next=o.next,o.next=s}t.baseQueue=a=o,r.pending=null}if(o=e.baseState,null===a)e.memoizedState=o;else{var u=s=null,c=null,l=t=a.next,h=!1;do{var d=-536870913&l.lane;if(d!==l.lane?(rc&d)===d:(Ja&d)===d){var p=l.revertLane;if(0===p)null!==c&&(c=c.next={lane:0,revertLane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d===ja&&(h=!0);else{if((Ja&p)===p){l=l.next,p===ja&&(h=!0);continue}d={lane:0,revertLane:l.revertLane,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null},null===c?(u=c=d,s=o):c=c.next=d,$a.lanes|=p,hc|=p}d=l.action,ao&&n(o,d),o=l.hasEagerState?l.eagerState:n(o,d)}else p={lane:d,revertLane:l.revertLane,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null},null===c?(u=c=p,s=o):c=c.next=p,$a.lanes|=d,hc|=d;l=l.next}while(null!==l&&l!==t);if(null===c?s=o:c.next=u,!Xn(o,e.memoizedState)&&(ji=!0,h&&null!==(n=Ha)))throw n;e.memoizedState=o,e.baseState=s,e.baseQueue=c,r.lastRenderedState=o}return null===a&&(r.lanes=0),[e.memoizedState,r.dispatch]}function Io(e){var t=xo(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,o=t.memoizedState;if(null!==a){n.pending=null;var s=a=a.next;do{o=e(o,s.action),s=s.next}while(s!==a);Xn(o,t.memoizedState)||(ji=!0),t.memoizedState=o,null===t.baseQueue&&(t.baseState=o),n.lastRenderedState=o}return[o,r]}function No(e,t,n){var r=$a,a=xo(),o=Qr;if(o){if(void 0===n)throw Error(i(407));n=n()}else n=t();var s=!Xn((eo||a).memoizedState,n);if(s&&(a.memoizedState=n,ji=!0),a=a.queue,$o(Fo.bind(null,r,a,e),[e]),a.getSnapshot!==t||s||null!==to&&1&to.memoizedState.tag){if(r.flags|=2048,Xo(9,Ao.bind(null,r,a,n,t),{destroy:void 0},null),null===tc)throw Error(i(349));o||0!==(60&Ja)||To(r,t,n)}return n}function To(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=$a.updateQueue)?(t={lastEffect:null,events:null,stores:null,memoCache:null},$a.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ao(e,t,n,r){t.value=n,t.getSnapshot=r,_o(t)&&Ro(e)}function Fo(e,t,n){return n((function(){_o(t)&&Ro(e)}))}function _o(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Xn(e,n)}catch(r){return!0}}function Ro(e){var t=Tr(e,2);null!==t&&_c(t,e,2)}function Mo(e){var t=vo();if("function"===typeof e){var n=e;if(e=n(),ao){ve(!0);try{n()}finally{ve(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Do,lastRenderedState:e},t}function Oo(e,t,n,r){return e.baseState=n,Eo(e,eo,"function"===typeof r?r:Do)}function zo(e,t,n,r,a){if(ki(e))throw Error(i(485));if(null!==(e=t.action)){var o={payload:a,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(e){o.listeners.push(e)}};null!==A.T?n(!0):o.isTransition=!1,r(o),null===(n=t.pending)?(o.next=t.pending=o,Lo(t,o)):(o.next=n.next,t.pending=n.next=o)}}function Lo(e,t){var n=t.action,r=t.payload,a=e.state;if(t.isTransition){var o=A.T,i={};A.T=i;try{var s=n(a,r),u=A.S;null!==u&&u(i,s),Bo(e,t,s)}catch(c){Wo(e,t,c)}finally{A.T=o}}else try{Bo(e,t,o=n(a,r))}catch(l){Wo(e,t,l)}}function Bo(e,t,n){null!==n&&"object"===typeof n&&"function"===typeof n.then?n.then((function(n){Po(e,t,n)}),(function(n){return Wo(e,t,n)})):Po(e,t,n)}function Po(e,t,n){t.status="fulfilled",t.value=n,Uo(t),e.state=n,null!==(t=e.pending)&&((n=t.next)===t?e.pending=null:(n=n.next,t.next=n,Lo(e,n)))}function Wo(e,t,n){var r=e.pending;if(e.pending=null,null!==r){r=r.next;do{t.status="rejected",t.reason=n,Uo(t),t=t.next}while(t!==r)}e.action=null}function Uo(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function Vo(e,t){return t}function Go(e,t){if(Qr){var n=tc.formState;if(null!==n){e:{var r=$a;if(Qr){if(Yr){t:{for(var a=Yr,o=Jr;8!==a.nodeType;){if(!o){a=null;break t}if(null===(a=sh(a.nextSibling))){a=null;break t}}a="F!"===(o=a.data)||"F"===o?a:null}if(a){Yr=sh(a.nextSibling),r="F!"===a.data;break e}}ea(r)}r=!1}r&&(t=n[0])}}return(n=vo()).memoizedState=n.baseState=t,r={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Vo,lastRenderedState:t},n.queue=r,n=vi.bind(null,$a,r),r.dispatch=n,r=Mo(!1),o=wi.bind(null,$a,!1,r.queue),a={state:t,dispatch:null,action:e,pending:null},(r=vo()).queue=a,n=zo.bind(null,$a,a,o,n),a.dispatch=n,r.memoizedState=e,[t,n,!1]}function jo(e){return Ho(xo(),eo,e)}function Ho(e,t,n){t=Eo(e,t,Vo)[0],e=So(Do)[0],t="object"===typeof t&&null!==t&&"function"===typeof t.then?wo(t):t;var r=xo(),a=r.queue,o=a.dispatch;return n!==r.memoizedState&&($a.flags|=2048,Xo(9,qo.bind(null,a,n),{destroy:void 0},null)),[t,o,e]}function qo(e,t){e.action=t}function Ko(e){var t=xo(),n=eo;if(null!==n)return Ho(t,n,e);xo(),t=t.memoizedState;var r=(n=xo()).queue.dispatch;return n.memoizedState=e,[t,r,!1]}function Xo(e,t,n,r){return e={tag:e,create:t,inst:n,deps:r,next:null},null===(t=$a.updateQueue)&&(t={lastEffect:null,events:null,stores:null,memoCache:null},$a.updateQueue=t),null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function Yo(){return xo().memoizedState}function Qo(e,t,n,r){var a=vo();$a.flags|=e,a.memoizedState=Xo(1|t,n,{destroy:void 0},void 0===r?null:r)}function Zo(e,t,n,r){var a=xo();r=void 0===r?null:r;var o=a.memoizedState.inst;null!==eo&&null!==r&&lo(r,eo.memoizedState.deps)?a.memoizedState=Xo(t,n,o,r):($a.flags|=e,a.memoizedState=Xo(1|t,n,o,r))}function Jo(e,t){Qo(8390656,8,e,t)}function $o(e,t){Zo(2048,8,e,t)}function ei(e,t){return Zo(4,2,e,t)}function ti(e,t){return Zo(4,4,e,t)}function ni(e,t){if("function"===typeof t){e=e();var n=t(e);return function(){"function"===typeof n?n():t(null)}}if(null!==t&&void 0!==t)return e=e(),t.current=e,function(){t.current=null}}function ri(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,Zo(4,4,ni.bind(null,t,e),n)}function ai(){}function oi(e,t){var n=xo();t=void 0===t?null:t;var r=n.memoizedState;return null!==t&&lo(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function ii(e,t){var n=xo();t=void 0===t?null:t;var r=n.memoizedState;if(null!==t&&lo(t,r[1]))return r[0];if(r=e(),ao){ve(!0);try{e()}finally{ve(!1)}}return n.memoizedState=[r,t],r}function si(e,t,n){return void 0===n||0!==(1073741824&Ja)?e.memoizedState=t:(e.memoizedState=n,e=Fc(),$a.lanes|=e,hc|=e,n)}function ui(e,t,n,r){return Xn(n,t)?n:null!==Ca.current?(e=si(e,n,r),Xn(e,t)||(ji=!0),e):0===(42&Ja)?(ji=!0,e.memoizedState=n):(e=Fc(),$a.lanes|=e,hc|=e,t)}function ci(e,t,n,r,a){var o=V.p;V.p=0!==o&&8>o?o:8;var i=A.T,s={};A.T=s,wi(e,!1,t,n);try{var u=a(),c=A.S;if(null!==c&&c(s,u),null!==u&&"object"===typeof u&&"function"===typeof u.then)xi(e,t,function(e,t){var n=[],r={status:"pending",value:null,reason:null,then:function(e){n.push(e)}};return e.then((function(){r.status="fulfilled",r.value=t;for(var e=0;e<n.length;e++)(0,n[e])(t)}),(function(e){for(r.status="rejected",r.reason=e,e=0;e<n.length;e++)(0,n[e])(void 0)})),r}(u,r),Ac());else xi(e,t,r,Ac())}catch(l){xi(e,t,{then:function(){},status:"rejected",reason:l},Ac())}finally{V.p=o,A.T=i}}function li(){}function hi(e,t,n,r){if(5!==e.tag)throw Error(i(476));var a=di(e).queue;ci(e,a,t,G,null===n?li:function(){return pi(e),n(r)})}function di(e){var t=e.memoizedState;if(null!==t)return t;var n={};return(t={memoizedState:G,baseState:G,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Do,lastRenderedState:G},next:null}).next={memoizedState:n,baseState:n,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Do,lastRenderedState:n},next:null},e.memoizedState=t,null!==(e=e.alternate)&&(e.memoizedState=t),t}function pi(e){xi(e,di(e).next.queue,{},Ac())}function fi(){return Ss(zh)}function mi(){return xo().memoizedState}function gi(){return xo().memoizedState}function yi(e){for(var t=e.return;null!==t;){switch(t.tag){case 24:case 3:var n=Ac(),r=_s(t,e=Fs(n),n);return null!==r&&(_c(r,t,n),Rs(r,t,n)),t={cache:Wa()},void(e.payload=t)}t=t.return}}function bi(e,t,n){var r=Ac();n={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null},ki(e)?Ci(t,n):null!==(n=Nr(e,t,n,r))&&(_c(n,e,r),Di(n,t,r))}function vi(e,t,n){xi(e,t,n,Ac())}function xi(e,t,n,r){var a={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null};if(ki(e))Ci(t,a);else{var o=e.alternate;if(0===e.lanes&&(null===o||0===o.lanes)&&null!==(o=t.lastRenderedReducer))try{var i=t.lastRenderedState,s=o(i,n);if(a.hasEagerState=!0,a.eagerState=s,Xn(s,i))return Ir(e,t,a,0),null===tc&&Er(),!1}catch(u){}if(null!==(n=Nr(e,t,a,r)))return _c(n,e,r),Di(n,t,r),!0}return!1}function wi(e,t,n,r){if(r={lane:2,revertLane:wl(),action:r,hasEagerState:!1,eagerState:null,next:null},ki(e)){if(t)throw Error(i(479))}else null!==(t=Nr(e,n,r,2))&&_c(t,e,2)}function ki(e){var t=e.alternate;return e===$a||null!==t&&t===$a}function Ci(e,t){ro=no=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Di(e,t,n){if(0!==(4194176&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Me(e,n)}}var Si={readContext:Ss,use:ko,useCallback:co,useContext:co,useEffect:co,useImperativeHandle:co,useLayoutEffect:co,useInsertionEffect:co,useMemo:co,useReducer:co,useRef:co,useState:co,useDebugValue:co,useDeferredValue:co,useTransition:co,useSyncExternalStore:co,useId:co};Si.useCacheRefresh=co,Si.useMemoCache=co,Si.useHostTransitionStatus=co,Si.useFormState=co,Si.useActionState=co,Si.useOptimistic=co;var Ei={readContext:Ss,use:ko,useCallback:function(e,t){return vo().memoizedState=[e,void 0===t?null:t],e},useContext:Ss,useEffect:Jo,useImperativeHandle:function(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,Qo(4194308,4,ni.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Qo(4194308,4,e,t)},useInsertionEffect:function(e,t){Qo(4,2,e,t)},useMemo:function(e,t){var n=vo();t=void 0===t?null:t;var r=e();if(ao){ve(!0);try{e()}finally{ve(!1)}}return n.memoizedState=[r,t],r},useReducer:function(e,t,n){var r=vo();if(void 0!==n){var a=n(t);if(ao){ve(!0);try{n(t)}finally{ve(!1)}}}else a=t;return r.memoizedState=r.baseState=a,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:a},r.queue=e,e=e.dispatch=bi.bind(null,$a,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},vo().memoizedState=e},useState:function(e){var t=(e=Mo(e)).queue,n=vi.bind(null,$a,t);return t.dispatch=n,[e.memoizedState,n]},useDebugValue:ai,useDeferredValue:function(e,t){return si(vo(),e,t)},useTransition:function(){var e=Mo(!1);return e=ci.bind(null,$a,e.queue,!0,!1),vo().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,n){var r=$a,a=vo();if(Qr){if(void 0===n)throw Error(i(407));n=n()}else{if(n=t(),null===tc)throw Error(i(349));0!==(60&rc)||To(r,t,n)}a.memoizedState=n;var o={value:n,getSnapshot:t};return a.queue=o,Jo(Fo.bind(null,r,o,e),[e]),r.flags|=2048,Xo(9,Ao.bind(null,r,o,n,t),{destroy:void 0},null),n},useId:function(){var e=vo(),t=tc.identifierPrefix;if(Qr){var n=Gr;t=":"+t+"R"+(n=(Vr&~(1<<32-xe(Vr)-1)).toString(32)+n),0<(n=oo++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=uo++).toString(32)+":";return e.memoizedState=t},useCacheRefresh:function(){return vo().memoizedState=yi.bind(null,$a)}};Ei.useMemoCache=Co,Ei.useHostTransitionStatus=fi,Ei.useFormState=Go,Ei.useActionState=Go,Ei.useOptimistic=function(e){var t=vo();t.memoizedState=t.baseState=e;var n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=n,t=wi.bind(null,$a,!0,n),n.dispatch=t,[e,t]};var Ii={readContext:Ss,use:ko,useCallback:oi,useContext:Ss,useEffect:$o,useImperativeHandle:ri,useInsertionEffect:ei,useLayoutEffect:ti,useMemo:ii,useReducer:So,useRef:Yo,useState:function(){return So(Do)},useDebugValue:ai,useDeferredValue:function(e,t){return ui(xo(),eo.memoizedState,e,t)},useTransition:function(){var e=So(Do)[0],t=xo().memoizedState;return["boolean"===typeof e?e:wo(e),t]},useSyncExternalStore:No,useId:mi};Ii.useCacheRefresh=gi,Ii.useMemoCache=Co,Ii.useHostTransitionStatus=fi,Ii.useFormState=jo,Ii.useActionState=jo,Ii.useOptimistic=function(e,t){return Oo(xo(),0,e,t)};var Ni={readContext:Ss,use:ko,useCallback:oi,useContext:Ss,useEffect:$o,useImperativeHandle:ri,useInsertionEffect:ei,useLayoutEffect:ti,useMemo:ii,useReducer:Io,useRef:Yo,useState:function(){return Io(Do)},useDebugValue:ai,useDeferredValue:function(e,t){var n=xo();return null===eo?si(n,e,t):ui(n,eo.memoizedState,e,t)},useTransition:function(){var e=Io(Do)[0],t=xo().memoizedState;return["boolean"===typeof e?e:wo(e),t]},useSyncExternalStore:No,useId:mi};function Ti(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:F({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}Ni.useCacheRefresh=gi,Ni.useMemoCache=Co,Ni.useHostTransitionStatus=fi,Ni.useFormState=Ko,Ni.useActionState=Ko,Ni.useOptimistic=function(e,t){var n=xo();return null!==eo?Oo(n,0,e,t):(n.baseState=e,[e,n.queue.dispatch])};var Ai={isMounted:function(e){return!!(e=e._reactInternals)&&L(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=Ac(),a=Fs(r);a.payload=t,void 0!==n&&null!==n&&(a.callback=n),null!==(t=_s(e,a,r))&&(_c(t,e,r),Rs(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=Ac(),a=Fs(r);a.tag=1,a.payload=t,void 0!==n&&null!==n&&(a.callback=n),null!==(t=_s(e,a,r))&&(_c(t,e,r),Rs(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=Ac(),r=Fs(n);r.tag=2,void 0!==t&&null!==t&&(r.callback=t),null!==(t=_s(e,r,n))&&(_c(t,e,n),Rs(t,e,n))}};function Fi(e,t,n,r,a,o,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,o,i):!t.prototype||!t.prototype.isPureReactComponent||(!Yn(n,r)||!Yn(a,o))}function _i(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&Ai.enqueueReplaceState(t,t.state,null)}function Ri(e,t){var n=t;if("ref"in t)for(var r in n={},t)"ref"!==r&&(n[r]=t[r]);if(e=e.defaultProps)for(var a in n===t&&(n=F({},n)),e)void 0===n[a]&&(n[a]=e[a]);return n}var Mi="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function Oi(e){Mi(e)}function zi(e){console.error(e)}function Li(e){Mi(e)}function Bi(e,t){try{(0,e.onUncaughtError)(t.value,{componentStack:t.stack})}catch(n){setTimeout((function(){throw n}))}}function Pi(e,t,n){try{(0,e.onCaughtError)(n.value,{componentStack:n.stack,errorBoundary:1===t.tag?t.stateNode:null})}catch(r){setTimeout((function(){throw r}))}}function Wi(e,t,n){return(n=Fs(n)).tag=3,n.payload={element:null},n.callback=function(){Bi(e,t)},n}function Ui(e){return(e=Fs(e)).tag=3,e}function Vi(e,t,n,r){var a=n.type.getDerivedStateFromError;if("function"===typeof a){var o=r.value;e.payload=function(){return a(o)},e.callback=function(){Pi(t,n,r)}}var i=n.stateNode;null!==i&&"function"===typeof i.componentDidCatch&&(e.callback=function(){Pi(t,n,r),"function"!==typeof a&&(null===kc?kc=new Set([this]):kc.add(this));var e=r.stack;this.componentDidCatch(r.value,{componentStack:null!==e?e:""})})}var Gi=Error(i(461)),ji=!1;function Hi(e,t,n,r){t.child=null===e?ka(t,null,n,r):wa(t,e.child,n,r)}function qi(e,t,n,r,a){n=n.render;var o=t.ref;if("ref"in r){var i={};for(var s in r)"ref"!==s&&(i[s]=r[s])}else i=r;return Ds(t),r=ho(e,t,n,i,o,a),s=go(),null===e||ji?(Qr&&s&&qr(t),t.flags|=1,Hi(e,t,r,a),t.child):(yo(e,t,a),ds(e,t,a))}function Ki(e,t,n,r,a){if(null===e){var o=n.type;return"function"!==typeof o||zu(o)||void 0!==o.defaultProps||null!==n.compare?((e=Pu(n.type,null,r,t,t.mode,a)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=o,Xi(e,t,o,r,a))}if(o=e.child,!ps(e,a)){var i=o.memoizedProps;if((n=null!==(n=n.compare)?n:Yn)(i,r)&&e.ref===t.ref)return ds(e,t,a)}return t.flags|=1,(e=Lu(o,r)).ref=t.ref,e.return=t,t.child=e}function Xi(e,t,n,r,a){if(null!==e){var o=e.memoizedProps;if(Yn(o,r)&&e.ref===t.ref){if(ji=!1,t.pendingProps=r=o,!ps(e,a))return t.lanes=e.lanes,ds(e,t,a);0!==(131072&e.flags)&&(ji=!0)}}return Ji(e,t,n,r,a)}function Yi(e,t,n){var r=t.pendingProps,a=r.children,o=0!==(2&t.stateNode._pendingVisibility),i=null!==e?e.memoizedState:null;if(Zi(e,t),"hidden"===r.mode||o){if(0!==(128&t.flags)){if(r=null!==i?i.baseLanes|n:n,null!==e){for(a=t.child=e.child,o=0;null!==a;)o=o|a.lanes|a.childLanes,a=a.sibling;t.childLanes=o&~r}else t.childLanes=0,t.child=null;return Qi(e,t,r,n)}if(0===(536870912&n))return t.lanes=t.childLanes=536870912,Qi(e,t,null!==i?i.baseLanes|n:n,n);t.memoizedState={baseLanes:0,cachePool:null},null!==e&&Qa(0,null!==i?i.cachePool:null),null!==i?Sa(t,i):Ea(),Fa(t)}else null!==i?(Qa(0,i.cachePool),Sa(t,i),_a(),t.memoizedState=null):(null!==e&&Qa(0,null),Ea(),_a());return Hi(e,t,a,n),t.child}function Qi(e,t,n,r){var a=Ya();return a=null===a?null:{parent:Pa._currentValue,pool:a},t.memoizedState={baseLanes:n,cachePool:a},null!==e&&Qa(0,null),Ea(),Fa(t),null!==e&&ks(e,t,r,!0),null}function Zi(e,t){var n=t.ref;if(null===n)null!==e&&null!==e.ref&&(t.flags|=2097664);else{if("function"!==typeof n&&"object"!==typeof n)throw Error(i(284));null!==e&&e.ref===n||(t.flags|=2097664)}}function Ji(e,t,n,r,a){return Ds(t),n=ho(e,t,n,r,void 0,a),r=go(),null===e||ji?(Qr&&r&&qr(t),t.flags|=1,Hi(e,t,n,a),t.child):(yo(e,t,a),ds(e,t,a))}function $i(e,t,n,r,a,o){return Ds(t),t.updateQueue=null,n=fo(t,r,n,a),po(e),r=go(),null===e||ji?(Qr&&r&&qr(t),t.flags|=1,Hi(e,t,n,o),t.child):(yo(e,t,o),ds(e,t,o))}function es(e,t,n,r,a){if(Ds(t),null===t.stateNode){var o=_r,i=n.contextType;"object"===typeof i&&null!==i&&(o=Ss(i)),o=new n(r,o),t.memoizedState=null!==o.state&&void 0!==o.state?o.state:null,o.updater=Ai,t.stateNode=o,o._reactInternals=t,(o=t.stateNode).props=r,o.state=t.memoizedState,o.refs={},Ts(t),i=n.contextType,o.context="object"===typeof i&&null!==i?Ss(i):_r,o.state=t.memoizedState,"function"===typeof(i=n.getDerivedStateFromProps)&&(Ti(t,n,i,r),o.state=t.memoizedState),"function"===typeof n.getDerivedStateFromProps||"function"===typeof o.getSnapshotBeforeUpdate||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||(i=o.state,"function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount(),i!==o.state&&Ai.enqueueReplaceState(o,o.state,null),Ls(t,r,o,a),zs(),o.state=t.memoizedState),"function"===typeof o.componentDidMount&&(t.flags|=4194308),r=!0}else if(null===e){o=t.stateNode;var s=t.memoizedProps,u=Ri(n,s);o.props=u;var c=o.context,l=n.contextType;i=_r,"object"===typeof l&&null!==l&&(i=Ss(l));var h=n.getDerivedStateFromProps;l="function"===typeof h||"function"===typeof o.getSnapshotBeforeUpdate,s=t.pendingProps!==s,l||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(s||c!==i)&&_i(t,o,r,i),Ns=!1;var d=t.memoizedState;o.state=d,Ls(t,r,o,a),zs(),c=t.memoizedState,s||d!==c||Ns?("function"===typeof h&&(Ti(t,n,h,r),c=t.memoizedState),(u=Ns||Fi(t,n,u,r,d,c,i))?(l||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||("function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount()),"function"===typeof o.componentDidMount&&(t.flags|=4194308)):("function"===typeof o.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=c),o.props=r,o.state=c,o.context=i,r=u):("function"===typeof o.componentDidMount&&(t.flags|=4194308),r=!1)}else{o=t.stateNode,As(e,t),l=Ri(n,i=t.memoizedProps),o.props=l,h=t.pendingProps,d=o.context,c=n.contextType,u=_r,"object"===typeof c&&null!==c&&(u=Ss(c)),(c="function"===typeof(s=n.getDerivedStateFromProps)||"function"===typeof o.getSnapshotBeforeUpdate)||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==h||d!==u)&&_i(t,o,r,u),Ns=!1,d=t.memoizedState,o.state=d,Ls(t,r,o,a),zs();var p=t.memoizedState;i!==h||d!==p||Ns||null!==e&&null!==e.dependencies&&Cs(e.dependencies)?("function"===typeof s&&(Ti(t,n,s,r),p=t.memoizedState),(l=Ns||Fi(t,n,l,r,d,p,u)||null!==e&&null!==e.dependencies&&Cs(e.dependencies))?(c||"function"!==typeof o.UNSAFE_componentWillUpdate&&"function"!==typeof o.componentWillUpdate||("function"===typeof o.componentWillUpdate&&o.componentWillUpdate(r,p,u),"function"===typeof o.UNSAFE_componentWillUpdate&&o.UNSAFE_componentWillUpdate(r,p,u)),"function"===typeof o.componentDidUpdate&&(t.flags|=4),"function"===typeof o.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof o.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=p),o.props=r,o.state=p,o.context=u,r=l):("function"!==typeof o.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),r=!1)}return o=r,Zi(e,t),r=0!==(128&t.flags),o||r?(o=t.stateNode,n=r&&"function"!==typeof n.getDerivedStateFromError?null:o.render(),t.flags|=1,null!==e&&r?(t.child=wa(t,e.child,null,a),t.child=wa(t,null,n,a)):Hi(e,t,n,a),t.memoizedState=o.state,e=t.child):e=ds(e,t,a),e}function ts(e,t,n,r){return aa(),t.flags|=256,Hi(e,t,n,r),t.child}var ns={dehydrated:null,treeContext:null,retryLane:0};function rs(e){return{baseLanes:e,cachePool:Za()}}function as(e,t,n){return e=null!==e?e.childLanes&~n:0,t&&(e|=fc),e}function os(e,t,n){var r,a=t.pendingProps,o=!1,s=0!==(128&t.flags);if((r=s)||(r=(null===e||null!==e.memoizedState)&&0!==(2&Ma.current)),r&&(o=!0,t.flags&=-129),r=0!==(32&t.flags),t.flags&=-33,null===e){if(Qr){if(o?Aa(t):_a(),Qr){var u,c=Yr;if(u=c){e:{for(u=c,c=Jr;8!==u.nodeType;){if(!c){c=null;break e}if(null===(u=sh(u.nextSibling))){c=null;break e}}c=u}null!==c?(t.memoizedState={dehydrated:c,treeContext:null!==Ur?{id:Vr,overflow:Gr}:null,retryLane:536870912},(u=Ou(18,null,null,0)).stateNode=c,u.return=t,t.child=u,Xr=t,Yr=null,u=!0):u=!1}u||ea(t)}if(null!==(c=t.memoizedState)&&null!==(c=c.dehydrated))return"$!"===c.data?t.lanes=16:t.lanes=536870912,null;Ra(t)}return c=a.children,a=a.fallback,o?(_a(),c=ss({mode:"hidden",children:c},o=t.mode),a=Wu(a,o,n,null),c.return=t,a.return=t,c.sibling=a,t.child=c,(o=t.child).memoizedState=rs(n),o.childLanes=as(e,r,n),t.memoizedState=ns,a):(Aa(t),is(t,c))}if(null!==(u=e.memoizedState)&&null!==(c=u.dehydrated)){if(s)256&t.flags?(Aa(t),t.flags&=-257,t=us(e,t,n)):null!==t.memoizedState?(_a(),t.child=e.child,t.flags|=128,t=null):(_a(),o=a.fallback,c=t.mode,a=ss({mode:"visible",children:a.children},c),(o=Wu(o,c,n,null)).flags|=2,a.return=t,o.return=t,a.sibling=o,t.child=a,wa(t,e.child,null,n),(a=t.child).memoizedState=rs(n),a.childLanes=as(e,r,n),t.memoizedState=ns,t=o);else if(Aa(t),"$!"===c.data){if(r=c.nextSibling&&c.nextSibling.dataset)var l=r.dgst;r=l,(a=Error(i(419))).stack="",a.digest=r,oa({value:a,source:null,stack:null}),t=us(e,t,n)}else if(ji||ks(e,t,n,!1),r=0!==(n&e.childLanes),ji||r){if(null!==(r=tc)){if(0!==(42&(a=n&-n)))a=1;else switch(a){case 2:a=1;break;case 8:a=4;break;case 32:a=16;break;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:a=64;break;case 268435456:a=134217728;break;default:a=0}if(0!==(a=0!==(a&(r.suspendedLanes|n))?0:a)&&a!==u.retryLane)throw u.retryLane=a,Tr(e,a),_c(r,e,a),Gi}"$?"===c.data||jc(),t=us(e,t,n)}else"$?"===c.data?(t.flags|=128,t.child=e.child,t=sl.bind(null,e),c._reactRetry=t,t=null):(e=u.treeContext,Yr=sh(c.nextSibling),Xr=t,Qr=!0,Zr=null,Jr=!1,null!==e&&(Pr[Wr++]=Vr,Pr[Wr++]=Gr,Pr[Wr++]=Ur,Vr=e.id,Gr=e.overflow,Ur=t),(t=is(t,a.children)).flags|=4096);return t}return o?(_a(),o=a.fallback,c=t.mode,l=(u=e.child).sibling,(a=Lu(u,{mode:"hidden",children:a.children})).subtreeFlags=31457280&u.subtreeFlags,null!==l?o=Lu(l,o):(o=Wu(o,c,n,null)).flags|=2,o.return=t,a.return=t,a.sibling=o,t.child=a,a=o,o=t.child,null===(c=e.child.memoizedState)?c=rs(n):(null!==(u=c.cachePool)?(l=Pa._currentValue,u=u.parent!==l?{parent:l,pool:l}:u):u=Za(),c={baseLanes:c.baseLanes|n,cachePool:u}),o.memoizedState=c,o.childLanes=as(e,r,n),t.memoizedState=ns,a):(Aa(t),e=(n=e.child).sibling,(n=Lu(n,{mode:"visible",children:a.children})).return=t,n.sibling=null,null!==e&&(null===(r=t.deletions)?(t.deletions=[e],t.flags|=16):r.push(e)),t.child=n,t.memoizedState=null,n)}function is(e,t){return(t=ss({mode:"visible",children:t},e.mode)).return=e,e.child=t}function ss(e,t){return Uu(e,t,0,null)}function us(e,t,n){return wa(t,e.child,null,n),(e=is(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function cs(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),xs(e.return,t,n)}function ls(e,t,n,r,a){var o=e.memoizedState;null===o?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=r,o.tail=n,o.tailMode=a)}function hs(e,t,n){var r=t.pendingProps,a=r.revealOrder,o=r.tail;if(Hi(e,t,r.children,n),0!==(2&(r=Ma.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&cs(e,n,t);else if(19===e.tag)cs(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}switch(X(Ma,r),a){case"forwards":for(n=t.child,a=null;null!==n;)null!==(e=n.alternate)&&null===Oa(e)&&(a=n),n=n.sibling;null===(n=a)?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),ls(t,!1,a,n,o);break;case"backwards":for(n=null,a=t.child,t.child=null;null!==a;){if(null!==(e=a.alternate)&&null===Oa(e)){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}ls(t,!0,n,null,o);break;case"together":ls(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function ds(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),hc|=t.lanes,0===(n&t.childLanes)){if(null===e)return null;if(ks(e,t,n,!1),0===(n&t.childLanes))return null}if(null!==e&&t.child!==e.child)throw Error(i(153));if(null!==t.child){for(n=Lu(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Lu(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function ps(e,t){return 0!==(e.lanes&t)||!(null===(e=e.dependencies)||!Cs(e))}function fs(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps)ji=!0;else{if(!ps(e,n)&&0===(128&t.flags))return ji=!1,function(e,t,n){switch(t.tag){case 3:$(t,t.stateNode.containerInfo),bs(t,Pa,e.memoizedState.cache),aa();break;case 27:case 5:te(t);break;case 4:$(t,t.stateNode.containerInfo);break;case 10:bs(t,t.type,t.memoizedProps.value);break;case 13:var r=t.memoizedState;if(null!==r)return null!==r.dehydrated?(Aa(t),t.flags|=128,null):0!==(n&t.child.childLanes)?os(e,t,n):(Aa(t),null!==(e=ds(e,t,n))?e.sibling:null);Aa(t);break;case 19:var a=0!==(128&e.flags);if((r=0!==(n&t.childLanes))||(ks(e,t,n,!1),r=0!==(n&t.childLanes)),a){if(r)return hs(e,t,n);t.flags|=128}if(null!==(a=t.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),X(Ma,Ma.current),r)break;return null;case 22:case 23:return t.lanes=0,Yi(e,t,n);case 24:bs(t,Pa,e.memoizedState.cache)}return ds(e,t,n)}(e,t,n);ji=0!==(131072&e.flags)}else ji=!1,Qr&&0!==(1048576&t.flags)&&Hr(t,Br,t.index);switch(t.lanes=0,t.tag){case 16:e:{e=t.pendingProps;var r=t.elementType,a=r._init;if(r=a(r._payload),t.type=r,"function"!==typeof r){if(void 0!==r&&null!==r){if((a=r.$$typeof)===y){t.tag=11,t=qi(null,t,r,e,n);break e}if(a===x){t.tag=14,t=Ki(null,t,r,e,n);break e}}throw t=I(r)||r,Error(i(306,t,""))}zu(r)?(e=Ri(r,e),t.tag=1,t=es(null,t,r,e,n)):(t.tag=0,t=Ji(null,t,r,e,n))}return t;case 0:return Ji(e,t,t.type,t.pendingProps,n);case 1:return es(e,t,r=t.type,a=Ri(r,t.pendingProps),n);case 3:e:{if($(t,t.stateNode.containerInfo),null===e)throw Error(i(387));var o=t.pendingProps;r=(a=t.memoizedState).element,As(e,t),Ls(t,o,null,n);var s=t.memoizedState;if(o=s.cache,bs(t,Pa,o),o!==a.cache&&ws(t,[Pa],n,!0),zs(),o=s.element,a.isDehydrated){if(a={element:o,isDehydrated:!1,cache:s.cache},t.updateQueue.baseState=a,t.memoizedState=a,256&t.flags){t=ts(e,t,o,n);break e}if(o!==r){oa(r=Mr(Error(i(424)),t)),t=ts(e,t,o,n);break e}for(Yr=sh(t.stateNode.containerInfo.firstChild),Xr=t,Qr=!0,Zr=null,Jr=!0,n=ka(t,null,o,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(aa(),o===r){t=ds(e,t,n);break e}Hi(e,t,o,n)}t=t.child}return t;case 26:return Zi(e,t),null===e?(n=gh(t.type,null,t.pendingProps,null))?t.memoizedState=n:Qr||(n=t.type,e=t.pendingProps,(r=Yl(Z.current).createElement(n))[Be]=t,r[Pe]=e,ql(r,n,e),Ze(r),t.stateNode=r):t.memoizedState=gh(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return te(t),null===e&&Qr&&(r=t.stateNode=ch(t.type,t.pendingProps,Z.current),Xr=t,Jr=!0,Yr=sh(r.firstChild)),r=t.pendingProps.children,null!==e||Qr?Hi(e,t,r,n):t.child=wa(t,null,r,n),Zi(e,t),t.child;case 5:return null===e&&Qr&&((a=r=Yr)&&(null!==(r=function(e,t,n,r){for(;1===e.nodeType;){var a=n;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!r&&("INPUT"!==e.nodeName||"hidden"!==e.type))break}else if(r){if(!e[He])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if("stylesheet"===(o=e.getAttribute("rel"))&&e.hasAttribute("data-precedence"))break;if(o!==a.rel||e.getAttribute("href")!==(null==a.href?null:a.href)||e.getAttribute("crossorigin")!==(null==a.crossOrigin?null:a.crossOrigin)||e.getAttribute("title")!==(null==a.title?null:a.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(((o=e.getAttribute("src"))!==(null==a.src?null:a.src)||e.getAttribute("type")!==(null==a.type?null:a.type)||e.getAttribute("crossorigin")!==(null==a.crossOrigin?null:a.crossOrigin))&&o&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else{if("input"!==t||"hidden"!==e.type)return e;var o=null==a.name?null:""+a.name;if("hidden"===a.type&&e.getAttribute("name")===o)return e}if(null===(e=sh(e.nextSibling)))break}return null}(r,t.type,t.pendingProps,Jr))?(t.stateNode=r,Xr=t,Yr=sh(r.firstChild),Jr=!1,a=!0):a=!1),a||ea(t)),te(t),a=t.type,o=t.pendingProps,s=null!==e?e.memoizedProps:null,r=o.children,Jl(a,o)?r=null:null!==s&&Jl(a,s)&&(t.flags|=32),null!==t.memoizedState&&(a=ho(e,t,mo,null,null,n),zh._currentValue=a),Zi(e,t),Hi(e,t,r,n),t.child;case 6:return null===e&&Qr&&((e=n=Yr)&&(null!==(n=function(e,t,n){if(""===t)return null;for(;3!==e.nodeType;){if((1!==e.nodeType||"INPUT"!==e.nodeName||"hidden"!==e.type)&&!n)return null;if(null===(e=sh(e.nextSibling)))return null}return e}(n,t.pendingProps,Jr))?(t.stateNode=n,Xr=t,Yr=null,e=!0):e=!1),e||ea(t)),null;case 13:return os(e,t,n);case 4:return $(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=wa(t,null,r,n):Hi(e,t,r,n),t.child;case 11:return qi(e,t,t.type,t.pendingProps,n);case 7:return Hi(e,t,t.pendingProps,n),t.child;case 8:case 12:return Hi(e,t,t.pendingProps.children,n),t.child;case 10:return r=t.pendingProps,bs(t,t.type,r.value),Hi(e,t,r.children,n),t.child;case 9:return a=t.type._context,r=t.pendingProps.children,Ds(t),r=r(a=Ss(a)),t.flags|=1,Hi(e,t,r,n),t.child;case 14:return Ki(e,t,t.type,t.pendingProps,n);case 15:return Xi(e,t,t.type,t.pendingProps,n);case 19:return hs(e,t,n);case 22:return Yi(e,t,n);case 24:return Ds(t),r=Ss(Pa),null===e?(null===(a=Ya())&&(a=tc,o=Wa(),a.pooledCache=o,o.refCount++,null!==o&&(a.pooledCacheLanes|=n),a=o),t.memoizedState={parent:r,cache:a},Ts(t),bs(t,Pa,a)):(0!==(e.lanes&n)&&(As(e,t),Ls(t,null,null,n),zs()),a=e.memoizedState,o=t.memoizedState,a.parent!==r?(a={parent:r,cache:r},t.memoizedState=a,0===t.lanes&&(t.memoizedState=t.updateQueue.baseState=a),bs(t,Pa,r)):(r=o.cache,bs(t,Pa,r),r!==a.cache&&ws(t,[Pa],n,!0))),Hi(e,t,t.pendingProps.children,n),t.child;case 29:throw t.pendingProps}throw Error(i(156,t.tag))}var ms=q(null),gs=null,ys=null;function bs(e,t,n){X(ms,t._currentValue),t._currentValue=n}function vs(e){e._currentValue=ms.current,K(ms)}function xs(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function ws(e,t,n,r){var a=e.child;for(null!==a&&(a.return=e);null!==a;){var o=a.dependencies;if(null!==o){var s=a.child;o=o.firstContext;e:for(;null!==o;){var u=o;o=a;for(var c=0;c<t.length;c++)if(u.context===t[c]){o.lanes|=n,null!==(u=o.alternate)&&(u.lanes|=n),xs(o.return,n,e),r||(s=null);break e}o=u.next}}else if(18===a.tag){if(null===(s=a.return))throw Error(i(341));s.lanes|=n,null!==(o=s.alternate)&&(o.lanes|=n),xs(s,n,e),s=null}else s=a.child;if(null!==s)s.return=a;else for(s=a;null!==s;){if(s===e){s=null;break}if(null!==(a=s.sibling)){a.return=s.return,s=a;break}s=s.return}a=s}}function ks(e,t,n,r){e=null;for(var a=t,o=!1;null!==a;){if(!o)if(0!==(524288&a.flags))o=!0;else if(0!==(262144&a.flags))break;if(10===a.tag){var s=a.alternate;if(null===s)throw Error(i(387));if(null!==(s=s.memoizedProps)){var u=a.type;Xn(a.pendingProps.value,s.value)||(null!==e?e.push(u):e=[u])}}else if(a===J.current){if(null===(s=a.alternate))throw Error(i(387));s.memoizedState.memoizedState!==a.memoizedState.memoizedState&&(null!==e?e.push(zh):e=[zh])}a=a.return}null!==e&&ws(t,e,n,r),t.flags|=262144}function Cs(e){for(e=e.firstContext;null!==e;){if(!Xn(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function Ds(e){gs=e,ys=null,null!==(e=e.dependencies)&&(e.firstContext=null)}function Ss(e){return Is(gs,e)}function Es(e,t){return null===gs&&Ds(e),Is(e,t)}function Is(e,t){var n=t._currentValue;if(t={context:t,memoizedValue:n,next:null},null===ys){if(null===e)throw Error(i(308));ys=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else ys=ys.next=t;return n}var Ns=!1;function Ts(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function As(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function Fs(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function _s(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&ec)){var a=r.pending;return null===a?t.next=t:(t.next=a.next,a.next=t),r.pending=t,t=Fr(e),Ar(e,null,n),t}return Ir(e,r,t,n),Fr(e)}function Rs(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194176&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Me(e,n)}}function Ms(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,o=null;if(null!==(n=n.firstBaseUpdate)){do{var i={lane:n.lane,tag:n.tag,payload:n.payload,callback:null,next:null};null===o?a=o=i:o=o.next=i,n=n.next}while(null!==n);null===o?a=o=t:o=o.next=t}else a=o=t;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:o,shared:r.shared,callbacks:r.callbacks},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}var Os=!1;function zs(){if(Os){if(null!==Ha)throw Ha}}function Ls(e,t,n,r){Os=!1;var a=e.updateQueue;Ns=!1;var o=a.firstBaseUpdate,i=a.lastBaseUpdate,s=a.shared.pending;if(null!==s){a.shared.pending=null;var u=s,c=u.next;u.next=null,null===i?o=c:i.next=c,i=u;var l=e.alternate;null!==l&&((s=(l=l.updateQueue).lastBaseUpdate)!==i&&(null===s?l.firstBaseUpdate=c:s.next=c,l.lastBaseUpdate=u))}if(null!==o){var h=a.baseState;for(i=0,l=c=u=null,s=o;;){var d=-536870913&s.lane,p=d!==s.lane;if(p?(rc&d)===d:(r&d)===d){0!==d&&d===ja&&(Os=!0),null!==l&&(l=l.next={lane:0,tag:s.tag,payload:s.payload,callback:null,next:null});e:{var f=e,m=s;d=t;var g=n;switch(m.tag){case 1:if("function"===typeof(f=m.payload)){h=f.call(g,h,d);break e}h=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(d="function"===typeof(f=m.payload)?f.call(g,h,d):f)||void 0===d)break e;h=F({},h,d);break e;case 2:Ns=!0}}null!==(d=s.callback)&&(e.flags|=64,p&&(e.flags|=8192),null===(p=a.callbacks)?a.callbacks=[d]:p.push(d))}else p={lane:d,tag:s.tag,payload:s.payload,callback:s.callback,next:null},null===l?(c=l=p,u=h):l=l.next=p,i|=d;if(null===(s=s.next)){if(null===(s=a.shared.pending))break;s=(p=s).next,p.next=null,a.lastBaseUpdate=p,a.shared.pending=null}}null===l&&(u=h),a.baseState=u,a.firstBaseUpdate=c,a.lastBaseUpdate=l,null===o&&(a.shared.lanes=0),hc|=i,e.lanes=i,e.memoizedState=h}}function Bs(e,t){if("function"!==typeof e)throw Error(i(191,e));e.call(t)}function Ps(e,t){var n=e.callbacks;if(null!==n)for(e.callbacks=null,e=0;e<n.length;e++)Bs(n[e],t)}function Ws(e,t){try{var n=t.updateQueue,r=null!==n?n.lastEffect:null;if(null!==r){var a=r.next;n=a;do{if((n.tag&e)===e){r=void 0;var o=n.create,i=n.inst;r=o(),i.destroy=r}n=n.next}while(n!==a)}}catch(s){rl(t,t.return,s)}}function Us(e,t,n){try{var r=t.updateQueue,a=null!==r?r.lastEffect:null;if(null!==a){var o=a.next;r=o;do{if((r.tag&e)===e){var i=r.inst,s=i.destroy;if(void 0!==s){i.destroy=void 0,a=t;var u=n;try{s()}catch(c){rl(a,u,c)}}}r=r.next}while(r!==o)}}catch(c){rl(t,t.return,c)}}function Vs(e){var t=e.updateQueue;if(null!==t){var n=e.stateNode;try{Ps(t,n)}catch(r){rl(e,e.return,r)}}}function Gs(e,t,n){n.props=Ri(e.type,e.memoizedProps),n.state=e.memoizedState;try{n.componentWillUnmount()}catch(r){rl(e,t,r)}}function js(e,t){try{var n=e.ref;if(null!==n){var r=e.stateNode;switch(e.tag){case 26:case 27:case 5:var a=r;break;default:a=r}"function"===typeof n?e.refCleanup=n(a):n.current=a}}catch(o){rl(e,t,o)}}function Hs(e,t){var n=e.ref,r=e.refCleanup;if(null!==n)if("function"===typeof r)try{r()}catch(a){rl(e,t,a)}finally{e.refCleanup=null,null!=(e=e.alternate)&&(e.refCleanup=null)}else if("function"===typeof n)try{n(null)}catch(o){rl(e,t,o)}else n.current=null}function qs(e){var t=e.type,n=e.memoizedProps,r=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":n.autoFocus&&r.focus();break e;case"img":n.src?r.src=n.src:n.srcSet&&(r.srcset=n.srcSet)}}catch(a){rl(e,e.return,a)}}function Ks(e,t,n){try{var r=e.stateNode;!function(e,t,n,r){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var a=null,o=null,s=null,u=null,c=null,l=null,h=null;for(f in n){var d=n[f];if(n.hasOwnProperty(f)&&null!=d)switch(f){case"checked":case"value":break;case"defaultValue":c=d;default:r.hasOwnProperty(f)||jl(e,t,f,null,r,d)}}for(var p in r){var f=r[p];if(d=n[p],r.hasOwnProperty(p)&&(null!=f||null!=d))switch(p){case"type":o=f;break;case"name":a=f;break;case"checked":l=f;break;case"defaultChecked":h=f;break;case"value":s=f;break;case"defaultValue":u=f;break;case"children":case"dangerouslySetInnerHTML":if(null!=f)throw Error(i(137,t));break;default:f!==d&&jl(e,t,p,f,r,d)}}return void gt(e,s,u,c,l,h,o,a);case"select":for(o in f=s=u=p=null,n)if(c=n[o],n.hasOwnProperty(o)&&null!=c)switch(o){case"value":break;case"multiple":f=c;default:r.hasOwnProperty(o)||jl(e,t,o,null,r,c)}for(a in r)if(o=r[a],c=n[a],r.hasOwnProperty(a)&&(null!=o||null!=c))switch(a){case"value":p=o;break;case"defaultValue":u=o;break;case"multiple":s=o;default:o!==c&&jl(e,t,a,o,r,c)}return t=u,n=s,r=f,void(null!=p?vt(e,!!n,p,!1):!!r!==!!n&&(null!=t?vt(e,!!n,t,!0):vt(e,!!n,n?[]:"",!1)));case"textarea":for(u in f=p=null,n)if(a=n[u],n.hasOwnProperty(u)&&null!=a&&!r.hasOwnProperty(u))switch(u){case"value":case"children":break;default:jl(e,t,u,null,r,a)}for(s in r)if(a=r[s],o=n[s],r.hasOwnProperty(s)&&(null!=a||null!=o))switch(s){case"value":p=a;break;case"defaultValue":f=a;break;case"children":break;case"dangerouslySetInnerHTML":if(null!=a)throw Error(i(91));break;default:a!==o&&jl(e,t,s,a,r,o)}return void xt(e,p,f);case"option":for(var m in n)if(p=n[m],n.hasOwnProperty(m)&&null!=p&&!r.hasOwnProperty(m))if("selected"===m)e.selected=!1;else jl(e,t,m,null,r,p);for(c in r)if(p=r[c],f=n[c],r.hasOwnProperty(c)&&p!==f&&(null!=p||null!=f))if("selected"===c)e.selected=p&&"function"!==typeof p&&"symbol"!==typeof p;else jl(e,t,c,p,r,f);return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var g in n)p=n[g],n.hasOwnProperty(g)&&null!=p&&!r.hasOwnProperty(g)&&jl(e,t,g,null,r,p);for(l in r)if(p=r[l],f=n[l],r.hasOwnProperty(l)&&p!==f&&(null!=p||null!=f))switch(l){case"children":case"dangerouslySetInnerHTML":if(null!=p)throw Error(i(137,t));break;default:jl(e,t,l,p,r,f)}return;default:if(Et(t)){for(var y in n)p=n[y],n.hasOwnProperty(y)&&void 0!==p&&!r.hasOwnProperty(y)&&Hl(e,t,y,void 0,r,p);for(h in r)p=r[h],f=n[h],!r.hasOwnProperty(h)||p===f||void 0===p&&void 0===f||Hl(e,t,h,p,r,f);return}}for(var b in n)p=n[b],n.hasOwnProperty(b)&&null!=p&&!r.hasOwnProperty(b)&&jl(e,t,b,null,r,p);for(d in r)p=r[d],f=n[d],!r.hasOwnProperty(d)||p===f||null==p&&null==f||jl(e,t,d,p,r,f)}(r,e.type,n,t),r[Pe]=t}catch(a){rl(e,e.return,a)}}function Xs(e){return 5===e.tag||3===e.tag||26===e.tag||27===e.tag||4===e.tag}function Ys(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||Xs(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&27!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function Qs(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Gl));else if(4!==r&&27!==r&&null!==(e=e.child))for(Qs(e,t,n),e=e.sibling;null!==e;)Qs(e,t,n),e=e.sibling}function Zs(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&27!==r&&null!==(e=e.child))for(Zs(e,t,n),e=e.sibling;null!==e;)Zs(e,t,n),e=e.sibling}var Js=!1,$s=!1,eu=!1,tu="function"===typeof WeakSet?WeakSet:Set,nu=null,ru=!1;function au(e,t,n){var r=n.flags;switch(n.tag){case 0:case 11:case 15:yu(e,n),4&r&&Ws(5,n);break;case 1:if(yu(e,n),4&r)if(e=n.stateNode,null===t)try{e.componentDidMount()}catch(s){rl(n,n.return,s)}else{var a=Ri(n.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(a,t,e.__reactInternalSnapshotBeforeUpdate)}catch(u){rl(n,n.return,u)}}64&r&&Vs(n),512&r&&js(n,n.return);break;case 3:if(yu(e,n),64&r&&null!==(r=n.updateQueue)){if(e=null,null!==n.child)switch(n.child.tag){case 27:case 5:case 1:e=n.child.stateNode}try{Ps(r,e)}catch(s){rl(n,n.return,s)}}break;case 26:yu(e,n),512&r&&js(n,n.return);break;case 27:case 5:yu(e,n),null===t&&4&r&&qs(n),512&r&&js(n,n.return);break;case 12:default:yu(e,n);break;case 13:yu(e,n),4&r&&lu(e,n);break;case 22:if(!(a=null!==n.memoizedState||Js)){t=null!==t&&null!==t.memoizedState||$s;var o=Js,i=$s;Js=a,($s=t)&&!i?vu(e,n,0!==(8772&n.subtreeFlags)):yu(e,n),Js=o,$s=i}512&r&&("manual"===n.memoizedProps.mode?js(n,n.return):Hs(n,n.return))}}function ou(e){var t=e.alternate;null!==t&&(e.alternate=null,ou(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&qe(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var iu=null,su=!1;function uu(e,t,n){for(n=n.child;null!==n;)cu(e,t,n),n=n.sibling}function cu(e,t,n){if(be&&"function"===typeof be.onCommitFiberUnmount)try{be.onCommitFiberUnmount(ye,n)}catch(i){}switch(n.tag){case 26:$s||Hs(n,t),uu(e,t,n),n.memoizedState?n.memoizedState.count--:n.stateNode&&(n=n.stateNode).parentNode.removeChild(n);break;case 27:$s||Hs(n,t);var r=iu,a=su;for(iu=n.stateNode,uu(e,t,n),t=(n=n.stateNode).attributes;t.length;)n.removeAttributeNode(t[0]);qe(n),iu=r,su=a;break;case 5:$s||Hs(n,t);case 6:a=iu;var o=su;if(iu=null,uu(e,t,n),su=o,null!==(iu=a))if(su)try{e=iu,r=n.stateNode,8===e.nodeType?e.parentNode.removeChild(r):e.removeChild(r)}catch(s){rl(n,t,s)}else try{iu.removeChild(n.stateNode)}catch(s){rl(n,t,s)}break;case 18:null!==iu&&(su?(t=iu,n=n.stateNode,8===t.nodeType?oh(t.parentNode,n):1===t.nodeType&&oh(t,n),md(t)):oh(iu,n.stateNode));break;case 4:r=iu,a=su,iu=n.stateNode.containerInfo,su=!0,uu(e,t,n),iu=r,su=a;break;case 0:case 11:case 14:case 15:$s||Us(2,n,t),$s||Us(4,n,t),uu(e,t,n);break;case 1:$s||(Hs(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount&&Gs(n,t,r)),uu(e,t,n);break;case 21:uu(e,t,n);break;case 22:$s||Hs(n,t),$s=(r=$s)||null!==n.memoizedState,uu(e,t,n),$s=r;break;default:uu(e,t,n)}}function lu(e,t){if(null===t.memoizedState&&(null!==(e=t.alternate)&&(null!==(e=e.memoizedState)&&null!==(e=e.dehydrated))))try{md(e)}catch(n){rl(t,t.return,n)}}function hu(e,t){var n=function(e){switch(e.tag){case 13:case 19:var t=e.stateNode;return null===t&&(t=e.stateNode=new tu),t;case 22:return null===(t=(e=e.stateNode)._retryCache)&&(t=e._retryCache=new tu),t;default:throw Error(i(435,e.tag))}}(e);t.forEach((function(t){var r=ul.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}function du(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r],o=e,s=t,u=s;e:for(;null!==u;){switch(u.tag){case 27:case 5:iu=u.stateNode,su=!1;break e;case 3:case 4:iu=u.stateNode.containerInfo,su=!0;break e}u=u.return}if(null===iu)throw Error(i(160));cu(o,s,a),iu=null,su=!1,null!==(o=a.alternate)&&(o.return=null),a.return=null}if(13878&t.subtreeFlags)for(t=t.child;null!==t;)fu(t,e),t=t.sibling}var pu=null;function fu(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:du(t,e),mu(e),4&r&&(Us(3,e,e.return),Ws(3,e),Us(5,e,e.return));break;case 1:du(t,e),mu(e),512&r&&($s||null===n||Hs(n,n.return)),64&r&&Js&&(null!==(e=e.updateQueue)&&(null!==(r=e.callbacks)&&(n=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=null===n?r:n.concat(r))));break;case 26:var a=pu;if(du(t,e),mu(e),512&r&&($s||null===n||Hs(n,n.return)),4&r){var o=null!==n?n.memoizedState:null;if(r=e.memoizedState,null===n)if(null===r)if(null===e.stateNode){e:{r=e.type,n=e.memoizedProps,a=a.ownerDocument||a;t:switch(r){case"title":(!(o=a.getElementsByTagName("title")[0])||o[He]||o[Be]||"http://www.w3.org/2000/svg"===o.namespaceURI||o.hasAttribute("itemprop"))&&(o=a.createElement(r),a.head.insertBefore(o,a.querySelector("head > title"))),ql(o,r,n),o[Be]=e,Ze(o),r=o;break e;case"link":var s=Ih("link","href",a).get(r+(n.href||""));if(s)for(var u=0;u<s.length;u++)if((o=s[u]).getAttribute("href")===(null==n.href?null:n.href)&&o.getAttribute("rel")===(null==n.rel?null:n.rel)&&o.getAttribute("title")===(null==n.title?null:n.title)&&o.getAttribute("crossorigin")===(null==n.crossOrigin?null:n.crossOrigin)){s.splice(u,1);break t}ql(o=a.createElement(r),r,n),a.head.appendChild(o);break;case"meta":if(s=Ih("meta","content",a).get(r+(n.content||"")))for(u=0;u<s.length;u++)if((o=s[u]).getAttribute("content")===(null==n.content?null:""+n.content)&&o.getAttribute("name")===(null==n.name?null:n.name)&&o.getAttribute("property")===(null==n.property?null:n.property)&&o.getAttribute("http-equiv")===(null==n.httpEquiv?null:n.httpEquiv)&&o.getAttribute("charset")===(null==n.charSet?null:n.charSet)){s.splice(u,1);break t}ql(o=a.createElement(r),r,n),a.head.appendChild(o);break;default:throw Error(i(468,r))}o[Be]=e,Ze(o),r=o}e.stateNode=r}else Nh(a,e.type,e.stateNode);else e.stateNode=kh(a,r,e.memoizedProps);else o!==r?(null===o?null!==n.stateNode&&(n=n.stateNode).parentNode.removeChild(n):o.count--,null===r?Nh(a,e.type,e.stateNode):kh(a,r,e.memoizedProps)):null===r&&null!==e.stateNode&&Ks(e,e.memoizedProps,n.memoizedProps)}break;case 27:if(4&r&&null===e.alternate){a=e.stateNode,o=e.memoizedProps;try{for(var c=a.firstChild;c;){var l=c.nextSibling,h=c.nodeName;c[He]||"HEAD"===h||"BODY"===h||"SCRIPT"===h||"STYLE"===h||"LINK"===h&&"stylesheet"===c.rel.toLowerCase()||a.removeChild(c),c=l}for(var d=e.type,p=a.attributes;p.length;)a.removeAttributeNode(p[0]);ql(a,d,o),a[Be]=e,a[Pe]=o}catch(m){rl(e,e.return,m)}}case 5:if(du(t,e),mu(e),512&r&&($s||null===n||Hs(n,n.return)),32&e.flags){a=e.stateNode;try{kt(a,"")}catch(m){rl(e,e.return,m)}}4&r&&null!=e.stateNode&&Ks(e,a=e.memoizedProps,null!==n?n.memoizedProps:a),1024&r&&(eu=!0);break;case 6:if(du(t,e),mu(e),4&r){if(null===e.stateNode)throw Error(i(162));r=e.memoizedProps,n=e.stateNode;try{n.nodeValue=r}catch(m){rl(e,e.return,m)}}break;case 3:if(Eh=null,a=pu,pu=dh(t.containerInfo),du(t,e),pu=a,mu(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{md(t.containerInfo)}catch(m){rl(e,e.return,m)}eu&&(eu=!1,gu(e));break;case 4:r=pu,pu=dh(e.stateNode.containerInfo),du(t,e),mu(e),pu=r;break;case 12:du(t,e),mu(e);break;case 13:du(t,e),mu(e),8192&e.child.flags&&null!==e.memoizedState!==(null!==n&&null!==n.memoizedState)&&(vc=ue()),4&r&&(null!==(r=e.updateQueue)&&(e.updateQueue=null,hu(e,r)));break;case 22:if(512&r&&($s||null===n||Hs(n,n.return)),c=null!==e.memoizedState,l=null!==n&&null!==n.memoizedState,Js=(h=Js)||c,$s=(d=$s)||l,du(t,e),$s=d,Js=h,mu(e),(t=e.stateNode)._current=e,t._visibility&=-3,t._visibility|=2&t._pendingVisibility,8192&r&&(t._visibility=c?-2&t._visibility:1|t._visibility,c&&(t=Js||$s,null===n||l||t||bu(e)),null===e.memoizedProps||"manual"!==e.memoizedProps.mode))e:for(n=null,t=e;;){if(5===t.tag||26===t.tag||27===t.tag){if(null===n){l=n=t;try{if(a=l.stateNode,c)"function"===typeof(o=a.style).setProperty?o.setProperty("display","none","important"):o.display="none";else{s=l.stateNode;var f=void 0!==(u=l.memoizedProps.style)&&null!==u&&u.hasOwnProperty("display")?u.display:null;s.style.display=null==f||"boolean"===typeof f?"":(""+f).trim()}}catch(m){rl(l,l.return,m)}}}else if(6===t.tag){if(null===n){l=t;try{l.stateNode.nodeValue=c?"":l.memoizedProps}catch(m){rl(l,l.return,m)}}}else if((22!==t.tag&&23!==t.tag||null===t.memoizedState||t===e)&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;null===t.sibling;){if(null===t.return||t.return===e)break e;n===t&&(n=null),t=t.return}n===t&&(n=null),t.sibling.return=t.return,t=t.sibling}4&r&&(null!==(r=e.updateQueue)&&(null!==(n=r.retryQueue)&&(r.retryQueue=null,hu(e,n))));break;case 19:du(t,e),mu(e),4&r&&(null!==(r=e.updateQueue)&&(e.updateQueue=null,hu(e,r)));break;case 21:break;default:du(t,e),mu(e)}}function mu(e){var t=e.flags;if(2&t){try{if(27!==e.tag){e:{for(var n=e.return;null!==n;){if(Xs(n)){var r=n;break e}n=n.return}throw Error(i(160))}switch(r.tag){case 27:var a=r.stateNode;Zs(e,Ys(e),a);break;case 5:var o=r.stateNode;32&r.flags&&(kt(o,""),r.flags&=-33),Zs(e,Ys(e),o);break;case 3:case 4:var s=r.stateNode.containerInfo;Qs(e,Ys(e),s);break;default:throw Error(i(161))}}}catch(u){rl(e,e.return,u)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function gu(e){if(1024&e.subtreeFlags)for(e=e.child;null!==e;){var t=e;gu(t),5===t.tag&&1024&t.flags&&t.stateNode.reset(),e=e.sibling}}function yu(e,t){if(8772&t.subtreeFlags)for(t=t.child;null!==t;)au(e,t.alternate,t),t=t.sibling}function bu(e){for(e=e.child;null!==e;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:Us(4,t,t.return),bu(t);break;case 1:Hs(t,t.return);var n=t.stateNode;"function"===typeof n.componentWillUnmount&&Gs(t,t.return,n),bu(t);break;case 26:case 27:case 5:Hs(t,t.return),bu(t);break;case 22:Hs(t,t.return),null===t.memoizedState&&bu(t);break;default:bu(t)}e=e.sibling}}function vu(e,t,n){for(n=n&&0!==(8772&t.subtreeFlags),t=t.child;null!==t;){var r=t.alternate,a=e,o=t,i=o.flags;switch(o.tag){case 0:case 11:case 15:vu(a,o,n),Ws(4,o);break;case 1:if(vu(a,o,n),"function"===typeof(a=(r=o).stateNode).componentDidMount)try{a.componentDidMount()}catch(c){rl(r,r.return,c)}if(null!==(a=(r=o).updateQueue)){var s=r.stateNode;try{var u=a.shared.hiddenCallbacks;if(null!==u)for(a.shared.hiddenCallbacks=null,a=0;a<u.length;a++)Bs(u[a],s)}catch(c){rl(r,r.return,c)}}n&&64&i&&Vs(o),js(o,o.return);break;case 26:case 27:case 5:vu(a,o,n),n&&null===r&&4&i&&qs(o),js(o,o.return);break;case 12:default:vu(a,o,n);break;case 13:vu(a,o,n),n&&4&i&&lu(a,o);break;case 22:null===o.memoizedState&&vu(a,o,n),js(o,o.return)}t=t.sibling}}function xu(e,t){var n=null;null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),e=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(e=t.memoizedState.cachePool.pool),e!==n&&(null!=e&&e.refCount++,null!=n&&Ua(n))}function wu(e,t){e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Ua(e))}function ku(e,t,n,r){if(10256&t.subtreeFlags)for(t=t.child;null!==t;)Cu(e,t,n,r),t=t.sibling}function Cu(e,t,n,r){var a=t.flags;switch(t.tag){case 0:case 11:case 15:ku(e,t,n,r),2048&a&&Ws(9,t);break;case 3:ku(e,t,n,r),2048&a&&(e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Ua(e)));break;case 12:if(2048&a){ku(e,t,n,r),e=t.stateNode;try{var o=t.memoizedProps,i=o.id,s=o.onPostCommit;"function"===typeof s&&s(i,null===t.alternate?"mount":"update",e.passiveEffectDuration,-0)}catch(u){rl(t,t.return,u)}}else ku(e,t,n,r);break;case 23:break;case 22:o=t.stateNode,null!==t.memoizedState?4&o._visibility?ku(e,t,n,r):Su(e,t):4&o._visibility?ku(e,t,n,r):(o._visibility|=4,Du(e,t,n,r,0!==(10256&t.subtreeFlags))),2048&a&&xu(t.alternate,t);break;case 24:ku(e,t,n,r),2048&a&&wu(t.alternate,t);break;default:ku(e,t,n,r)}}function Du(e,t,n,r,a){for(a=a&&0!==(10256&t.subtreeFlags),t=t.child;null!==t;){var o=e,i=t,s=n,u=r,c=i.flags;switch(i.tag){case 0:case 11:case 15:Du(o,i,s,u,a),Ws(8,i);break;case 23:break;case 22:var l=i.stateNode;null!==i.memoizedState?4&l._visibility?Du(o,i,s,u,a):Su(o,i):(l._visibility|=4,Du(o,i,s,u,a)),a&&2048&c&&xu(i.alternate,i);break;case 24:Du(o,i,s,u,a),a&&2048&c&&wu(i.alternate,i);break;default:Du(o,i,s,u,a)}t=t.sibling}}function Su(e,t){if(10256&t.subtreeFlags)for(t=t.child;null!==t;){var n=e,r=t,a=r.flags;switch(r.tag){case 22:Su(n,r),2048&a&&xu(r.alternate,r);break;case 24:Su(n,r),2048&a&&wu(r.alternate,r);break;default:Su(n,r)}t=t.sibling}}var Eu=8192;function Iu(e){if(e.subtreeFlags&Eu)for(e=e.child;null!==e;)Nu(e),e=e.sibling}function Nu(e){switch(e.tag){case 26:Iu(e),e.flags&Eu&&null!==e.memoizedState&&function(e,t,n){if(null===Ah)throw Error(i(475));var r=Ah;if("stylesheet"===t.type&&("string"!==typeof n.media||!1!==matchMedia(n.media).matches)&&0===(4&t.state.loading)){if(null===t.instance){var a=yh(n.href),o=e.querySelector(bh(a));if(o)return null!==(e=o._p)&&"object"===typeof e&&"function"===typeof e.then&&(r.count++,r=_h.bind(r),e.then(r,r)),t.state.loading|=4,t.instance=o,void Ze(o);o=e.ownerDocument||e,n=vh(n),(a=lh.get(a))&&Dh(n,a),Ze(o=o.createElement("link"));var s=o;s._p=new Promise((function(e,t){s.onload=e,s.onerror=t})),ql(o,"link",n),t.instance=o}null===r.stylesheets&&(r.stylesheets=new Map),r.stylesheets.set(t,e),(e=t.state.preload)&&0===(3&t.state.loading)&&(r.count++,t=_h.bind(r),e.addEventListener("load",t),e.addEventListener("error",t))}}(pu,e.memoizedState,e.memoizedProps);break;case 5:default:Iu(e);break;case 3:case 4:var t=pu;pu=dh(e.stateNode.containerInfo),Iu(e),pu=t;break;case 22:null===e.memoizedState&&(null!==(t=e.alternate)&&null!==t.memoizedState?(t=Eu,Eu=16777216,Iu(e),Eu=t):Iu(e))}}function Tu(e){var t=e.alternate;if(null!==t&&null!==(e=t.child)){t.child=null;do{t=e.sibling,e.sibling=null,e=t}while(null!==e)}}function Au(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];nu=r,Ru(r,e)}Tu(e)}if(10256&e.subtreeFlags)for(e=e.child;null!==e;)Fu(e),e=e.sibling}function Fu(e){switch(e.tag){case 0:case 11:case 15:Au(e),2048&e.flags&&Us(9,e,e.return);break;case 3:case 12:default:Au(e);break;case 22:var t=e.stateNode;null!==e.memoizedState&&4&t._visibility&&(null===e.return||13!==e.return.tag)?(t._visibility&=-5,_u(e)):Au(e)}}function _u(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];nu=r,Ru(r,e)}Tu(e)}for(e=e.child;null!==e;){switch((t=e).tag){case 0:case 11:case 15:Us(8,t,t.return),_u(t);break;case 22:4&(n=t.stateNode)._visibility&&(n._visibility&=-5,_u(t));break;default:_u(t)}e=e.sibling}}function Ru(e,t){for(;null!==nu;){var n=nu;switch(n.tag){case 0:case 11:case 15:Us(8,n,t);break;case 23:case 22:if(null!==n.memoizedState&&null!==n.memoizedState.cachePool){var r=n.memoizedState.cachePool.pool;null!=r&&r.refCount++}break;case 24:Ua(n.memoizedState.cache)}if(null!==(r=n.child))r.return=n,nu=r;else e:for(n=e;null!==nu;){var a=(r=nu).sibling,o=r.return;if(ou(r),r===n){nu=null;break e}if(null!==a){a.return=o,nu=a;break e}nu=o}}}function Mu(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ou(e,t,n,r){return new Mu(e,t,n,r)}function zu(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Lu(e,t){var n=e.alternate;return null===n?((n=Ou(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=31457280&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n.refCleanup=e.refCleanup,n}function Bu(e,t){e.flags&=31457282;var n=e.alternate;return null===n?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=n.childLanes,e.lanes=n.lanes,e.child=n.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=n.memoizedProps,e.memoizedState=n.memoizedState,e.updateQueue=n.updateQueue,e.type=n.type,t=n.dependencies,e.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function Pu(e,t,n,r,a,o){var s=0;if(r=e,"function"===typeof e)zu(e)&&(s=1);else if("string"===typeof e)s=function(e,t,n){if(1===n||null!=t.itemProp)return!1;switch(e){case"meta":case"title":return!0;case"style":if("string"!==typeof t.precedence||"string"!==typeof t.href||""===t.href)break;return!0;case"link":if("string"!==typeof t.rel||"string"!==typeof t.href||""===t.href||t.onLoad||t.onError)break;return"stylesheet"!==t.rel||(e=t.disabled,"string"===typeof t.precedence&&null==e);case"script":if(t.async&&"function"!==typeof t.async&&"symbol"!==typeof t.async&&!t.onLoad&&!t.onError&&t.src&&"string"===typeof t.src)return!0}return!1}(e,n,Y.current)?26:"html"===e||"head"===e||"body"===e?27:5;else e:switch(e){case h:return Wu(n.children,a,o,t);case d:s=8,a|=24;break;case p:return(e=Ou(12,n,t,2|a)).elementType=p,e.lanes=o,e;case b:return(e=Ou(13,n,t,a)).elementType=b,e.lanes=o,e;case v:return(e=Ou(19,n,t,a)).elementType=v,e.lanes=o,e;case k:return Uu(n,a,o,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case f:case g:s=10;break e;case m:s=9;break e;case y:s=11;break e;case x:s=14;break e;case w:s=16,r=null;break e}s=29,n=Error(i(130,null===e?"null":typeof e,"")),r=null}return(t=Ou(s,n,t,a)).elementType=e,t.type=r,t.lanes=o,t}function Wu(e,t,n,r){return(e=Ou(7,e,r,t)).lanes=n,e}function Uu(e,t,n,r){(e=Ou(22,e,r,t)).elementType=k,e.lanes=n;var a={_visibility:1,_pendingVisibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null,_current:null,detach:function(){var e=a._current;if(null===e)throw Error(i(456));if(0===(2&a._pendingVisibility)){var t=Tr(e,2);null!==t&&(a._pendingVisibility|=2,_c(t,e,2))}},attach:function(){var e=a._current;if(null===e)throw Error(i(456));if(0!==(2&a._pendingVisibility)){var t=Tr(e,2);null!==t&&(a._pendingVisibility&=-3,_c(t,e,2))}}};return e.stateNode=a,e}function Vu(e,t,n){return(e=Ou(6,e,null,t)).lanes=n,e}function Gu(e,t,n){return(t=Ou(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function ju(e){e.flags|=4}function Hu(e,t){if("stylesheet"!==t.type||0!==(4&t.state.loading))e.flags&=-16777217;else if(e.flags|=16777216,!Th(t)){if(null!==(t=Na.current)&&((4194176&rc)===rc?null!==Ta:(62914560&rc)!==rc&&0===(536870912&rc)||t!==Ta))throw da=ua,sa;e.flags|=8192}}function qu(e,t){null!==t&&(e.flags|=4),16384&e.flags&&(t=22!==e.tag?Ae():536870912,e.lanes|=t,mc|=t)}function Ku(e,t){if(!Qr)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Xu(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=31457280&a.subtreeFlags,r|=31457280&a.flags,a.return=e,a=a.sibling;else for(a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function Yu(e,t,n){var r=t.pendingProps;switch(Kr(t),t.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:case 1:return Xu(t),null;case 3:return n=t.stateNode,r=null,null!==e&&(r=e.memoizedState.cache),t.memoizedState.cache!==r&&(t.flags|=2048),vs(Pa),ee(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),null!==e&&null!==e.child||(ra(t)?ju(t):null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==Zr&&(Mc(Zr),Zr=null))),Xu(t),null;case 26:return n=t.memoizedState,null===e?(ju(t),null!==n?(Xu(t),Hu(t,n)):(Xu(t),t.flags&=-16777217)):n?n!==e.memoizedState?(ju(t),Xu(t),Hu(t,n)):(Xu(t),t.flags&=-16777217):(e.memoizedProps!==r&&ju(t),Xu(t),t.flags&=-16777217),null;case 27:ne(t),n=Z.current;var a=t.type;if(null!==e&&null!=t.stateNode)e.memoizedProps!==r&&ju(t);else{if(!r){if(null===t.stateNode)throw Error(i(166));return Xu(t),null}e=Y.current,ra(t)?ta(t):(e=ch(a,r,n),t.stateNode=e,ju(t))}return Xu(t),null;case 5:if(ne(t),n=t.type,null!==e&&null!=t.stateNode)e.memoizedProps!==r&&ju(t);else{if(!r){if(null===t.stateNode)throw Error(i(166));return Xu(t),null}if(e=Y.current,ra(t))ta(t);else{switch(a=Yl(Z.current),e){case 1:e=a.createElementNS("http://www.w3.org/2000/svg",n);break;case 2:e=a.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;default:switch(n){case"svg":e=a.createElementNS("http://www.w3.org/2000/svg",n);break;case"math":e=a.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;case"script":(e=a.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild);break;case"select":e="string"===typeof r.is?a.createElement("select",{is:r.is}):a.createElement("select"),r.multiple?e.multiple=!0:r.size&&(e.size=r.size);break;default:e="string"===typeof r.is?a.createElement(n,{is:r.is}):a.createElement(n)}}e[Be]=t,e[Pe]=r;e:for(a=t.child;null!==a;){if(5===a.tag||6===a.tag)e.appendChild(a.stateNode);else if(4!==a.tag&&27!==a.tag&&null!==a.child){a.child.return=a,a=a.child;continue}if(a===t)break e;for(;null===a.sibling;){if(null===a.return||a.return===t)break e;a=a.return}a.sibling.return=a.return,a=a.sibling}t.stateNode=e;e:switch(ql(e,n,r),n){case"button":case"input":case"select":case"textarea":e=!!r.autoFocus;break e;case"img":e=!0;break e;default:e=!1}e&&ju(t)}}return Xu(t),t.flags&=-16777217,null;case 6:if(e&&null!=t.stateNode)e.memoizedProps!==r&&ju(t);else{if("string"!==typeof r&&null===t.stateNode)throw Error(i(166));if(e=Z.current,ra(t)){if(e=t.stateNode,n=t.memoizedProps,r=null,null!==(a=Xr))switch(a.tag){case 27:case 5:r=a.memoizedProps}e[Be]=t,(e=!!(e.nodeValue===n||null!==r&&!0===r.suppressHydrationWarning||Vl(e.nodeValue,n)))||ea(t)}else(e=Yl(e).createTextNode(r))[Be]=t,t.stateNode=e}return Xu(t),null;case 13:if(r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(a=ra(t),null!==r&&null!==r.dehydrated){if(null===e){if(!a)throw Error(i(318));if(!(a=null!==(a=t.memoizedState)?a.dehydrated:null))throw Error(i(317));a[Be]=t}else aa(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Xu(t),a=!1}else null!==Zr&&(Mc(Zr),Zr=null),a=!0;if(!a)return 256&t.flags?(Ra(t),t):(Ra(t),null)}if(Ra(t),0!==(128&t.flags))return t.lanes=n,t;if(n=null!==r,e=null!==e&&null!==e.memoizedState,n){a=null,null!==(r=t.child).alternate&&null!==r.alternate.memoizedState&&null!==r.alternate.memoizedState.cachePool&&(a=r.alternate.memoizedState.cachePool.pool);var o=null;null!==r.memoizedState&&null!==r.memoizedState.cachePool&&(o=r.memoizedState.cachePool.pool),o!==a&&(r.flags|=2048)}return n!==e&&n&&(t.child.flags|=8192),qu(t,t.updateQueue),Xu(t),null;case 4:return ee(),null===e&&_l(t.stateNode.containerInfo),Xu(t),null;case 10:return vs(t.type),Xu(t),null;case 19:if(K(Ma),null===(a=t.memoizedState))return Xu(t),null;if(r=0!==(128&t.flags),null===(o=a.rendering))if(r)Ku(a,!1);else{if(0!==lc||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(o=Oa(e))){for(t.flags|=128,Ku(a,!1),e=o.updateQueue,t.updateQueue=e,qu(t,e),t.subtreeFlags=0,e=n,n=t.child;null!==n;)Bu(n,e),n=n.sibling;return X(Ma,1&Ma.current|2),t.child}e=e.sibling}null!==a.tail&&ue()>xc&&(t.flags|=128,r=!0,Ku(a,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=Oa(o))){if(t.flags|=128,r=!0,e=e.updateQueue,t.updateQueue=e,qu(t,e),Ku(a,!0),null===a.tail&&"hidden"===a.tailMode&&!o.alternate&&!Qr)return Xu(t),null}else 2*ue()-a.renderingStartTime>xc&&536870912!==n&&(t.flags|=128,r=!0,Ku(a,!1),t.lanes=4194304);a.isBackwards?(o.sibling=t.child,t.child=o):(null!==(e=a.last)?e.sibling=o:t.child=o,a.last=o)}return null!==a.tail?(t=a.tail,a.rendering=t,a.tail=t.sibling,a.renderingStartTime=ue(),t.sibling=null,e=Ma.current,X(Ma,r?1&e|2:1&e),t):(Xu(t),null);case 22:case 23:return Ra(t),Ia(),r=null!==t.memoizedState,null!==e?null!==e.memoizedState!==r&&(t.flags|=8192):r&&(t.flags|=8192),r?0!==(536870912&n)&&0===(128&t.flags)&&(Xu(t),6&t.subtreeFlags&&(t.flags|=8192)):Xu(t),null!==(n=t.updateQueue)&&qu(t,n.retryQueue),n=null,null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),r=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(r=t.memoizedState.cachePool.pool),r!==n&&(t.flags|=2048),null!==e&&K(Xa),null;case 24:return n=null,null!==e&&(n=e.memoizedState.cache),t.memoizedState.cache!==n&&(t.flags|=2048),vs(Pa),Xu(t),null;case 25:return null}throw Error(i(156,t.tag))}function Qu(e,t){switch(Kr(t),t.tag){case 1:return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return vs(Pa),ee(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 26:case 27:case 5:return ne(t),null;case 13:if(Ra(t),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(i(340));aa()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return K(Ma),null;case 4:return ee(),null;case 10:return vs(t.type),null;case 22:case 23:return Ra(t),Ia(),null!==e&&K(Xa),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 24:return vs(Pa),null;default:return null}}function Zu(e,t){switch(Kr(t),t.tag){case 3:vs(Pa),ee();break;case 26:case 27:case 5:ne(t);break;case 4:ee();break;case 13:Ra(t);break;case 19:K(Ma);break;case 10:vs(t.type);break;case 22:case 23:Ra(t),Ia(),null!==e&&K(Xa);break;case 24:vs(Pa)}}var Ju={getCacheForType:function(e){var t=Ss(Pa),n=t.data.get(e);return void 0===n&&(n=e(),t.data.set(e,n)),n}},$u="function"===typeof WeakMap?WeakMap:Map,ec=0,tc=null,nc=null,rc=0,ac=0,oc=null,ic=!1,sc=!1,uc=!1,cc=0,lc=0,hc=0,dc=0,pc=0,fc=0,mc=0,gc=null,yc=null,bc=!1,vc=0,xc=1/0,wc=null,kc=null,Cc=!1,Dc=null,Sc=0,Ec=0,Ic=null,Nc=0,Tc=null;function Ac(){if(0!==(2&ec)&&0!==rc)return rc&-rc;if(null!==A.T){return 0!==ja?ja:wl()}return ze()}function Fc(){0===fc&&(fc=0===(536870912&rc)||Qr?Te():536870912);var e=Na.current;return null!==e&&(e.flags|=32),fc}function _c(e,t,n){(e===tc&&2===ac||null!==e.cancelPendingCommit)&&(Wc(e,0),Lc(e,rc,fc,!1)),_e(e,n),0!==(2&ec)&&e===tc||(e===tc&&(0===(2&ec)&&(dc|=n),4===lc&&Lc(e,rc,fc,!1)),ml(e))}function Rc(e,t,n){if(0!==(6&ec))throw Error(i(327));for(var r=!n&&0===(60&t)&&0===(t&e.expiredLanes)||Ie(e,t),a=r?function(e,t){var n=ec;ec|=2;var r=Vc(),a=Gc();tc!==e||rc!==t?(wc=null,xc=ue()+500,Wc(e,t)):sc=Ie(e,t);e:for(;;)try{if(0!==ac&&null!==nc){t=nc;var o=oc;t:switch(ac){case 1:ac=0,oc=null,Qc(e,t,o,1);break;case 2:if(ca(o)){ac=0,oc=null,Yc(t);break}t=function(){2===ac&&tc===e&&(ac=7),ml(e)},o.then(t,t);break e;case 3:ac=7;break e;case 4:ac=5;break e;case 7:ca(o)?(ac=0,oc=null,Yc(t)):(ac=0,oc=null,Qc(e,t,o,7));break;case 5:var s=null;switch(nc.tag){case 26:s=nc.memoizedState;case 5:case 27:var u=nc;if(!s||Th(s)){ac=0,oc=null;var c=u.sibling;if(null!==c)nc=c;else{var l=u.return;null!==l?(nc=l,Zc(l)):nc=null}break t}}ac=0,oc=null,Qc(e,t,o,5);break;case 6:ac=0,oc=null,Qc(e,t,o,6);break;case 8:Pc(),lc=6;break e;default:throw Error(i(462))}}Kc();break}catch(h){Uc(e,h)}return ys=gs=null,A.H=r,A.A=a,ec=n,null!==nc?0:(tc=null,rc=0,Er(),lc)}(e,t):Hc(e,t,!0),o=r;;){if(0===a){sc&&!r&&Lc(e,t,0,!1);break}if(6===a)Lc(e,t,0,!ic);else{if(n=e.current.alternate,o&&!zc(n)){a=Hc(e,t,!1),o=!1;continue}if(2===a){if(o=t,e.errorRecoveryDisabledLanes&o)var s=0;else s=0!==(s=-536870913&e.pendingLanes)?s:536870912&s?536870912:0;if(0!==s){t=s;e:{var u=e;a=gc;var c=u.current.memoizedState.isDehydrated;if(c&&(Wc(u,s).flags|=256),2!==(s=Hc(u,s,!1))){if(uc&&!c){u.errorRecoveryDisabledLanes|=o,dc|=o,a=4;break e}o=yc,yc=a,null!==o&&Mc(o)}a=s}if(o=!1,2!==a)continue}}if(1===a){Wc(e,0),Lc(e,t,0,!0);break}e:{switch(r=e,a){case 0:case 1:throw Error(i(345));case 4:if((4194176&t)===t){Lc(r,t,fc,!ic);break e}break;case 2:yc=null;break;case 3:case 5:break;default:throw Error(i(329))}if(r.finishedWork=n,r.finishedLanes=t,(62914560&t)===t&&10<(o=vc+300-ue())){if(Lc(r,t,fc,!ic),0!==Ee(r,0))break e;r.timeoutHandle=eh(Oc.bind(null,r,n,yc,wc,bc,t,fc,dc,mc,ic,2,-0,0),o)}else Oc(r,n,yc,wc,bc,t,fc,dc,mc,ic,0,-0,0)}}break}ml(e)}function Mc(e){null===yc?yc=e:yc.push.apply(yc,e)}function Oc(e,t,n,r,a,o,s,u,c,l,h,d,p){var f=t.subtreeFlags;if((8192&f||16785408===(16785408&f))&&(Ah={stylesheets:null,count:0,unsuspend:Fh},Nu(t),null!==(t=function(){if(null===Ah)throw Error(i(475));var e=Ah;return e.stylesheets&&0===e.count&&Mh(e,e.stylesheets),0<e.count?function(t){var n=setTimeout((function(){if(e.stylesheets&&Mh(e,e.stylesheets),e.unsuspend){var t=e.unsuspend;e.unsuspend=null,t()}}),6e4);return e.unsuspend=t,function(){e.unsuspend=null,clearTimeout(n)}}:null}())))return e.cancelPendingCommit=t($c.bind(null,e,n,r,a,s,u,c,1,d,p)),void Lc(e,o,s,!l);$c(e,n,r,a,s,u,c,h,d,p)}function zc(e){for(var t=e;;){var n=t.tag;if((0===n||11===n||15===n)&&16384&t.flags&&(null!==(n=t.updateQueue)&&null!==(n=n.stores)))for(var r=0;r<n.length;r++){var a=n[r],o=a.getSnapshot;a=a.value;try{if(!Xn(o(),a))return!1}catch(i){return!1}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Lc(e,t,n,r){t&=~pc,t&=~dc,e.suspendedLanes|=t,e.pingedLanes&=~t,r&&(e.warmLanes|=t),r=e.expirationTimes;for(var a=t;0<a;){var o=31-xe(a),i=1<<o;r[o]=-1,a&=~i}0!==n&&Re(e,n,t)}function Bc(){return 0!==(6&ec)||(gl(0,!1),!1)}function Pc(){if(null!==nc){if(0===ac)var e=nc.return;else ys=gs=null,bo(e=nc),fa=null,ma=0,e=nc;for(;null!==e;)Zu(e.alternate,e),e=e.return;nc=null}}function Wc(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;-1!==n&&(e.timeoutHandle=-1,th(n)),null!==(n=e.cancelPendingCommit)&&(e.cancelPendingCommit=null,n()),Pc(),tc=e,nc=n=Lu(e.current,null),rc=t,ac=0,oc=null,ic=!1,sc=Ie(e,t),uc=!1,mc=fc=pc=dc=hc=lc=0,yc=gc=null,bc=!1,0!==(8&t)&&(t|=32&t);var r=e.entangledLanes;if(0!==r)for(e=e.entanglements,r&=t;0<r;){var a=31-xe(r),o=1<<a;t|=e[a],r&=~o}return cc=t,Er(),n}function Uc(e,t){$a=null,A.H=Si,t===ia?(t=pa(),ac=3):t===sa?(t=pa(),ac=4):ac=t===Gi?8:null!==t&&"object"===typeof t&&"function"===typeof t.then?6:1,oc=t,null===nc&&(lc=1,Bi(e,Mr(t,e.current)))}function Vc(){var e=A.H;return A.H=Si,null===e?Si:e}function Gc(){var e=A.A;return A.A=Ju,e}function jc(){lc=4,ic||(4194176&rc)!==rc&&null!==Na.current||(sc=!0),0===(134217727&hc)&&0===(134217727&dc)||null===tc||Lc(tc,rc,fc,!1)}function Hc(e,t,n){var r=ec;ec|=2;var a=Vc(),o=Gc();tc===e&&rc===t||(wc=null,Wc(e,t)),t=!1;var i=lc;e:for(;;)try{if(0!==ac&&null!==nc){var s=nc,u=oc;switch(ac){case 8:Pc(),i=6;break e;case 3:case 2:case 6:null===Na.current&&(t=!0);var c=ac;if(ac=0,oc=null,Qc(e,s,u,c),n&&sc){i=0;break e}break;default:c=ac,ac=0,oc=null,Qc(e,s,u,c)}}qc(),i=lc;break}catch(l){Uc(e,l)}return t&&e.shellSuspendCounter++,ys=gs=null,ec=r,A.H=a,A.A=o,null===nc&&(tc=null,rc=0,Er()),i}function qc(){for(;null!==nc;)Xc(nc)}function Kc(){for(;null!==nc&&!ie();)Xc(nc)}function Xc(e){var t=fs(e.alternate,e,cc);e.memoizedProps=e.pendingProps,null===t?Zc(e):nc=t}function Yc(e){var t=e,n=t.alternate;switch(t.tag){case 15:case 0:t=$i(n,t,t.pendingProps,t.type,void 0,rc);break;case 11:t=$i(n,t,t.pendingProps,t.type.render,t.ref,rc);break;case 5:bo(t);default:Zu(n,t),t=fs(n,t=nc=Bu(t,cc),cc)}e.memoizedProps=e.pendingProps,null===t?Zc(e):nc=t}function Qc(e,t,n,r){ys=gs=null,bo(t),fa=null,ma=0;var a=t.return;try{if(function(e,t,n,r,a){if(n.flags|=32768,null!==r&&"object"===typeof r&&"function"===typeof r.then){if(null!==(t=n.alternate)&&ks(t,n,a,!0),null!==(n=Na.current)){switch(n.tag){case 13:return null===Ta?jc():null===n.alternate&&0===lc&&(lc=3),n.flags&=-257,n.flags|=65536,n.lanes=a,r===ua?n.flags|=16384:(null===(t=n.updateQueue)?n.updateQueue=new Set([r]):t.add(r),al(e,r,a)),!1;case 22:return n.flags|=65536,r===ua?n.flags|=16384:(null===(t=n.updateQueue)?(t={transitions:null,markerInstances:null,retryQueue:new Set([r])},n.updateQueue=t):null===(n=t.retryQueue)?t.retryQueue=new Set([r]):n.add(r),al(e,r,a)),!1}throw Error(i(435,n.tag))}return al(e,r,a),jc(),!1}if(Qr)return null!==(t=Na.current)?(0===(65536&t.flags)&&(t.flags|=256),t.flags|=65536,t.lanes=a,r!==$r&&oa(Mr(e=Error(i(422),{cause:r}),n))):(r!==$r&&oa(Mr(t=Error(i(423),{cause:r}),n)),(e=e.current.alternate).flags|=65536,a&=-a,e.lanes|=a,r=Mr(r,n),Ms(e,a=Wi(e.stateNode,r,a)),4!==lc&&(lc=2)),!1;var o=Error(i(520),{cause:r});if(o=Mr(o,n),null===gc?gc=[o]:gc.push(o),4!==lc&&(lc=2),null===t)return!0;r=Mr(r,n),n=t;do{switch(n.tag){case 3:return n.flags|=65536,e=a&-a,n.lanes|=e,Ms(n,e=Wi(n.stateNode,r,e)),!1;case 1:if(t=n.type,o=n.stateNode,0===(128&n.flags)&&("function"===typeof t.getDerivedStateFromError||null!==o&&"function"===typeof o.componentDidCatch&&(null===kc||!kc.has(o))))return n.flags|=65536,a&=-a,n.lanes|=a,Vi(a=Ui(a),e,n,r),Ms(n,a),!1}n=n.return}while(null!==n);return!1}(e,a,t,n,rc))return lc=1,Bi(e,Mr(n,e.current)),void(nc=null)}catch(o){if(null!==a)throw nc=a,o;return lc=1,Bi(e,Mr(n,e.current)),void(nc=null)}32768&t.flags?(Qr||1===r?e=!0:sc||0!==(536870912&rc)?e=!1:(ic=e=!0,(2===r||3===r||6===r)&&(null!==(r=Na.current)&&13===r.tag&&(r.flags|=16384))),Jc(t,e)):Zc(t)}function Zc(e){var t=e;do{if(0!==(32768&t.flags))return void Jc(t,ic);e=t.return;var n=Yu(t.alternate,t,cc);if(null!==n)return void(nc=n);if(null!==(t=t.sibling))return void(nc=t);nc=t=e}while(null!==t);0===lc&&(lc=5)}function Jc(e,t){do{var n=Qu(e.alternate,e);if(null!==n)return n.flags&=32767,void(nc=n);if(null!==(n=e.return)&&(n.flags|=32768,n.subtreeFlags=0,n.deletions=null),!t&&null!==(e=e.sibling))return void(nc=e);nc=e=n}while(null!==e);lc=6,nc=null}function $c(e,t,n,r,a,o,s,u,c,l){var h=A.T,d=V.p;try{V.p=2,A.T=null,function(e,t,n,r,a,o,s,u){do{tl()}while(null!==Dc);if(0!==(6&ec))throw Error(i(327));var c=e.finishedWork;if(r=e.finishedLanes,null===c)return null;if(e.finishedWork=null,e.finishedLanes=0,c===e.current)throw Error(i(177));e.callbackNode=null,e.callbackPriority=0,e.cancelPendingCommit=null;var l=c.lanes|c.childLanes;if(function(e,t,n,r,a,o){var i=e.pendingLanes;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=n,e.entangledLanes&=n,e.errorRecoveryDisabledLanes&=n,e.shellSuspendCounter=0;var s=e.entanglements,u=e.expirationTimes,c=e.hiddenUpdates;for(n=i&~n;0<n;){var l=31-xe(n),h=1<<l;s[l]=0,u[l]=-1;var d=c[l];if(null!==d)for(c[l]=null,l=0;l<d.length;l++){var p=d[l];null!==p&&(p.lane&=-536870913)}n&=~h}0!==r&&Re(e,r,0),0!==o&&0===a&&0!==e.tag&&(e.suspendedLanes|=o&~(i&~t))}(e,r,l|=Sr,o,s,u),e===tc&&(nc=tc=null,rc=0),0===(10256&c.subtreeFlags)&&0===(10256&c.flags)||Cc||(Cc=!0,Ec=l,Ic=n,function(e,t){ae(e,t)}(de,(function(){return tl(),null}))),n=0!==(15990&c.flags),0!==(15990&c.subtreeFlags)||n?(n=A.T,A.T=null,o=V.p,V.p=2,s=ec,ec|=4,function(e,t){if(e=e.containerInfo,Kl=jh,er(e=$n(e))){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,o=r.focusNode;r=r.focusOffset;try{n.nodeType,o.nodeType}catch(g){n=null;break e}var s=0,u=-1,c=-1,l=0,h=0,d=e,p=null;t:for(;;){for(var f;d!==n||0!==a&&3!==d.nodeType||(u=s+a),d!==o||0!==r&&3!==d.nodeType||(c=s+r),3===d.nodeType&&(s+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===e)break t;if(p===n&&++l===a&&(u=s),p===o&&++h===r&&(c=s),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===u||-1===c?null:{start:u,end:c}}else n=null}n=n||{start:0,end:0}}else n=null;for(Xl={focusedElem:e,selectionRange:n},jh=!1,nu=t;null!==nu;)if(e=(t=nu).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,nu=e;else for(;null!==nu;){switch(o=(t=nu).alternate,e=t.flags,t.tag){case 0:case 11:case 15:case 5:case 26:case 27:case 6:case 4:case 17:break;case 1:if(0!==(1024&e)&&null!==o){e=void 0,n=t,a=o.memoizedProps,o=o.memoizedState,r=n.stateNode;try{var m=Ri(n.type,a,(n.elementType,n.type));e=r.getSnapshotBeforeUpdate(m,o),r.__reactInternalSnapshotBeforeUpdate=e}catch(y){rl(n,n.return,y)}}break;case 3:if(0!==(1024&e))if(9===(n=(e=t.stateNode.containerInfo).nodeType))ih(e);else if(1===n)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":ih(e);break;default:e.textContent=""}break;default:if(0!==(1024&e))throw Error(i(163))}if(null!==(e=t.sibling)){e.return=t.return,nu=e;break}nu=t.return}m=ru,ru=!1}(e,c),fu(c,e),tr(Xl,e.containerInfo),jh=!!Kl,Xl=Kl=null,e.current=c,au(e,c.alternate,c),se(),ec=s,V.p=o,A.T=n):e.current=c,Cc?(Cc=!1,Dc=e,Sc=r):el(e,l),l=e.pendingLanes,0===l&&(kc=null),function(e){if(be&&"function"===typeof be.onCommitFiberRoot)try{be.onCommitFiberRoot(ye,e,void 0,128===(128&e.current.flags))}catch(t){}}(c.stateNode),ml(e),null!==t)for(a=e.onRecoverableError,c=0;c<t.length;c++)l=t[c],a(l.value,{componentStack:l.stack});0!==(3&Sc)&&tl(),l=e.pendingLanes,0!==(4194218&r)&&0!==(42&l)?e===Tc?Nc++:(Nc=0,Tc=e):Nc=0,gl(0,!1)}(e,t,n,r,d,a,o,s)}finally{A.T=h,V.p=d}}function el(e,t){0===(e.pooledCacheLanes&=t)&&(null!=(t=e.pooledCache)&&(e.pooledCache=null,Ua(t)))}function tl(){if(null!==Dc){var e=Dc,t=Ec;Ec=0;var n=Oe(Sc),r=A.T,a=V.p;try{if(V.p=32>n?32:n,A.T=null,null===Dc)var o=!1;else{n=Ic,Ic=null;var s=Dc,u=Sc;if(Dc=null,Sc=0,0!==(6&ec))throw Error(i(331));var c=ec;if(ec|=4,Fu(s.current),Cu(s,s.current,u,n),ec=c,gl(0,!1),be&&"function"===typeof be.onPostCommitFiberRoot)try{be.onPostCommitFiberRoot(ye,s)}catch(l){}o=!0}return o}finally{V.p=a,A.T=r,el(e,t)}}return!1}function nl(e,t,n){t=Mr(n,t),null!==(e=_s(e,t=Wi(e.stateNode,t,2),2))&&(_e(e,2),ml(e))}function rl(e,t,n){if(3===e.tag)nl(e,e,n);else for(;null!==t;){if(3===t.tag){nl(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===kc||!kc.has(r))){e=Mr(n,e),null!==(r=_s(t,n=Ui(2),2))&&(Vi(n,r,t,e),_e(r,2),ml(r));break}}t=t.return}}function al(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new $u;var a=new Set;r.set(t,a)}else void 0===(a=r.get(t))&&(a=new Set,r.set(t,a));a.has(n)||(uc=!0,a.add(n),e=ol.bind(null,e,t,n),t.then(e,e))}function ol(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),e.pingedLanes|=e.suspendedLanes&n,e.warmLanes&=~n,tc===e&&(rc&n)===n&&(4===lc||3===lc&&(62914560&rc)===rc&&300>ue()-vc?0===(2&ec)&&Wc(e,0):pc|=n,mc===rc&&(mc=0)),ml(e)}function il(e,t){0===t&&(t=Ae()),null!==(e=Tr(e,t))&&(_e(e,t),ml(e))}function sl(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),il(e,n)}function ul(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=e.stateNode;break;case 22:r=e.stateNode._retryCache;break;default:throw Error(i(314))}null!==r&&r.delete(t),il(e,n)}var cl=null,ll=null,hl=!1,dl=!1,pl=!1,fl=0;function ml(e){var t;e!==ll&&null===e.next&&(null===ll?cl=ll=e:ll=ll.next=e),dl=!0,hl||(hl=!0,t=yl,rh((function(){0!==(6&ec)?ae(le,t):t()})))}function gl(e,t){if(!pl&&dl){pl=!0;do{for(var n=!1,r=cl;null!==r;){if(!t)if(0!==e){var a=r.pendingLanes;if(0===a)var o=0;else{var i=r.suspendedLanes,s=r.pingedLanes;o=(1<<31-xe(42|e)+1)-1,o=201326677&(o&=a&~(i&~s))?201326677&o|1:o?2|o:0}0!==o&&(n=!0,xl(r,o))}else o=rc,0===(3&(o=Ee(r,r===tc?o:0)))||Ie(r,o)||(n=!0,xl(r,o));r=r.next}}while(n);pl=!1}}function yl(){dl=hl=!1;var e=0;0!==fl&&(function(){var e=window.event;if(e&&"popstate"===e.type)return e!==$l&&($l=e,!0);return $l=null,!1}()&&(e=fl),fl=0);for(var t=ue(),n=null,r=cl;null!==r;){var a=r.next,o=bl(r,t);0===o?(r.next=null,null===n?cl=a:n.next=a,null===a&&(ll=n)):(n=r,(0!==e||0!==(3&o))&&(dl=!0)),r=a}gl(e,!1)}function bl(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,o=-62914561&e.pendingLanes;0<o;){var i=31-xe(o),s=1<<i,u=a[i];-1===u?0!==(s&n)&&0===(s&r)||(a[i]=Ne(s,t)):u<=t&&(e.expiredLanes|=s),o&=~s}if(n=rc,n=Ee(e,e===(t=tc)?n:0),r=e.callbackNode,0===n||e===t&&2===ac||null!==e.cancelPendingCommit)return null!==r&&null!==r&&oe(r),e.callbackNode=null,e.callbackPriority=0;if(0===(3&n)||Ie(e,n)){if((t=n&-n)===e.callbackPriority)return t;switch(null!==r&&oe(r),Oe(n)){case 2:case 8:n=he;break;case 32:default:n=de;break;case 268435456:n=fe}return r=vl.bind(null,e),n=ae(n,r),e.callbackPriority=t,e.callbackNode=n,t}return null!==r&&null!==r&&oe(r),e.callbackPriority=2,e.callbackNode=null,2}function vl(e,t){var n=e.callbackNode;if(tl()&&e.callbackNode!==n)return null;var r=rc;return 0===(r=Ee(e,e===tc?r:0))?null:(Rc(e,r,t),bl(e,ue()),null!=e.callbackNode&&e.callbackNode===n?vl.bind(null,e):null)}function xl(e,t){if(tl())return null;Rc(e,t,!0)}function wl(){return 0===fl&&(fl=Te()),fl}function kl(e){return null==e||"symbol"===typeof e||"boolean"===typeof e?null:"function"===typeof e?e:Tt(""+e)}function Cl(e,t){var n=t.ownerDocument.createElement("input");return n.name=t.name,n.value=t.value,e.id&&n.setAttribute("form",e.id),t.parentNode.insertBefore(n,t),e=new FormData(e),n.parentNode.removeChild(n),e}for(var Dl=0;Dl<wr.length;Dl++){var Sl=wr[Dl];kr(Sl.toLowerCase(),"on"+(Sl[0].toUpperCase()+Sl.slice(1)))}kr(pr,"onAnimationEnd"),kr(fr,"onAnimationIteration"),kr(mr,"onAnimationStart"),kr("dblclick","onDoubleClick"),kr("focusin","onFocus"),kr("focusout","onBlur"),kr(gr,"onTransitionRun"),kr(yr,"onTransitionStart"),kr(br,"onTransitionCancel"),kr(vr,"onTransitionEnd"),tt("onMouseEnter",["mouseout","mouseover"]),tt("onMouseLeave",["mouseout","mouseover"]),tt("onPointerEnter",["pointerout","pointerover"]),tt("onPointerLeave",["pointerout","pointerover"]),et("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),et("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),et("onBeforeInput",["compositionend","keypress","textInput","paste"]),et("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),et("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),et("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var El="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Il=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(El));function Nl(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var o=void 0;if(t)for(var i=r.length-1;0<=i;i--){var s=r[i],u=s.instance,c=s.currentTarget;if(s=s.listener,u!==o&&a.isPropagationStopped())break e;o=s,a.currentTarget=c;try{o(a)}catch(l){Mi(l)}a.currentTarget=null,o=u}else for(i=0;i<r.length;i++){if(u=(s=r[i]).instance,c=s.currentTarget,s=s.listener,u!==o&&a.isPropagationStopped())break e;o=s,a.currentTarget=c;try{o(a)}catch(l){Mi(l)}a.currentTarget=null,o=u}}}}function Tl(e,t){var n=t[Ue];void 0===n&&(n=t[Ue]=new Set);var r=e+"__bubble";n.has(r)||(Rl(t,e,2,!1),n.add(r))}function Al(e,t,n){var r=0;t&&(r|=4),Rl(n,e,r,t)}var Fl="_reactListening"+Math.random().toString(36).slice(2);function _l(e){if(!e[Fl]){e[Fl]=!0,Je.forEach((function(t){"selectionchange"!==t&&(Il.has(t)||Al(t,!1,e),Al(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Fl]||(t[Fl]=!0,Al("selectionchange",!1,t))}}function Rl(e,t,n,r){switch(Zh(t)){case 2:var a=Hh;break;case 8:a=qh;break;default:a=Kh}n=a.bind(null,t,n,e),a=void 0,!Bt||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(a=!0),r?void 0!==a?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):void 0!==a?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function Ml(e,t,n,r,a){var o=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var s=r.stateNode.containerInfo;if(s===a||8===s.nodeType&&s.parentNode===a)break;if(4===i)for(i=r.return;null!==i;){var u=i.tag;if((3===u||4===u)&&((u=i.stateNode.containerInfo)===a||8===u.nodeType&&u.parentNode===a))return;i=i.return}for(;null!==s;){if(null===(i=Ke(s)))return;if(5===(u=i.tag)||6===u||26===u||27===u){r=o=i;continue e}s=s.parentNode}}r=r.return}zt((function(){var r=o,a=Ft(n),i=[];e:{var s=xr.get(e);if(void 0!==s){var u=Jt,c=e;switch(e){case"keypress":if(0===jt(n))break e;case"keydown":case"keyup":u=fn;break;case"focusin":c="focus",u=an;break;case"focusout":c="blur",u=an;break;case"beforeblur":case"afterblur":u=an;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":u=nn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":u=rn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":u=gn;break;case pr:case fr:case mr:u=on;break;case vr:u=yn;break;case"scroll":case"scrollend":u=en;break;case"wheel":u=bn;break;case"copy":case"cut":case"paste":u=sn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":u=mn;break;case"toggle":case"beforetoggle":u=vn}var l=0!==(4&t),h=!l&&("scroll"===e||"scrollend"===e),d=l?null!==s?s+"Capture":null:s;l=[];for(var p,f=r;null!==f;){var m=f;if(p=m.stateNode,5!==(m=m.tag)&&26!==m&&27!==m||null===p||null===d||null!=(m=Lt(f,d))&&l.push(Ol(f,m,p)),h)break;f=f.return}0<l.length&&(s=new u(s,c,null,n,a),i.push({event:s,listeners:l}))}}if(0===(7&t)){if(u="mouseout"===e||"pointerout"===e,(!(s="mouseover"===e||"pointerover"===e)||n===At||!(c=n.relatedTarget||n.fromElement)||!Ke(c)&&!c[We])&&(u||s)&&(s=a.window===a?a:(s=a.ownerDocument)?s.defaultView||s.parentWindow:window,u?(u=r,null!==(c=(c=n.relatedTarget||n.toElement)?Ke(c):null)&&(h=L(c),l=c.tag,c!==h||5!==l&&27!==l&&6!==l)&&(c=null)):(u=null,c=r),u!==c)){if(l=nn,m="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(l=mn,m="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==u?s:Ye(u),p=null==c?s:Ye(c),(s=new l(m,f+"leave",u,n,a)).target=h,s.relatedTarget=p,m=null,Ke(a)===r&&((l=new l(d,f+"enter",c,n,a)).target=p,l.relatedTarget=h,m=l),h=m,u&&c)e:{for(d=c,f=0,p=l=u;p;p=Ll(p))f++;for(p=0,m=d;m;m=Ll(m))p++;for(;0<f-p;)l=Ll(l),f--;for(;0<p-f;)d=Ll(d),p--;for(;f--;){if(l===d||null!==d&&l===d.alternate)break e;l=Ll(l),d=Ll(d)}l=null}else l=null;null!==u&&Bl(i,s,u,l,!1),null!==c&&null!==h&&Bl(i,h,c,l,!0)}if("select"===(u=(s=r?Ye(r):window).nodeName&&s.nodeName.toLowerCase())||"input"===u&&"file"===s.type)var g=Ln;else if(Fn(s))if(Bn)g=Kn;else{g=Hn;var y=jn}else!(u=s.nodeName)||"input"!==u.toLowerCase()||"checkbox"!==s.type&&"radio"!==s.type?r&&Et(r.elementType)&&(g=Ln):g=qn;switch(g&&(g=g(e,r))?_n(i,g,n,a):(y&&y(e,s,r),"focusout"===e&&r&&"number"===s.type&&null!=r.memoizedProps.value&&bt(s,"number",s.value)),y=r?Ye(r):window,e){case"focusin":(Fn(y)||"true"===y.contentEditable)&&(rr=y,ar=r,or=null);break;case"focusout":or=ar=rr=null;break;case"mousedown":ir=!0;break;case"contextmenu":case"mouseup":case"dragend":ir=!1,sr(i,n,a);break;case"selectionchange":if(nr)break;case"keydown":case"keyup":sr(i,n,a)}var b;if(wn)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Tn?In(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Dn&&"ko"!==n.locale&&(Tn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Tn&&(b=Gt()):(Ut="value"in(Wt=a)?Wt.value:Wt.textContent,Tn=!0)),0<(y=zl(r,v)).length&&(v=new un(v,e,null,n,a),i.push({event:v,listeners:y}),b?v.data=b:null!==(b=Nn(n))&&(v.data=b))),(b=Cn?function(e,t){switch(e){case"compositionend":return Nn(t);case"keypress":return 32!==t.which?null:(En=!0,Sn);case"textInput":return(e=t.data)===Sn&&En?null:e;default:return null}}(e,n):function(e,t){if(Tn)return"compositionend"===e||!wn&&In(e,t)?(e=Gt(),Vt=Ut=Wt=null,Tn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Dn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(v=zl(r,"onBeforeInput")).length&&(y=new un("onBeforeInput","beforeinput",null,n,a),i.push({event:y,listeners:v}),y.data=b)),function(e,t,n,r,a){if("submit"===t&&n&&n.stateNode===a){var o=kl((a[Pe]||null).action),i=r.submitter;i&&null!==(t=(t=i[Pe]||null)?kl(t.formAction):i.getAttribute("formAction"))&&(o=t,i=null);var s=new Jt("action","action",null,r,a);e.push({event:s,listeners:[{instance:null,listener:function(){if(r.defaultPrevented){if(0!==fl){var e=i?Cl(a,i):new FormData(a);hi(n,{pending:!0,data:e,method:a.method,action:o},null,e)}}else"function"===typeof o&&(s.preventDefault(),e=i?Cl(a,i):new FormData(a),hi(n,{pending:!0,data:e,method:a.method,action:o},o,e))},currentTarget:a}]})}}(i,e,r,n,a)}Nl(i,t)}))}function Ol(e,t,n){return{instance:e,listener:t,currentTarget:n}}function zl(e,t){for(var n=t+"Capture",r=[];null!==e;){var a=e,o=a.stateNode;5!==(a=a.tag)&&26!==a&&27!==a||null===o||(null!=(a=Lt(e,n))&&r.unshift(Ol(e,a,o)),null!=(a=Lt(e,t))&&r.push(Ol(e,a,o))),e=e.return}return r}function Ll(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag&&27!==e.tag);return e||null}function Bl(e,t,n,r,a){for(var o=t._reactName,i=[];null!==n&&n!==r;){var s=n,u=s.alternate,c=s.stateNode;if(s=s.tag,null!==u&&u===r)break;5!==s&&26!==s&&27!==s||null===c||(u=c,a?null!=(c=Lt(n,o))&&i.unshift(Ol(n,c,u)):a||null!=(c=Lt(n,o))&&i.push(Ol(n,c,u))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var Pl=/\r\n?/g,Wl=/\u0000|\uFFFD/g;function Ul(e){return("string"===typeof e?e:""+e).replace(Pl,"\n").replace(Wl,"")}function Vl(e,t){return t=Ul(t),Ul(e)===t}function Gl(){}function jl(e,t,n,r,a,o){switch(n){case"children":"string"===typeof r?"body"===t||"textarea"===t&&""===r||kt(e,r):("number"===typeof r||"bigint"===typeof r)&&"body"!==t&&kt(e,""+r);break;case"className":st(e,"class",r);break;case"tabIndex":st(e,"tabindex",r);break;case"dir":case"role":case"viewBox":case"width":case"height":st(e,n,r);break;case"style":St(e,r,o);break;case"data":if("object"!==t){st(e,"data",r);break}case"src":case"href":if(""===r&&("a"!==t||"href"!==n)){e.removeAttribute(n);break}if(null==r||"function"===typeof r||"symbol"===typeof r||"boolean"===typeof r){e.removeAttribute(n);break}r=Tt(""+r),e.setAttribute(n,r);break;case"action":case"formAction":if("function"===typeof r){e.setAttribute(n,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}if("function"===typeof o&&("formAction"===n?("input"!==t&&jl(e,t,"name",a.name,a,null),jl(e,t,"formEncType",a.formEncType,a,null),jl(e,t,"formMethod",a.formMethod,a,null),jl(e,t,"formTarget",a.formTarget,a,null)):(jl(e,t,"encType",a.encType,a,null),jl(e,t,"method",a.method,a,null),jl(e,t,"target",a.target,a,null))),null==r||"symbol"===typeof r||"boolean"===typeof r){e.removeAttribute(n);break}r=Tt(""+r),e.setAttribute(n,r);break;case"onClick":null!=r&&(e.onclick=Gl);break;case"onScroll":null!=r&&Tl("scroll",e);break;case"onScrollEnd":null!=r&&Tl("scrollend",e);break;case"dangerouslySetInnerHTML":if(null!=r){if("object"!==typeof r||!("__html"in r))throw Error(i(61));if(null!=(n=r.__html)){if(null!=a.children)throw Error(i(60));e.innerHTML=n}}break;case"multiple":e.multiple=r&&"function"!==typeof r&&"symbol"!==typeof r;break;case"muted":e.muted=r&&"function"!==typeof r&&"symbol"!==typeof r;break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":case"autoFocus":break;case"xlinkHref":if(null==r||"function"===typeof r||"boolean"===typeof r||"symbol"===typeof r){e.removeAttribute("xlink:href");break}n=Tt(""+r),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",n);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":null!=r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,""+r):e.removeAttribute(n);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,""):e.removeAttribute(n);break;case"capture":case"download":!0===r?e.setAttribute(n,""):!1!==r&&null!=r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,r):e.removeAttribute(n);break;case"cols":case"rows":case"size":case"span":null!=r&&"function"!==typeof r&&"symbol"!==typeof r&&!isNaN(r)&&1<=r?e.setAttribute(n,r):e.removeAttribute(n);break;case"rowSpan":case"start":null==r||"function"===typeof r||"symbol"===typeof r||isNaN(r)?e.removeAttribute(n):e.setAttribute(n,r);break;case"popover":Tl("beforetoggle",e),Tl("toggle",e),it(e,"popover",r);break;case"xlinkActuate":ut(e,"http://www.w3.org/1999/xlink","xlink:actuate",r);break;case"xlinkArcrole":ut(e,"http://www.w3.org/1999/xlink","xlink:arcrole",r);break;case"xlinkRole":ut(e,"http://www.w3.org/1999/xlink","xlink:role",r);break;case"xlinkShow":ut(e,"http://www.w3.org/1999/xlink","xlink:show",r);break;case"xlinkTitle":ut(e,"http://www.w3.org/1999/xlink","xlink:title",r);break;case"xlinkType":ut(e,"http://www.w3.org/1999/xlink","xlink:type",r);break;case"xmlBase":ut(e,"http://www.w3.org/XML/1998/namespace","xml:base",r);break;case"xmlLang":ut(e,"http://www.w3.org/XML/1998/namespace","xml:lang",r);break;case"xmlSpace":ut(e,"http://www.w3.org/XML/1998/namespace","xml:space",r);break;case"is":it(e,"is",r);break;case"innerText":case"textContent":break;default:(!(2<n.length)||"o"!==n[0]&&"O"!==n[0]||"n"!==n[1]&&"N"!==n[1])&&it(e,n=It.get(n)||n,r)}}function Hl(e,t,n,r,a,o){switch(n){case"style":St(e,r,o);break;case"dangerouslySetInnerHTML":if(null!=r){if("object"!==typeof r||!("__html"in r))throw Error(i(61));if(null!=(n=r.__html)){if(null!=a.children)throw Error(i(60));e.innerHTML=n}}break;case"children":"string"===typeof r?kt(e,r):("number"===typeof r||"bigint"===typeof r)&&kt(e,""+r);break;case"onScroll":null!=r&&Tl("scroll",e);break;case"onScrollEnd":null!=r&&Tl("scrollend",e);break;case"onClick":null!=r&&(e.onclick=Gl);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":case"innerText":case"textContent":break;default:$e.hasOwnProperty(n)||("o"!==n[0]||"n"!==n[1]||(a=n.endsWith("Capture"),t=n.slice(2,a?n.length-7:void 0),"function"===typeof(o=null!=(o=e[Pe]||null)?o[n]:null)&&e.removeEventListener(t,o,a),"function"!==typeof r)?n in e?e[n]=r:!0===r?e.setAttribute(n,""):it(e,n,r):("function"!==typeof o&&null!==o&&(n in e?e[n]=null:e.hasAttribute(n)&&e.removeAttribute(n)),e.addEventListener(t,r,a)))}}function ql(e,t,n){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Tl("error",e),Tl("load",e);var r,a=!1,o=!1;for(r in n)if(n.hasOwnProperty(r)){var s=n[r];if(null!=s)switch(r){case"src":a=!0;break;case"srcSet":o=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(i(137,t));default:jl(e,t,r,s,n,null)}}return o&&jl(e,t,"srcSet",n.srcSet,n,null),void(a&&jl(e,t,"src",n.src,n,null));case"input":Tl("invalid",e);var u=r=s=o=null,c=null,l=null;for(a in n)if(n.hasOwnProperty(a)){var h=n[a];if(null!=h)switch(a){case"name":o=h;break;case"type":s=h;break;case"checked":c=h;break;case"defaultChecked":l=h;break;case"value":r=h;break;case"defaultValue":u=h;break;case"children":case"dangerouslySetInnerHTML":if(null!=h)throw Error(i(137,t));break;default:jl(e,t,a,h,n,null)}}return yt(e,r,u,c,l,s,o,!1),void ht(e);case"select":for(o in Tl("invalid",e),a=s=r=null,n)if(n.hasOwnProperty(o)&&null!=(u=n[o]))switch(o){case"value":r=u;break;case"defaultValue":s=u;break;case"multiple":a=u;default:jl(e,t,o,u,n,null)}return t=r,n=s,e.multiple=!!a,void(null!=t?vt(e,!!a,t,!1):null!=n&&vt(e,!!a,n,!0));case"textarea":for(s in Tl("invalid",e),r=o=a=null,n)if(n.hasOwnProperty(s)&&null!=(u=n[s]))switch(s){case"value":a=u;break;case"defaultValue":o=u;break;case"children":r=u;break;case"dangerouslySetInnerHTML":if(null!=u)throw Error(i(91));break;default:jl(e,t,s,u,n,null)}return wt(e,a,o,r),void ht(e);case"option":for(c in n)if(n.hasOwnProperty(c)&&null!=(a=n[c]))if("selected"===c)e.selected=a&&"function"!==typeof a&&"symbol"!==typeof a;else jl(e,t,c,a,n,null);return;case"dialog":Tl("cancel",e),Tl("close",e);break;case"iframe":case"object":Tl("load",e);break;case"video":case"audio":for(a=0;a<El.length;a++)Tl(El[a],e);break;case"image":Tl("error",e),Tl("load",e);break;case"details":Tl("toggle",e);break;case"embed":case"source":case"link":Tl("error",e),Tl("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(l in n)if(n.hasOwnProperty(l)&&null!=(a=n[l]))switch(l){case"children":case"dangerouslySetInnerHTML":throw Error(i(137,t));default:jl(e,t,l,a,n,null)}return;default:if(Et(t)){for(h in n)n.hasOwnProperty(h)&&(void 0!==(a=n[h])&&Hl(e,t,h,a,n,void 0));return}}for(u in n)n.hasOwnProperty(u)&&(null!=(a=n[u])&&jl(e,t,u,a,n,null))}var Kl=null,Xl=null;function Yl(e){return 9===e.nodeType?e:e.ownerDocument}function Ql(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function Zl(e,t){if(0===e)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return 1===e&&"foreignObject"===t?0:e}function Jl(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"bigint"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var $l=null;var eh="function"===typeof setTimeout?setTimeout:void 0,th="function"===typeof clearTimeout?clearTimeout:void 0,nh="function"===typeof Promise?Promise:void 0,rh="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof nh?function(e){return nh.resolve(null).then(e).catch(ah)}:eh;function ah(e){setTimeout((function(){throw e}))}function oh(e,t){var n=t,r=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return e.removeChild(a),void md(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);md(t)}function ih(e){var t=e.firstChild;for(t&&10===t.nodeType&&(t=t.nextSibling);t;){var n=t;switch(t=t.nextSibling,n.nodeName){case"HTML":case"HEAD":case"BODY":ih(n),qe(n);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if("stylesheet"===n.rel.toLowerCase())continue}e.removeChild(n)}}function sh(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t||"F!"===t||"F"===t)break;if("/$"===t)return null}}return e}function uh(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}function ch(e,t,n){switch(t=Yl(n),e){case"html":if(!(e=t.documentElement))throw Error(i(452));return e;case"head":if(!(e=t.head))throw Error(i(453));return e;case"body":if(!(e=t.body))throw Error(i(454));return e;default:throw Error(i(451))}}var lh=new Map,hh=new Set;function dh(e){return"function"===typeof e.getRootNode?e.getRootNode():e.ownerDocument}var ph=V.d;V.d={f:function(){var e=ph.f(),t=Bc();return e||t},r:function(e){var t=Xe(e);null!==t&&5===t.tag&&"form"===t.type?pi(t):ph.r(e)},D:function(e){ph.D(e),mh("dns-prefetch",e,null)},C:function(e,t){ph.C(e,t),mh("preconnect",e,t)},L:function(e,t,n){ph.L(e,t,n);var r=fh;if(r&&e&&t){var a='link[rel="preload"][as="'+mt(t)+'"]';"image"===t&&n&&n.imageSrcSet?(a+='[imagesrcset="'+mt(n.imageSrcSet)+'"]',"string"===typeof n.imageSizes&&(a+='[imagesizes="'+mt(n.imageSizes)+'"]')):a+='[href="'+mt(e)+'"]';var o=a;switch(t){case"style":o=yh(e);break;case"script":o=xh(e)}lh.has(o)||(e=F({rel:"preload",href:"image"===t&&n&&n.imageSrcSet?void 0:e,as:t},n),lh.set(o,e),null!==r.querySelector(a)||"style"===t&&r.querySelector(bh(o))||"script"===t&&r.querySelector(wh(o))||(ql(t=r.createElement("link"),"link",e),Ze(t),r.head.appendChild(t)))}},m:function(e,t){ph.m(e,t);var n=fh;if(n&&e){var r=t&&"string"===typeof t.as?t.as:"script",a='link[rel="modulepreload"][as="'+mt(r)+'"][href="'+mt(e)+'"]',o=a;switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":o=xh(e)}if(!lh.has(o)&&(e=F({rel:"modulepreload",href:e},t),lh.set(o,e),null===n.querySelector(a))){switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(n.querySelector(wh(o)))return}ql(r=n.createElement("link"),"link",e),Ze(r),n.head.appendChild(r)}}},X:function(e,t){ph.X(e,t);var n=fh;if(n&&e){var r=Qe(n).hoistableScripts,a=xh(e),o=r.get(a);o||((o=n.querySelector(wh(a)))||(e=F({src:e,async:!0},t),(t=lh.get(a))&&Sh(e,t),Ze(o=n.createElement("script")),ql(o,"link",e),n.head.appendChild(o)),o={type:"script",instance:o,count:1,state:null},r.set(a,o))}},S:function(e,t,n){ph.S(e,t,n);var r=fh;if(r&&e){var a=Qe(r).hoistableStyles,o=yh(e);t=t||"default";var i=a.get(o);if(!i){var s={loading:0,preload:null};if(i=r.querySelector(bh(o)))s.loading=5;else{e=F({rel:"stylesheet",href:e,"data-precedence":t},n),(n=lh.get(o))&&Dh(e,n);var u=i=r.createElement("link");Ze(u),ql(u,"link",e),u._p=new Promise((function(e,t){u.onload=e,u.onerror=t})),u.addEventListener("load",(function(){s.loading|=1})),u.addEventListener("error",(function(){s.loading|=2})),s.loading|=4,Ch(i,t,r)}i={type:"stylesheet",instance:i,count:1,state:s},a.set(o,i)}}},M:function(e,t){ph.M(e,t);var n=fh;if(n&&e){var r=Qe(n).hoistableScripts,a=xh(e),o=r.get(a);o||((o=n.querySelector(wh(a)))||(e=F({src:e,async:!0,type:"module"},t),(t=lh.get(a))&&Sh(e,t),Ze(o=n.createElement("script")),ql(o,"link",e),n.head.appendChild(o)),o={type:"script",instance:o,count:1,state:null},r.set(a,o))}}};var fh="undefined"===typeof document?null:document;function mh(e,t,n){var r=fh;if(r&&"string"===typeof t&&t){var a=mt(t);a='link[rel="'+e+'"][href="'+a+'"]',"string"===typeof n&&(a+='[crossorigin="'+n+'"]'),hh.has(a)||(hh.add(a),e={rel:e,crossOrigin:n,href:t},null===r.querySelector(a)&&(ql(t=r.createElement("link"),"link",e),Ze(t),r.head.appendChild(t)))}}function gh(e,t,n,r){var a,o,s,u,c=(c=Z.current)?dh(c):null;if(!c)throw Error(i(446));switch(e){case"meta":case"title":return null;case"style":return"string"===typeof n.precedence&&"string"===typeof n.href?(t=yh(n.href),(r=(n=Qe(c).hoistableStyles).get(t))||(r={type:"style",instance:null,count:0,state:null},n.set(t,r)),r):{type:"void",instance:null,count:0,state:null};case"link":if("stylesheet"===n.rel&&"string"===typeof n.href&&"string"===typeof n.precedence){e=yh(n.href);var l=Qe(c).hoistableStyles,h=l.get(e);if(h||(c=c.ownerDocument||c,h={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},l.set(e,h),(l=c.querySelector(bh(e)))&&!l._p&&(h.instance=l,h.state.loading=5),lh.has(e)||(n={rel:"preload",as:"style",href:n.href,crossOrigin:n.crossOrigin,integrity:n.integrity,media:n.media,hrefLang:n.hrefLang,referrerPolicy:n.referrerPolicy},lh.set(e,n),l||(a=c,o=e,s=n,u=h.state,a.querySelector('link[rel="preload"][as="style"]['+o+"]")?u.loading=1:(o=a.createElement("link"),u.preload=o,o.addEventListener("load",(function(){return u.loading|=1})),o.addEventListener("error",(function(){return u.loading|=2})),ql(o,"link",s),Ze(o),a.head.appendChild(o))))),t&&null===r)throw Error(i(528,""));return h}if(t&&null!==r)throw Error(i(529,""));return null;case"script":return t=n.async,"string"===typeof(n=n.src)&&t&&"function"!==typeof t&&"symbol"!==typeof t?(t=xh(n),(r=(n=Qe(c).hoistableScripts).get(t))||(r={type:"script",instance:null,count:0,state:null},n.set(t,r)),r):{type:"void",instance:null,count:0,state:null};default:throw Error(i(444,e))}}function yh(e){return'href="'+mt(e)+'"'}function bh(e){return'link[rel="stylesheet"]['+e+"]"}function vh(e){return F({},e,{"data-precedence":e.precedence,precedence:null})}function xh(e){return'[src="'+mt(e)+'"]'}function wh(e){return"script[async]"+e}function kh(e,t,n){if(t.count++,null===t.instance)switch(t.type){case"style":var r=e.querySelector('style[data-href~="'+mt(n.href)+'"]');if(r)return t.instance=r,Ze(r),r;var a=F({},n,{"data-href":n.href,"data-precedence":n.precedence,href:null,precedence:null});return Ze(r=(e.ownerDocument||e).createElement("style")),ql(r,"style",a),Ch(r,n.precedence,e),t.instance=r;case"stylesheet":a=yh(n.href);var o=e.querySelector(bh(a));if(o)return t.state.loading|=4,t.instance=o,Ze(o),o;r=vh(n),(a=lh.get(a))&&Dh(r,a),Ze(o=(e.ownerDocument||e).createElement("link"));var s=o;return s._p=new Promise((function(e,t){s.onload=e,s.onerror=t})),ql(o,"link",r),t.state.loading|=4,Ch(o,n.precedence,e),t.instance=o;case"script":return o=xh(n.src),(a=e.querySelector(wh(o)))?(t.instance=a,Ze(a),a):(r=n,(a=lh.get(o))&&Sh(r=F({},n),a),Ze(a=(e=e.ownerDocument||e).createElement("script")),ql(a,"link",r),e.head.appendChild(a),t.instance=a);case"void":return null;default:throw Error(i(443,t.type))}else"stylesheet"===t.type&&0===(4&t.state.loading)&&(r=t.instance,t.state.loading|=4,Ch(r,n.precedence,e));return t.instance}function Ch(e,t,n){for(var r=n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),a=r.length?r[r.length-1]:null,o=a,i=0;i<r.length;i++){var s=r[i];if(s.dataset.precedence===t)o=s;else if(o!==a)break}o?o.parentNode.insertBefore(e,o.nextSibling):(t=9===n.nodeType?n.head:n).insertBefore(e,t.firstChild)}function Dh(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.title&&(e.title=t.title)}function Sh(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.integrity&&(e.integrity=t.integrity)}var Eh=null;function Ih(e,t,n){if(null===Eh){var r=new Map,a=Eh=new Map;a.set(n,r)}else(r=(a=Eh).get(n))||(r=new Map,a.set(n,r));if(r.has(e))return r;for(r.set(e,null),n=n.getElementsByTagName(e),a=0;a<n.length;a++){var o=n[a];if(!(o[He]||o[Be]||"link"===e&&"stylesheet"===o.getAttribute("rel"))&&"http://www.w3.org/2000/svg"!==o.namespaceURI){var i=o.getAttribute(t)||"";i=e+i;var s=r.get(i);s?s.push(o):r.set(i,[o])}}return r}function Nh(e,t,n){(e=e.ownerDocument||e).head.insertBefore(n,"title"===t?e.querySelector("head > title"):null)}function Th(e){return"stylesheet"!==e.type||0!==(3&e.state.loading)}var Ah=null;function Fh(){}function _h(){if(this.count--,0===this.count)if(this.stylesheets)Mh(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}var Rh=null;function Mh(e,t){e.stylesheets=null,null!==e.unsuspend&&(e.count++,Rh=new Map,t.forEach(Oh,e),Rh=null,_h.call(e))}function Oh(e,t){if(!(4&t.state.loading)){var n=Rh.get(e);if(n)var r=n.get(null);else{n=new Map,Rh.set(e,n);for(var a=e.querySelectorAll("link[data-precedence],style[data-precedence]"),o=0;o<a.length;o++){var i=a[o];"LINK"!==i.nodeName&&"not all"===i.getAttribute("media")||(n.set(i.dataset.precedence,i),r=i)}r&&n.set(null,r)}i=(a=t.instance).getAttribute("data-precedence"),(o=n.get(i)||r)===r&&n.set(null,a),n.set(i,a),this.count++,r=_h.bind(this),a.addEventListener("load",r),a.addEventListener("error",r),o?o.parentNode.insertBefore(a,o.nextSibling):(e=9===e.nodeType?e.head:e).insertBefore(a,e.firstChild),t.state.loading|=4}}var zh={$$typeof:g,Provider:null,Consumer:null,_currentValue:G,_currentValue2:G,_threadCount:0};function Lh(e,t,n,r,a,o,i,s){this.tag=1,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Fe(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.finishedLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Fe(0),this.hiddenUpdates=Fe(null),this.identifierPrefix=r,this.onUncaughtError=a,this.onCaughtError=o,this.onRecoverableError=i,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=s,this.incompleteTransitions=new Map}function Bh(e,t,n,r,a,o,i,s,u,c,l,h){return e=new Lh(e,t,n,i,s,u,c,h),t=1,!0===o&&(t|=24),o=Ou(3,null,null,t),e.current=o,o.stateNode=e,(t=Wa()).refCount++,e.pooledCache=t,t.refCount++,o.memoizedState={element:r,isDehydrated:n,cache:t},Ts(o),e}function Ph(e){return e?e=_r:_r}function Wh(e,t,n,r,a,o){a=Ph(a),null===r.context?r.context=a:r.pendingContext=a,(r=Fs(t)).payload={element:n},null!==(o=void 0===o?null:o)&&(r.callback=o),null!==(n=_s(e,r,t))&&(_c(n,0,t),Rs(n,e,t))}function Uh(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Vh(e,t){Uh(e,t),(e=e.alternate)&&Uh(e,t)}function Gh(e){if(13===e.tag){var t=Tr(e,67108864);null!==t&&_c(t,0,67108864),Vh(e,67108864)}}var jh=!0;function Hh(e,t,n,r){var a=A.T;A.T=null;var o=V.p;try{V.p=2,Kh(e,t,n,r)}finally{V.p=o,A.T=a}}function qh(e,t,n,r){var a=A.T;A.T=null;var o=V.p;try{V.p=8,Kh(e,t,n,r)}finally{V.p=o,A.T=a}}function Kh(e,t,n,r){if(jh){var a=Xh(r);if(null===a)Ml(e,t,r,Yh,n),id(e,r);else if(function(e,t,n,r,a){switch(t){case"focusin":return $h=sd($h,e,t,n,r,a),!0;case"dragenter":return ed=sd(ed,e,t,n,r,a),!0;case"mouseover":return td=sd(td,e,t,n,r,a),!0;case"pointerover":var o=a.pointerId;return nd.set(o,sd(nd.get(o)||null,e,t,n,r,a)),!0;case"gotpointercapture":return o=a.pointerId,rd.set(o,sd(rd.get(o)||null,e,t,n,r,a)),!0}return!1}(a,e,t,n,r))r.stopPropagation();else if(id(e,r),4&t&&-1<od.indexOf(e)){for(;null!==a;){var o=Xe(a);if(null!==o)switch(o.tag){case 3:if((o=o.stateNode).current.memoizedState.isDehydrated){var i=Se(o.pendingLanes);if(0!==i){var s=o;for(s.pendingLanes|=2,s.entangledLanes|=2;i;){var u=1<<31-xe(i);s.entanglements[1]|=u,i&=~u}ml(o),0===(6&ec)&&(xc=ue()+500,gl(0,!1))}}break;case 13:null!==(s=Tr(o,2))&&_c(s,0,2),Bc(),Vh(o,2)}if(null===(o=Xh(r))&&Ml(e,t,r,Yh,n),o===a)break;a=o}null!==a&&r.stopPropagation()}else Ml(e,t,r,null,n)}}function Xh(e){return Qh(e=Ft(e))}var Yh=null;function Qh(e){if(Yh=null,null!==(e=Ke(e))){var t=L(e);if(null===t)e=null;else{var n=t.tag;if(13===n){if(null!==(e=B(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return Yh=e,null}function Zh(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ce()){case le:return 2;case he:return 8;case de:case pe:return 32;case fe:return 268435456;default:return 32}default:return 32}}var Jh=!1,$h=null,ed=null,td=null,nd=new Map,rd=new Map,ad=[],od="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function id(e,t){switch(e){case"focusin":case"focusout":$h=null;break;case"dragenter":case"dragleave":ed=null;break;case"mouseover":case"mouseout":td=null;break;case"pointerover":case"pointerout":nd.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":rd.delete(t.pointerId)}}function sd(e,t,n,r,a,o){return null===e||e.nativeEvent!==o?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:o,targetContainers:[a]},null!==t&&(null!==(t=Xe(t))&&Gh(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==a&&-1===t.indexOf(a)&&t.push(a),e)}function ud(e){var t=Ke(e.target);if(null!==t){var n=L(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=B(n)))return e.blockedOn=t,void function(e,t){var n=V.p;try{return V.p=e,t()}finally{V.p=n}}(e.priority,(function(){if(13===n.tag){var e=Ac(),t=Tr(n,e);null!==t&&_c(t,0,e),Vh(n,e)}}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function cd(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Xh(e.nativeEvent);if(null!==n)return null!==(t=Xe(n))&&Gh(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);At=r,n.target.dispatchEvent(r),At=null,t.shift()}return!0}function ld(e,t,n){cd(e)&&n.delete(t)}function hd(){Jh=!1,null!==$h&&cd($h)&&($h=null),null!==ed&&cd(ed)&&(ed=null),null!==td&&cd(td)&&(td=null),nd.forEach(ld),rd.forEach(ld)}function dd(e,t){e.blockedOn===t&&(e.blockedOn=null,Jh||(Jh=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,hd)))}var pd=null;function fd(e){pd!==e&&(pd=e,r.unstable_scheduleCallback(r.unstable_NormalPriority,(function(){pd===e&&(pd=null);for(var t=0;t<e.length;t+=3){var n=e[t],r=e[t+1],a=e[t+2];if("function"!==typeof r){if(null===Qh(r||n))continue;break}var o=Xe(n);null!==o&&(e.splice(t,3),t-=3,hi(o,{pending:!0,data:a,method:n.method,action:r},r,a))}})))}function md(e){function t(t){return dd(t,e)}null!==$h&&dd($h,e),null!==ed&&dd(ed,e),null!==td&&dd(td,e),nd.forEach(t),rd.forEach(t);for(var n=0;n<ad.length;n++){var r=ad[n];r.blockedOn===e&&(r.blockedOn=null)}for(;0<ad.length&&null===(n=ad[0]).blockedOn;)ud(n),null===n.blockedOn&&ad.shift();if(null!=(n=(e.ownerDocument||e).$$reactFormReplay))for(r=0;r<n.length;r+=3){var a=n[r],o=n[r+1],i=a[Pe]||null;if("function"===typeof o)i||fd(n);else if(i){var s=null;if(o&&o.hasAttribute("formAction")){if(a=o,i=o[Pe]||null)s=i.formAction;else if(null!==Qh(a))continue}else s=i.action;"function"===typeof s?n[r+1]=s:(n.splice(r,3),r-=3),fd(n)}}}function gd(e){this._internalRoot=e}function yd(e){this._internalRoot=e}yd.prototype.render=gd.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(i(409));Wh(t.current,Ac(),e,t,null,null)},yd.prototype.unmount=gd.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;0===e.tag&&tl(),Wh(e.current,2,null,e,null,null),Bc(),t[We]=null}},yd.prototype.unstable_scheduleHydration=function(e){if(e){var t=ze();e={blockedOn:null,target:e,priority:t};for(var n=0;n<ad.length&&0!==t&&t<ad[n].priority;n++);ad.splice(n,0,e),0===n&&ud(e)}};var bd=a.version;if("19.0.0"!==bd)throw Error(i(527,bd,"19.0.0"));V.findDOMNode=function(e){var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(i(188));throw e=Object.keys(e).join(","),Error(i(268,e))}return e=function(e){var t=e.alternate;if(!t){if(null===(t=L(e)))throw Error(i(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(null===a)break;var o=a.alternate;if(null===o){if(null!==(r=a.return)){n=r;continue}break}if(a.child===o.child){for(o=a.child;o;){if(o===n)return P(a),e;if(o===r)return P(a),t;o=o.sibling}throw Error(i(188))}if(n.return!==r.return)n=a,r=o;else{for(var s=!1,u=a.child;u;){if(u===n){s=!0,n=a,r=o;break}if(u===r){s=!0,r=a,n=o;break}u=u.sibling}if(!s){for(u=o.child;u;){if(u===n){s=!0,n=o,r=a;break}if(u===r){s=!0,r=o,n=a;break}u=u.sibling}if(!s)throw Error(i(189))}}if(n.alternate!==r)throw Error(i(190))}if(3!==n.tag)throw Error(i(188));return n.stateNode.current===n?e:t}(t),e=null===(e=null!==e?W(e):null)?null:e.stateNode};var vd={bundleType:0,version:"19.0.0",rendererPackageName:"react-dom",currentDispatcherRef:A,findFiberByHostInstance:Ke,reconcilerVersion:"19.0.0"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var xd=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!xd.isDisabled&&xd.supportsFiber)try{ye=xd.inject(vd),be=xd}catch(kd){}}t.createRoot=function(e,t){if(!s(e))throw Error(i(299));var n=!1,r="",a=Oi,o=zi,u=Li;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onUncaughtError&&(a=t.onUncaughtError),void 0!==t.onCaughtError&&(o=t.onCaughtError),void 0!==t.onRecoverableError&&(u=t.onRecoverableError),void 0!==t.unstable_transitionCallbacks&&t.unstable_transitionCallbacks),t=Bh(e,1,!1,null,0,n,r,a,o,u,0,null),e[We]=t.current,_l(8===e.nodeType?e.parentNode:e),new gd(t)},t.hydrateRoot=function(e,t,n){if(!s(e))throw Error(i(299));var r=!1,a="",o=Oi,u=zi,c=Li,l=null;return null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(r=!0),void 0!==n.identifierPrefix&&(a=n.identifierPrefix),void 0!==n.onUncaughtError&&(o=n.onUncaughtError),void 0!==n.onCaughtError&&(u=n.onCaughtError),void 0!==n.onRecoverableError&&(c=n.onRecoverableError),void 0!==n.unstable_transitionCallbacks&&n.unstable_transitionCallbacks,void 0!==n.formState&&(l=n.formState)),(t=Bh(e,1,!0,t,0,r,a,o,u,c,0,l)).context=Ph(null),n=t.current,(a=Fs(r=Ac())).callback=null,_s(n,a,r),t.current.lanes=r,_e(t,r),ml(t),e[We]=t.current,_l(e),new yd(t)},t.version="19.0.0"},672:(e,t,n)=>{"use strict";var r=n(43);function a(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function o(){}var i={d:{f:o,r:function(){throw Error(a(522))},D:o,C:o,L:o,m:o,X:o,S:o,M:o},p:0,findDOMNode:null},s=Symbol.for("react.portal");var u=r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function c(e,t){return"font"===e?"":"string"===typeof t?"use-credentials"===t?t:"":void 0}t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=i,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType)throw Error(a(299));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:s,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.flushSync=function(e){var t=u.T,n=i.p;try{if(u.T=null,i.p=2,e)return e()}finally{u.T=t,i.p=n,i.d.f()}},t.preconnect=function(e,t){"string"===typeof e&&(t?t="string"===typeof(t=t.crossOrigin)?"use-credentials"===t?t:"":void 0:t=null,i.d.C(e,t))},t.prefetchDNS=function(e){"string"===typeof e&&i.d.D(e)},t.preinit=function(e,t){if("string"===typeof e&&t&&"string"===typeof t.as){var n=t.as,r=c(n,t.crossOrigin),a="string"===typeof t.integrity?t.integrity:void 0,o="string"===typeof t.fetchPriority?t.fetchPriority:void 0;"style"===n?i.d.S(e,"string"===typeof t.precedence?t.precedence:void 0,{crossOrigin:r,integrity:a,fetchPriority:o}):"script"===n&&i.d.X(e,{crossOrigin:r,integrity:a,fetchPriority:o,nonce:"string"===typeof t.nonce?t.nonce:void 0})}},t.preinitModule=function(e,t){if("string"===typeof e)if("object"===typeof t&&null!==t){if(null==t.as||"script"===t.as){var n=c(t.as,t.crossOrigin);i.d.M(e,{crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0})}}else null==t&&i.d.M(e)},t.preload=function(e,t){if("string"===typeof e&&"object"===typeof t&&null!==t&&"string"===typeof t.as){var n=t.as,r=c(n,t.crossOrigin);i.d.L(e,n,{crossOrigin:r,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0,type:"string"===typeof t.type?t.type:void 0,fetchPriority:"string"===typeof t.fetchPriority?t.fetchPriority:void 0,referrerPolicy:"string"===typeof t.referrerPolicy?t.referrerPolicy:void 0,imageSrcSet:"string"===typeof t.imageSrcSet?t.imageSrcSet:void 0,imageSizes:"string"===typeof t.imageSizes?t.imageSizes:void 0,media:"string"===typeof t.media?t.media:void 0})}},t.preloadModule=function(e,t){if("string"===typeof e)if(t){var n=c(t.as,t.crossOrigin);i.d.m(e,{as:"string"===typeof t.as&&"script"!==t.as?t.as:void 0,crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0})}else i.d.m(e)},t.requestFormReset=function(e){i.d.r(e)},t.unstable_batchedUpdates=function(e,t){return e(t)},t.useFormState=function(e,t,n){return u.H.useFormState(e,t,n)},t.useFormStatus=function(){return u.H.useHostTransitionStatus()},t.version="19.0.0"},391:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(4)},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(672)},799:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element");function r(e,t,r){var a=null;if(void 0!==r&&(a=""+r),void 0!==t.key&&(a=""+t.key),"key"in t)for(var o in r={},t)"key"!==o&&(r[o]=t[o]);else r=t;return t=r.ref,{$$typeof:n,type:e,key:a,ref:void 0!==t?t:null,props:r}}Symbol.for("react.fragment"),t.jsx=r,t.jsxs=r},288:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),s=Symbol.for("react.consumer"),u=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var x=v.prototype=new b;x.constructor=v,m(x,y.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k={H:null,A:null,T:null,S:null},C=Object.prototype.hasOwnProperty;function D(e,t,r,a,o,i){return r=i.ref,{$$typeof:n,type:e,key:t,ref:void 0!==r?r:null,props:i}}function S(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var E=/\/+/g;function I(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function N(){}function T(e,t,a,o,i){var s=typeof e;"undefined"!==s&&"boolean"!==s||(e=null);var u,c,l=!1;if(null===e)l=!0;else switch(s){case"bigint":case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case r:l=!0;break;case d:return T((l=e._init)(e._payload),t,a,o,i)}}if(l)return i=i(e),l=""===o?"."+I(e,0):o,w(i)?(a="",null!=l&&(a=l.replace(E,"$&/")+"/"),T(i,t,a,"",(function(e){return e}))):null!=i&&(S(i)&&(u=i,c=a+(null==i.key||e&&e.key===i.key?"":(""+i.key).replace(E,"$&/")+"/")+l,i=D(u.type,c,void 0,0,0,u.props)),t.push(i)),1;l=0;var h,f=""===o?".":o+":";if(w(e))for(var m=0;m<e.length;m++)l+=T(o=e[m],t,a,s=f+I(o,m),i);else if("function"===typeof(m=null===(h=e)||"object"!==typeof h?null:"function"===typeof(h=p&&h[p]||h["@@iterator"])?h:null))for(e=m.call(e),m=0;!(o=e.next()).done;)l+=T(o=o.value,t,a,s=f+I(o,m++),i);else if("object"===s){if("function"===typeof e.then)return T(function(e){switch(e.status){case"fulfilled":return e.value;case"rejected":throw e.reason;default:switch("string"===typeof e.status?e.then(N,N):(e.status="pending",e.then((function(t){"pending"===e.status&&(e.status="fulfilled",e.value=t)}),(function(t){"pending"===e.status&&(e.status="rejected",e.reason=t)}))),e.status){case"fulfilled":return e.value;case"rejected":throw e.reason}}throw e}(e),t,a,o,i);throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.")}return l}function A(e,t,n){if(null==e)return e;var r=[],a=0;return T(e,r,"","",(function(e){return t.call(n,e,a++)})),r}function F(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var _="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function R(){}t.Children={map:A,forEach:function(e,t,n){A(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return A(e,(function(){t++})),t},toArray:function(e){return A(e,(function(e){return e}))||[]},only:function(e){if(!S(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=a,t.Profiler=i,t.PureComponent=v,t.StrictMode=o,t.Suspense=l,t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=k,t.act=function(){throw Error("act(...) is not supported in production builds of React.")},t.cache=function(e){return function(){return e.apply(null,arguments)}},t.cloneElement=function(e,t,n){if(null===e||void 0===e)throw Error("The argument must be a React element, but you passed "+e+".");var r=m({},e.props),a=e.key;if(null!=t)for(o in void 0!==t.ref&&void 0,void 0!==t.key&&(a=""+t.key),t)!C.call(t,o)||"key"===o||"__self"===o||"__source"===o||"ref"===o&&void 0===t.ref||(r[o]=t[o]);var o=arguments.length-2;if(1===o)r.children=n;else if(1<o){for(var i=Array(o),s=0;s<o;s++)i[s]=arguments[s+2];r.children=i}return D(e.type,a,void 0,0,0,r)},t.createContext=function(e){return(e={$$typeof:u,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider=e,e.Consumer={$$typeof:s,_context:e},e},t.createElement=function(e,t,n){var r,a={},o=null;if(null!=t)for(r in void 0!==t.key&&(o=""+t.key),t)C.call(t,r)&&"key"!==r&&"__self"!==r&&"__source"!==r&&(a[r]=t[r]);var i=arguments.length-2;if(1===i)a.children=n;else if(1<i){for(var s=Array(i),u=0;u<i;u++)s[u]=arguments[u+2];a.children=s}if(e&&e.defaultProps)for(r in i=e.defaultProps)void 0===a[r]&&(a[r]=i[r]);return D(e,o,void 0,0,0,a)},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:c,render:e}},t.isValidElement=S,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:F}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=k.T,n={};k.T=n;try{var r=e(),a=k.S;null!==a&&a(n,r),"object"===typeof r&&null!==r&&"function"===typeof r.then&&r.then(R,_)}catch(o){_(o)}finally{k.T=t}},t.unstable_useCacheRefresh=function(){return k.H.useCacheRefresh()},t.use=function(e){return k.H.use(e)},t.useActionState=function(e,t,n){return k.H.useActionState(e,t,n)},t.useCallback=function(e,t){return k.H.useCallback(e,t)},t.useContext=function(e){return k.H.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e,t){return k.H.useDeferredValue(e,t)},t.useEffect=function(e,t){return k.H.useEffect(e,t)},t.useId=function(){return k.H.useId()},t.useImperativeHandle=function(e,t,n){return k.H.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return k.H.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return k.H.useLayoutEffect(e,t)},t.useMemo=function(e,t){return k.H.useMemo(e,t)},t.useOptimistic=function(e,t){return k.H.useOptimistic(e,t)},t.useReducer=function(e,t,n){return k.H.useReducer(e,t,n)},t.useRef=function(e){return k.H.useRef(e)},t.useState=function(e){return k.H.useState(e)},t.useSyncExternalStore=function(e,t,n){return k.H.useSyncExternalStore(e,t,n)},t.useTransition=function(){return k.H.useTransition()},t.version="19.0.0"},43:(e,t,n)=>{"use strict";e.exports=n(288)},579:(e,t,n)=>{"use strict";e.exports=n(799)},896:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,a=e[r];if(!(0<o(a,t)))break e;e[r]=t,e[n]=a,n=r}}function r(e){return 0===e.length?null:e[0]}function a(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,a=e.length,i=a>>>1;r<i;){var s=2*(r+1)-1,u=e[s],c=s+1,l=e[c];if(0>o(u,n))c<a&&0>o(l,u)?(e[r]=l,e[c]=n,r=c):(e[r]=u,e[s]=n,r=s);else{if(!(c<a&&0>o(l,n)))break e;e[r]=l,e[c]=n,r=c}}}return t}function o(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if(t.unstable_now=void 0,"object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var s=Date,u=s.now();t.unstable_now=function(){return s.now()-u}}var c=[],l=[],h=1,d=null,p=3,f=!1,m=!1,g=!1,y="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function x(e){for(var t=r(l);null!==t;){if(null===t.callback)a(l);else{if(!(t.startTime<=e))break;a(l),t.sortIndex=t.expirationTime,n(c,t)}t=r(l)}}function w(e){if(g=!1,x(e),!m)if(null!==r(c))m=!0,F();else{var t=r(l);null!==t&&_(w,t.startTime-e)}}var k,C=!1,D=-1,S=5,E=-1;function I(){return!(t.unstable_now()-E<S)}function N(){if(C){var e=t.unstable_now();E=e;var n=!0;try{e:{m=!1,g&&(g=!1,b(D),D=-1),f=!0;var o=p;try{t:{for(x(e),d=r(c);null!==d&&!(d.expirationTime>e&&I());){var i=d.callback;if("function"===typeof i){d.callback=null,p=d.priorityLevel;var s=i(d.expirationTime<=e);if(e=t.unstable_now(),"function"===typeof s){d.callback=s,x(e),n=!0;break t}d===r(c)&&a(c),x(e)}else a(c);d=r(c)}if(null!==d)n=!0;else{var u=r(l);null!==u&&_(w,u.startTime-e),n=!1}}break e}finally{d=null,p=o,f=!1}n=void 0}}finally{n?k():C=!1}}}if("function"===typeof v)k=function(){v(N)};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,A=T.port2;T.port1.onmessage=N,k=function(){A.postMessage(null)}}else k=function(){y(N,0)};function F(){C||(C=!0,k())}function _(e,n){D=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,F())},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):S=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return r(c)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,a,o){var i=t.unstable_now();switch("object"===typeof o&&null!==o?o="number"===typeof(o=o.delay)&&0<o?i+o:i:o=i,e){case 1:var s=-1;break;case 2:s=250;break;case 5:s=1073741823;break;case 4:s=1e4;break;default:s=5e3}return e={id:h++,callback:a,priorityLevel:e,startTime:o,expirationTime:s=o+s,sortIndex:-1},o>i?(e.sortIndex=o,n(l,e),null===r(c)&&e===r(l)&&(g?(b(D),D=-1):g=!0,_(w,o-i))):(e.sortIndex=s,n(c,e),m||f||(m=!0,F())),e},t.unstable_shouldYield=I,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},853:(e,t,n)=>{"use strict";e.exports=n(896)},334:(e,t,n)=>{var r=n(359),a=n(66),o=n(16),i=n(538),s=n(907),u=n(262),c=n(430);c.alea=r,c.xor128=a,c.xorwow=o,c.xorshift7=i,c.xor4096=s,c.tychei=u,e.exports=c},359:function(e,t,n){var r;!function(e,a){function o(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new o(e),r=t&&t.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,a))||(a.exports=r):this.alea=s}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var r;!function(e,a){function o(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,a))||(a.exports=r):this.tychei=s}(0,e=n.nmd(e),n.amdD)},66:function(e,t,n){var r;!function(e,a){function o(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,a))||(a.exports=r):this.xor128=s}(0,e=n.nmd(e),n.amdD)},907:function(e,t,n){var r;!function(e,a){function o(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,o=t.i;return t.w=r=r+1640531527|0,n=a[o+34&127],e=a[o=o+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[o]=n^e,t.i=o,n+(r^r>>>16)|0},function(e,t){var n,r,a,o,i,s=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),a=0,o=-32;o<u;++o)t&&(r^=t.charCodeAt((o+32)%t.length)),0===o&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(i=i+1640531527|0,a=0==(n=s[127&o]^=r+i)?a+1:0);for(a>=128&&(s[127&(t&&t.length||0)]=-1),a=127,o=512;o>0;--o)r=s[a+34&127],n=s[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[a]=r^n;e.w=i,e.X=s,e.i=a}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.X&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,a))||(a.exports=r):this.xor4096=s}(0,e=n.nmd(e),n.amdD)},538:function(e,t,n){var r;!function(e,a){function o(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.x&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,a))||(a.exports=r):this.xorshift7=s}(0,e=n.nmd(e),n.amdD)},16:function(e,t,n){var r;!function(e,a){function o(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new o(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,a))||(a.exports=r):this.xorwow=s}(0,e=n.nmd(e),n.amdD)},430:function(e,t,n){var r;!function(a,o,i){var s,u=256,c=i.pow(u,6),l=i.pow(2,52),h=2*l,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(o)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(u):(e=new Uint8Array(u),(a.crypto||a.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=a.navigator,n=t&&t.plugins;return[+new Date,a,n,a.screen,b(o)]}}():e,3),r),p=new f(r),v=function(){for(var e=p.g(6),t=c,n=0;e<l;)e=(e+n)*u,t*=u,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),o),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(v,d,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,a=0,o=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);a<u;)i[a]=a++;for(a=0;a<u;a++)i[a]=i[o=d&o+e[a%n]+(t=i[a])],i[o]=t;(r.g=function(e){for(var t,n=0,a=r.i,o=r.j,i=r.S;e--;)t=i[a=d&a+1],n=n*u+i[d&(i[a]=i[o=d&o+t])+(i[o]=t)];return r.i=a,r.j=o,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(g(e[n],t-1))}catch(o){}return r.length?r:"string"==a?e:e+"\0"}function y(e,t){for(var n,r=e+"",a=0;a<r.length;)t[d&a]=d&(n^=19*t[d&a])+r.charCodeAt(a++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),o),e.exports){e.exports=p;try{s=n(234)}catch(v){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},817:()=>{},590:()=>{},530:()=>{},108:()=>{},551:()=>{},234:()=>{},422:function(e){e.exports=function(){"use strict";function e(){return!0}function t(){return!1}function n(){}const r="Argument is not a typed-function.";function a(){function o(e){return"object"===typeof e&&null!==e&&e.constructor===Object}const i=[{name:"number",test:function(e){return"number"===typeof e}},{name:"string",test:function(e){return"string"===typeof e}},{name:"boolean",test:function(e){return"boolean"===typeof e}},{name:"Function",test:function(e){return"function"===typeof e}},{name:"Array",test:Array.isArray},{name:"Date",test:function(e){return e instanceof Date}},{name:"RegExp",test:function(e){return e instanceof RegExp}},{name:"Object",test:o},{name:"null",test:function(e){return null===e}},{name:"undefined",test:function(e){return void 0===e}}],s={name:"any",test:e,isAny:!0};let u,c,l=0,h={createCount:0};function d(e){const t=u.get(e);if(t)return t;let n='Unknown type "'+e+'"';const r=e.toLowerCase();let a;for(a of c)if(a.toLowerCase()===r){n+='. Did you mean "'+a+'" ?';break}throw new TypeError(n)}function p(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"any";const n=t?d(t).index:c.length,r=[];for(let o=0;o<e.length;++o){if(!e[o]||"string"!==typeof e[o].name||"function"!==typeof e[o].test)throw new TypeError("Object with properties {name: string, test: function} expected");const t=e[o].name;if(u.has(t))throw new TypeError('Duplicate type name "'+t+'"');r.push(t),u.set(t,{name:t,test:e[o].test,isAny:e[o].isAny,index:n+o,conversionsTo:[]})}const a=c.slice(n);c=c.slice(0,n).concat(r).concat(a);for(let o=n+r.length;o<c.length;++o)u.get(c[o]).index=o}function f(){u=new Map,c=[],l=0,p([s],!1)}function m(){let e;for(e of c)u.get(e).conversionsTo=[];l=0}function g(e){const t=c.filter((t=>{const n=u.get(t);return!n.isAny&&n.test(e)}));return t.length?t:["any"]}function y(e){return e&&"function"===typeof e&&"_typedFunctionData"in e}function b(e,t,n){if(!y(e))throw new TypeError(r);const a=n&&n.exact,o=S(Array.isArray(t)?t.join(","):t),i=w(o);if(!a||i in e.signatures){const t=e._typedFunctionData.signatureMap.get(i);if(t)return t}const s=o.length;let u,c;if(a){let t;for(t in u=[],e.signatures)u.push(e._typedFunctionData.signatureMap.get(t))}else u=e._typedFunctionData.signatures;for(let r=0;r<s;++r){const e=o[r],t=[];let n;for(n of u){const a=T(n.params,r);if(a&&(!e.restParam||a.restParam)){if(!a.hasAny){const t=D(a);if(e.types.some((e=>!t.has(e.name))))continue}t.push(n)}}if(u=t,0===u.length)break}for(c of u)if(c.params.length<=s)return c;throw new TypeError("Signature not found (signature: "+(e.name||"unnamed")+"("+w(o,", ")+"))")}function v(e,t,n){return b(e,t,n).implementation}function x(e,t){const n=d(t);if(n.test(e))return e;const r=n.conversionsTo;if(0===r.length)throw new Error("There are no conversions to "+t+" defined.");for(let a=0;a<r.length;a++)if(d(r[a].from).test(e))return r[a].convert(e);throw new Error("Cannot convert "+e+" to "+t)}function w(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:",";return e.map((e=>e.name)).join(t)}function k(e){const t=0===e.indexOf("..."),n=(t?e.length>3?e.slice(3):"any":e).split("|").map((e=>d(e.trim())));let r=!1,a=t?"...":"";return{types:n.map((function(e){return r=e.isAny||r,a+=e.name+"|",{name:e.name,typeIndex:e.index,test:e.test,isAny:e.isAny,conversion:null,conversionIndex:-1}})),name:a.slice(0,-1),hasAny:r,hasConversion:!1,restParam:t}}function C(e){const t=B(e.types.map((e=>e.name)));let n=e.hasAny,r=e.name;const a=t.map((function(e){const t=d(e.from);return n=t.isAny||n,r+="|"+e.from,{name:e.from,typeIndex:t.index,test:t.test,isAny:t.isAny,conversion:e,conversionIndex:e.index}}));return{types:e.types.concat(a),name:r,hasAny:n,hasConversion:a.length>0,restParam:e.restParam}}function D(e){return e.typeSet||(e.typeSet=new Set,e.types.forEach((t=>e.typeSet.add(t.name)))),e.typeSet}function S(e){const t=[];if("string"!==typeof e)throw new TypeError("Signatures must be strings");const n=e.trim();if(""===n)return t;const r=n.split(",");for(let a=0;a<r.length;++a){const e=k(r[a].trim());if(e.restParam&&a!==r.length-1)throw new SyntaxError('Unexpected rest parameter "'+r[a]+'": only allowed for the last parameter');if(0===e.types.length)return null;t.push(e)}return t}function E(e){const t=Q(e);return!!t&&t.restParam}function I(t){if(t&&0!==t.types.length){if(1===t.types.length)return d(t.types[0].name).test;if(2===t.types.length){const e=d(t.types[0].name).test,n=d(t.types[1].name).test;return function(t){return e(t)||n(t)}}{const e=t.types.map((function(e){return d(e.name).test}));return function(t){for(let n=0;n<e.length;n++)if(e[n](t))return!0;return!1}}}return e}function N(e){let t,n,r;if(E(e)){t=Y(e).map(I);const n=t.length,r=I(Q(e)),a=function(e){for(let t=n;t<e.length;t++)if(!r(e[t]))return!1;return!0};return function(e){for(let n=0;n<t.length;n++)if(!t[n](e[n]))return!1;return a(e)&&e.length>=n+1}}return 0===e.length?function(e){return 0===e.length}:1===e.length?(n=I(e[0]),function(e){return n(e[0])&&1===e.length}):2===e.length?(n=I(e[0]),r=I(e[1]),function(e){return n(e[0])&&r(e[1])&&2===e.length}):(t=e.map(I),function(e){for(let n=0;n<t.length;n++)if(!t[n](e[n]))return!1;return e.length===t.length})}function T(e,t){return t<e.length?e[t]:E(e)?Q(e):null}function A(e,t){const n=T(e,t);return n?D(n):new Set}function F(e){return null===e.conversion||void 0===e.conversion}function _(e,t){const n=new Set;return e.forEach((e=>{const r=A(e.params,t);let a;for(a of r)n.add(a)})),n.has("any")?["any"]:Array.from(n)}function R(e,t,n){let r,a;const o=e||"unnamed";let i,s=n;for(i=0;i<t.length;i++){const e=[];if(s.forEach((n=>{const r=I(T(n.params,i));(i<n.params.length||E(n.params))&&r(t[i])&&e.push(n)})),0===e.length){if(a=_(s,i),a.length>0){const e=g(t[i]);return r=new TypeError("Unexpected type of argument in function "+o+" (expected: "+a.join(" or ")+", actual: "+e.join(" | ")+", index: "+i+")"),r.data={category:"wrongType",fn:o,index:i,actual:e,expected:a},r}}else s=e}const u=s.map((function(e){return E(e.params)?1/0:e.params.length}));if(t.length<Math.min.apply(null,u))return a=_(s,i),r=new TypeError("Too few arguments in function "+o+" (expected: "+a.join(" or ")+", index: "+t.length+")"),r.data={category:"tooFewArgs",fn:o,index:t.length,expected:a},r;const c=Math.max.apply(null,u);if(t.length>c)return r=new TypeError("Too many arguments in function "+o+" (expected: "+c+", actual: "+t.length+")"),r.data={category:"tooManyArgs",fn:o,index:t.length,expectedLength:c},r;const l=[];for(let h=0;h<t.length;++h)l.push(g(t[h]).join("|"));return r=new TypeError('Arguments of type "'+l.join(", ")+'" do not match any of the defined signatures of function '+o+"."),r.data={category:"mismatch",actual:l},r}function M(e){let t=c.length+1;for(let n=0;n<e.types.length;n++)F(e.types[n])&&(t=Math.min(t,e.types[n].typeIndex));return t}function O(e){let t=l+1;for(let n=0;n<e.types.length;n++)F(e.types[n])||(t=Math.min(t,e.types[n].conversionIndex));return t}function z(e,t){if(e.hasAny){if(!t.hasAny)return 1}else if(t.hasAny)return-1;if(e.restParam){if(!t.restParam)return 1}else if(t.restParam)return-1;if(e.hasConversion){if(!t.hasConversion)return 1}else if(t.hasConversion)return-1;const n=M(e)-M(t);if(n<0)return-1;if(n>0)return 1;const r=O(e)-O(t);return r<0?-1:r>0?1:0}function L(e,t){const n=e.params,r=t.params,a=Q(n),o=Q(r),i=E(n),s=E(r);if(i&&a.hasAny){if(!s||!o.hasAny)return 1}else if(s&&o.hasAny)return-1;let u,c=0,l=0;for(u of n)u.hasAny&&++c,u.hasConversion&&++l;let h=0,d=0;for(u of r)u.hasAny&&++h,u.hasConversion&&++d;if(c!==h)return c-h;if(i&&a.hasConversion){if(!s||!o.hasConversion)return 1}else if(s&&o.hasConversion)return-1;if(l!==d)return l-d;if(i){if(!s)return 1}else if(s)return-1;const p=(n.length-r.length)*(i?-1:1);if(0!==p)return p;const f=[];let m,g=0;for(let y=0;y<n.length;++y){const e=z(n[y],r[y]);f.push(e),g+=e}if(0!==g)return g;for(m of f)if(0!==m)return m;return 0}function B(e){if(0===e.length)return[];const t=e.map(d);e.length>1&&t.sort(((e,t)=>e.index-t.index));let n=t[0].conversionsTo;if(1===e.length)return n;n=n.concat([]);const r=new Set(e);for(let a=1;a<t.length;++a){let e;for(e of t[a].conversionsTo)r.has(e.from)||(n.push(e),r.add(e.from))}return n}function P(e,t){let n=t;if(e.some((e=>e.hasConversion))){const r=E(e),a=e.map(W);n=function(){const e=[],n=r?arguments.length-1:arguments.length;for(let t=0;t<n;t++)e[t]=a[t](arguments[t]);return r&&(e[n]=arguments[n].map(a[n])),t.apply(this,e)}}let r=n;if(E(e)){const t=e.length-1;r=function(){return n.apply(this,Z(arguments,0,t).concat([Z(arguments,t)]))}}return r}function W(e){let t,n,r,a;const o=[],i=[];switch(e.types.forEach((function(e){e.conversion&&(o.push(d(e.conversion.from).test),i.push(e.conversion.convert))})),i.length){case 0:return function(e){return e};case 1:return t=o[0],r=i[0],function(e){return t(e)?r(e):e};case 2:return t=o[0],n=o[1],r=i[0],a=i[1],function(e){return t(e)?r(e):n(e)?a(e):e};default:return function(e){for(let t=0;t<i.length;t++)if(o[t](e))return i[t](e);return e}}}function U(e){function t(e,n,r){if(n<e.length){const a=e[n];let o=[];if(a.restParam){const e=a.types.filter(F);e.length<a.types.length&&o.push({types:e,name:"..."+e.map((e=>e.name)).join("|"),hasAny:e.some((e=>e.isAny)),hasConversion:!1,restParam:!0}),o.push(a)}else o=a.types.map((function(e){return{types:[e],name:e.name,hasAny:e.isAny,hasConversion:e.conversion,restParam:!1}}));return $(o,(function(a){return t(e,n+1,r.concat([a]))}))}return[r]}return t(e,0,[])}function V(e,t){const n=Math.max(e.length,t.length);for(let s=0;s<n;s++){const n=A(e,s),r=A(t,s);let a,o=!1;for(a of r)if(n.has(a)){o=!0;break}if(!o)return!1}const r=e.length,a=t.length,o=E(e),i=E(t);return o?i?r===a:a>=r:i?r>=a:r===a}function G(e){return e.map((e=>ae(e)?ne(e.referToSelf.callback):re(e)?te(e.referTo.references,e.referTo.callback):e))}function j(e,t,n){const r=[];let a;for(a of e){let e=n[a];if("number"!==typeof e)throw new TypeError('No definition for referenced signature "'+a+'"');if(e=t[e],"function"!==typeof e)return!1;r.push(e)}return r}function H(e,t,n){const r=G(e),a=new Array(r.length).fill(!1);let o=!0;for(;o;){o=!1;let e=!0;for(let i=0;i<r.length;++i){if(a[i])continue;const s=r[i];if(ae(s))r[i]=s.referToSelf.callback(n),r[i].referToSelf=s.referToSelf,a[i]=!0,e=!1;else if(re(s)){const n=j(s.referTo.references,r,t);n?(r[i]=s.referTo.callback.apply(this,n),r[i].referTo=s.referTo,a[i]=!0,e=!1):o=!0}}if(e&&o)throw new SyntaxError("Circular reference detected in resolving typed.referTo")}return r}function q(e){const t=/\bthis(\(|\.signatures\b)/;Object.keys(e).forEach((n=>{const r=e[n];if(t.test(r.toString()))throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.")}))}function K(e,r){if(h.createCount++,0===Object.keys(r).length)throw new SyntaxError("No signatures provided");h.warnAgainstDeprecatedThis&&q(r);const a=[],o=[],i={},s=[];let u;for(u in r){if(!Object.prototype.hasOwnProperty.call(r,u))continue;const e=S(u);if(!e)continue;a.forEach((function(t){if(V(t,e))throw new TypeError('Conflicting signatures "'+w(t)+'" and "'+w(e)+'".')})),a.push(e);const t=o.length;o.push(r[u]);const n=e.map(C);let c;for(c of U(n)){const e=w(c);s.push({params:c,name:e,fn:t}),c.every((e=>!e.hasConversion))&&(i[e]=t)}}s.sort(L);const c=H(o,i,ue);let l;for(l in i)Object.prototype.hasOwnProperty.call(i,l)&&(i[l]=c[i[l]]);const d=[],p=new Map;for(l of s)p.has(l.name)||(l.fn=c[l.fn],d.push(l),p.set(l.name,l));const f=d[0]&&d[0].params.length<=2&&!E(d[0].params),m=d[1]&&d[1].params.length<=2&&!E(d[1].params),g=d[2]&&d[2].params.length<=2&&!E(d[2].params),y=d[3]&&d[3].params.length<=2&&!E(d[3].params),b=d[4]&&d[4].params.length<=2&&!E(d[4].params),v=d[5]&&d[5].params.length<=2&&!E(d[5].params),x=f&&m&&g&&y&&b&&v;for(let t=0;t<d.length;++t)d[t].test=N(d[t].params);const k=f?I(d[0].params[0]):t,D=m?I(d[1].params[0]):t,T=g?I(d[2].params[0]):t,A=y?I(d[3].params[0]):t,F=b?I(d[4].params[0]):t,_=v?I(d[5].params[0]):t,R=f?I(d[0].params[1]):t,M=m?I(d[1].params[1]):t,O=g?I(d[2].params[1]):t,z=y?I(d[3].params[1]):t,B=b?I(d[4].params[1]):t,W=v?I(d[5].params[1]):t;for(let t=0;t<d.length;++t)d[t].implementation=P(d[t].params,d[t].fn);const G=f?d[0].implementation:n,j=m?d[1].implementation:n,K=g?d[2].implementation:n,X=y?d[3].implementation:n,Y=b?d[4].implementation:n,Q=v?d[5].implementation:n,Z=f?d[0].params.length:-1,J=m?d[1].params.length:-1,$=g?d[2].params.length:-1,ee=y?d[3].params.length:-1,te=b?d[4].params.length:-1,ne=v?d[5].params.length:-1,re=x?6:0,ae=d.length,oe=d.map((e=>e.test)),ie=d.map((e=>e.implementation)),se=function(){for(let e=re;e<ae;e++)if(oe[e](arguments))return ie[e].apply(this,arguments);return h.onMismatch(e,arguments,d)};function ue(e,t){return arguments.length===Z&&k(e)&&R(t)?G.apply(this,arguments):arguments.length===J&&D(e)&&M(t)?j.apply(this,arguments):arguments.length===$&&T(e)&&O(t)?K.apply(this,arguments):arguments.length===ee&&A(e)&&z(t)?X.apply(this,arguments):arguments.length===te&&F(e)&&B(t)?Y.apply(this,arguments):arguments.length===ne&&_(e)&&W(t)?Q.apply(this,arguments):se.apply(this,arguments)}try{Object.defineProperty(ue,"name",{value:e})}catch(ce){}return ue.signatures=i,ue._typedFunctionData={signatures:d,signatureMap:p},ue}function X(e,t,n){throw R(e,t,n)}function Y(e){return Z(e,0,e.length-1)}function Q(e){return e[e.length-1]}function Z(e,t,n){return Array.prototype.slice.call(e,t,n)}function J(e,t){for(let n=0;n<e.length;n++)if(t(e[n]))return e[n]}function $(e,t){return Array.prototype.concat.apply([],e.map(t))}function ee(){const e=Y(arguments).map((e=>w(S(e)))),t=Q(arguments);if("function"!==typeof t)throw new TypeError("Callback function expected as last argument");return te(e,t)}function te(e,t){return{referTo:{references:e,callback:t}}}function ne(e){if("function"!==typeof e)throw new TypeError("Callback function expected as first argument");return{referToSelf:{callback:e}}}function re(e){return e&&"object"===typeof e.referTo&&Array.isArray(e.referTo.references)&&"function"===typeof e.referTo.callback}function ae(e){return e&&"object"===typeof e.referToSelf&&"function"===typeof e.referToSelf.callback}function oe(e,t){if(!e)return t;if(t&&t!==e){const n=new Error("Function names do not match (expected: "+e+", actual: "+t+")");throw n.data={actual:t,expected:e},n}return e}function ie(e){let t;for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&(y(e[n])||"string"===typeof e[n].signature)&&(t=oe(t,e[n].name));return t}function se(e,t){let n;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)){if(n in e&&t[n]!==e[n]){const r=new Error('Signature "'+n+'" is defined twice');throw r.data={signature:n,sourceFunction:t[n],destFunction:e[n]},r}e[n]=t[n]}}f(),p(i);const ue=h;function ce(e){if(!e||"string"!==typeof e.from||"string"!==typeof e.to||"function"!==typeof e.convert)throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");if(e.to===e.from)throw new SyntaxError('Illegal to define conversion from "'+e.from+'" to itself.')}return h=function(e){const t="string"===typeof e;let n=t?e:"";const r={};for(let a=t?1:0;a<arguments.length;++a){const e=arguments[a];let i,s={};if("function"===typeof e?(i=e.name,"string"===typeof e.signature?s[e.signature]=e:y(e)&&(s=e.signatures)):o(e)&&(s=e,t||(i=ie(e))),0===Object.keys(s).length){const t=new TypeError("Argument to 'typed' at index "+a+" is not a (typed) function, nor an object with signatures as keys and functions as values.");throw t.data={index:a,argument:e},t}t||(n=oe(n,i)),se(r,s)}return K(n||"",r)},h.create=a,h.createCount=ue.createCount,h.onMismatch=X,h.throwMismatchError=X,h.createError=R,h.clear=f,h.clearConversions=m,h.addTypes=p,h._findType=d,h.referTo=ee,h.referToSelf=ne,h.convert=x,h.findSignature=b,h.find=v,h.isTypedFunction=y,h.warnAgainstDeprecatedThis=!0,h.addType=function(e,t){let n="any";!1!==t&&u.has("Object")&&(n="Object"),h.addTypes([e],n)},h.addConversion=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{override:!1};ce(e);const n=d(e.to),r=n.conversionsTo.find((t=>t.from===e.from));if(r){if(!t||!t.override)throw new Error('There is already a conversion from "'+e.from+'" to "'+n.name+'"');h.removeConversion({from:r.from,to:e.to,convert:r.convert})}n.conversionsTo.push({from:e.from,convert:e.convert,index:l++})},h.addConversions=function(e,t){e.forEach((e=>h.addConversion(e,t)))},h.removeConversion=function(e){ce(e);const t=d(e.to),n=J(t.conversionsTo,(t=>t.from===e.from));if(!n)throw new Error("Attempt to remove nonexistent conversion from "+e.from+" to "+e.to);if(n.convert!==e.convert)throw new Error("Conversion to remove does not match existing conversion");const r=t.conversionsTo.indexOf(n);t.conversionsTo.splice(r,1)},h.resolve=function(e,t){if(!y(e))throw new TypeError(r);const n=e._typedFunctionData.signatures;for(let r=0;r<n.length;++r)if(n[r].test(t))return n[r];return null},h}return a()}()}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={id:e,loaded:!1,exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__webpack_require__),n.loaded=!0,n.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.amdD=function(){throw new Error("define cannot be used indirect")},__webpack_require__.amdO={},__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.f={},__webpack_require__.e=e=>Promise.all(Object.keys(__webpack_require__.f).reduce(((t,n)=>(__webpack_require__.f[n](e,t),t)),[])),__webpack_require__.u=e=>"static/js/"+e+".c525d7c0.chunk.js",__webpack_require__.miniCssF=e=>{},__webpack_require__.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e={},t="firstapp:";__webpack_require__.l=(n,r,a,o)=>{if(e[n])e[n].push(r);else{var i,s;if(void 0!==a)for(var u=document.getElementsByTagName("script"),c=0;c<u.length;c++){var l=u[c];if(l.getAttribute("src")==n||l.getAttribute("data-webpack")==t+a){i=l;break}}i||(s=!0,(i=document.createElement("script")).charset="utf-8",i.timeout=120,__webpack_require__.nc&&i.setAttribute("nonce",__webpack_require__.nc),i.setAttribute("data-webpack",t+a),i.src=n),e[n]=[r];var h=(t,r)=>{i.onerror=i.onload=null,clearTimeout(d);var a=e[n];if(delete e[n],i.parentNode&&i.parentNode.removeChild(i),a&&a.forEach((e=>e(r))),t)return t(r)},d=setTimeout(h.bind(null,void 0,{type:"timeout",target:i}),12e4);i.onerror=h.bind(null,i.onerror),i.onload=h.bind(null,i.onload),s&&document.head.appendChild(i)}}})(),__webpack_require__.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),__webpack_require__.p="./",(()=>{var e={792:0};__webpack_require__.f.j=(t,n)=>{var r=__webpack_require__.o(e,t)?e[t]:void 0;if(0!==r)if(r)n.push(r[2]);else{var a=new Promise(((n,a)=>r=e[t]=[n,a]));n.push(r[2]=a);var o=__webpack_require__.p+__webpack_require__.u(t),i=new Error;__webpack_require__.l(o,(n=>{if(__webpack_require__.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var a=n&&("load"===n.type?"missing":n.type),o=n&&n.target&&n.target.src;i.message="Loading chunk "+t+" failed.\n("+a+": "+o+")",i.name="ChunkLoadError",i.type=a,i.request=o,r[1](i)}}),"chunk-"+t,t)}};var t=(t,n)=>{var r,a,o=n[0],i=n[1],s=n[2],u=0;if(o.some((t=>0!==e[t]))){for(r in i)__webpack_require__.o(i,r)&&(__webpack_require__.m[r]=i[r]);if(s)s(__webpack_require__)}for(t&&t(n);u<o.length;u++)a=o[u],__webpack_require__.o(e,a)&&e[a]&&e[a][0](),e[a]=0},n=self.webpackChunkfirstapp=self.webpackChunkfirstapp||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})();var __webpack_exports__={};(()=>{"use strict";var e={};__webpack_require__.r(e),__webpack_require__.d(e,{assertParamsValid:()=>Vd,computeFlatOffset:()=>tp,computeOutShape:()=>jd,getNormalizedAxes:()=>Xd,isSliceContinous:()=>ep,maskToAxes:()=>Gd,parseSliceParams:()=>np,sliceInfo:()=>rp,startForAxis:()=>Jd,startIndicesWithElidedDims:()=>Yd,stopForAxis:()=>$d,stopIndicesWithElidedDims:()=>Qd,stridesForAxis:()=>Zd,stridesWithElidedDims:()=>Hd});var t={};__webpack_require__.r(t),__webpack_require__.d(t,{collectGatherOpShapeInfo:()=>wy,computeOutShape:()=>xy,segOpComputeOptimalWindowSize:()=>vy});var n={};__webpack_require__.r(n),__webpack_require__.d(n,{ERF_A1:()=>Lg,ERF_A2:()=>Bg,ERF_A3:()=>Pg,ERF_A4:()=>Wg,ERF_A5:()=>Ug,ERF_P:()=>zg,PARALLELIZE_THRESHOLD:()=>kg,RowPartitionType:()=>yg,SELU_SCALE:()=>Og,SELU_SCALEALPHA:()=>Mg,applyActivation:()=>xm,assertAndGetBroadcastShape:()=>Sd,assertAxesAreInnerMostDims:()=>ff,assertParamsConsistent:()=>mg,assignToTypedArray:()=>Kg,axesAreInnerMostDims:()=>lf,calculateShapes:()=>Rg,checkEinsumDimSizes:()=>ny,checkPadOnDimRoundingMode:()=>kp,combineLocations:()=>hf,combineRaggedTensorToTensorShapes:()=>bg,complexWithEvenIndex:()=>jg,complexWithOddIndex:()=>Hg,computeConv2DInfo:()=>hp,computeConv3DInfo:()=>dp,computeDefaultPad:()=>pp,computeDilation2DInfo:()=>up,computeOptimalWindowSize:()=>Cg,computeOutAndReduceShapes:()=>df,computeOutShape:()=>gg,computePool2DInfo:()=>cp,computePool3DInfo:()=>lp,convertConv2DDataFormat:()=>wp,decodeEinsumEquation:()=>ey,eitherStridesOrDilationsAreOne:()=>vp,expandShapeToKeepDim:()=>pf,exponent:()=>Yg,exponents:()=>Xg,fromStringArrayToUint8:()=>Cy,fromUint8ToStringArray:()=>ky,getAxesPermutation:()=>mf,getBroadcastDims:()=>Cd,getComplexWithIndex:()=>qg,getEinsumComputePath:()=>ry,getEinsumPermutation:()=>ty,getFusedBiasGradient:()=>vm,getFusedDyActivation:()=>bm,getImageCenter:()=>Dg,getInnerMostAxes:()=>yf,getPermuted:()=>Eg,getRaggedRank:()=>xg,getReductionAxes:()=>Dd,getReshaped:()=>Sg,getReshapedPermuted:()=>Ig,getRowPartitionTypesHelper:()=>vg,getSliceBeginCoords:()=>Ng,getSliceSize:()=>Tg,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>sy,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>uy,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>cy,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>dy,getSparseReshapeInputOutputMismatchErrorMessage:()=>fy,getSparseReshapeInputOutputMultipleErrorMessage:()=>py,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>ly,getSparseReshapeNegativeOutputDimErrorMessage:()=>hy,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>by,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>my,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>gy,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>yy,getUndoAxesPermutation:()=>gf,isIdentityPermutation:()=>ay,log:()=>Lc,mergeRealAndImagArrays:()=>Vg,prepareAndValidate:()=>Ag,prepareSplitSize:()=>iy,segment_util:()=>t,shouldFuse:()=>wm,slice_util:()=>e,splitRealAndImagArrays:()=>Gg,stridesOrDilationsArePositive:()=>xp,tupleValuesAreOne:()=>bp,upcastType:()=>Ol,validateDefaultValueShape:()=>wg,validateInput:()=>_g,validateUpdateShape:()=>Fg,warn:()=>zc});var r={};__webpack_require__.r(r),__webpack_require__.d(r,{mx:()=>dI,XI:()=>aN,Nk:()=>oN,f6:()=>sN,ct:()=>sI,YG:()=>lN,hH:()=>gN,z3:()=>eT,sG:()=>hT,uM:()=>gT,vS:()=>RT,qB:()=>UT,GG:()=>GT,lg:()=>XT,rq:()=>HT,cu:()=>sA,WR:()=>aA,GE:()=>lA,px:()=>dA,jC:()=>IA,He:()=>AA,hE:()=>WA,BF:()=>qN,Dk:()=>QA,cl:()=>aF,_B:()=>yF,ub:()=>kF,_f:()=>SF,Ku:()=>FF,qy:()=>RF,Zy:()=>HF,bu:()=>XF,zv:()=>JE,dH:()=>wI,HS:()=>eN,yH:()=>f_,l3:()=>g_,z9:()=>b_,x6:()=>C_,_m:()=>A_,eW:()=>O_,GK:()=>B_,SP:()=>U_,yr:()=>G_,dl:()=>kT,Dw:()=>Y_,xT:()=>$_,_X:()=>NI,wz:()=>iR});var a=__webpack_require__(43),o=__webpack_require__(391);function i(){return i=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},i.apply(null,arguments)}var s={relTol:1e-12,absTol:1e-15,matrix:"Matrix",number:"number",numberFallback:"number",precision:64,predictable:!1,randomSeed:null},u=["Matrix","Array"],c=["number","BigNumber","Fraction"];var l=function(e){if(e)throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");return Object.freeze(s)};i(l,s,{MATRIX_OPTIONS:u,NUMBER_OPTIONS:c});var h,d,p=9e15,f=1e9,m="0123456789abcdef",g="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",y="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",b={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-p,maxE:p,crypto:!1},v=!0,x="[DecimalError] ",w=x+"Invalid argument: ",k=x+"Precision limit exceeded",C=x+"crypto unavailable",D="[object Decimal]",S=Math.floor,E=Math.pow,I=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,N=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,T=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,A=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,F=1e7,_=g.length-1,R=y.length-1,M={toStringTag:D};function O(e){var t,n,r,a=e.length-1,o="",i=e[0];if(a>0){for(o+=i,t=1;t<a;t++)(n=7-(r=e[t]+"").length)&&(o+=q(n)),o+=r;(n=7-(r=(i=e[t])+"").length)&&(o+=q(n))}else if(0===i)return"0";for(;i%10===0;)i/=10;return o+i}function z(e,t,n){if(e!==~~e||e<t||e>n)throw Error(w+e)}function L(e,t,n,r){var a,o,i,s;for(o=e[0];o>=10;o/=10)--t;return--t<0?(t+=7,a=0):(a=Math.ceil((t+1)/7),t%=7),o=E(10,7-t),s=e[a]%o|0,null==r?t<3?(0==t?s=s/100|0:1==t&&(s=s/10|0),i=n<4&&99999==s||n>3&&49999==s||5e4==s||0==s):i=(n<4&&s+1==o||n>3&&s+1==o/2)&&(e[a+1]/o/100|0)==E(10,t-2)-1||(s==o/2||0==s)&&0==(e[a+1]/o/100|0):t<4?(0==t?s=s/1e3|0:1==t?s=s/100|0:2==t&&(s=s/10|0),i=(r||n<4)&&9999==s||!r&&n>3&&4999==s):i=((r||n<4)&&s+1==o||!r&&n>3&&s+1==o/2)&&(e[a+1]/o/1e3|0)==E(10,t-3)-1,i}function B(e,t,n){for(var r,a,o=[0],i=0,s=e.length;i<s;){for(a=o.length;a--;)o[a]*=t;for(o[0]+=m.indexOf(e.charAt(i++)),r=0;r<o.length;r++)o[r]>n-1&&(void 0===o[r+1]&&(o[r+1]=0),o[r+1]+=o[r]/n|0,o[r]%=n)}return o.reverse()}M.absoluteValue=M.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),W(e)},M.ceil=function(){return W(new this.constructor(this),this.e+1,2)},M.clampedTo=M.clamp=function(e,t){var n=this,r=n.constructor;if(e=new r(e),t=new r(t),!e.s||!t.s)return new r(NaN);if(e.gt(t))throw Error(w+t);return n.cmp(e)<0?e:n.cmp(t)>0?t:new r(n)},M.comparedTo=M.cmp=function(e){var t,n,r,a,o=this,i=o.d,s=(e=new o.constructor(e)).d,u=o.s,c=e.s;if(!i||!s)return u&&c?u!==c?u:i===s?0:!i^u<0?1:-1:NaN;if(!i[0]||!s[0])return i[0]?u:s[0]?-c:0;if(u!==c)return u;if(o.e!==e.e)return o.e>e.e^u<0?1:-1;for(t=0,n=(r=i.length)<(a=s.length)?r:a;t<n;++t)if(i[t]!==s[t])return i[t]>s[t]^u<0?1:-1;return r===a?0:r>a^u<0?1:-1},M.cosine=M.cos=function(){var e,t,n=this,r=n.constructor;return n.d?n.d[0]?(e=r.precision,t=r.rounding,r.precision=e+Math.max(n.e,n.sd())+7,r.rounding=1,n=function(e,t){var n,r,a;if(t.isZero())return t;r=t.d.length,r<32?a=(1/ne(4,n=Math.ceil(r/3))).toString():(n=16,a="2.3283064365386962890625e-10");e.precision+=n,t=te(e,1,t.times(a),new e(1));for(var o=n;o--;){var i=t.times(t);t=i.times(i).minus(i).times(8).plus(1)}return e.precision-=n,t}(r,re(r,n)),r.precision=e,r.rounding=t,W(2==d||3==d?n.neg():n,e,t,!0)):new r(1):new r(NaN)},M.cubeRoot=M.cbrt=function(){var e,t,n,r,a,o,i,s,u,c,l=this,h=l.constructor;if(!l.isFinite()||l.isZero())return new h(l);for(v=!1,(o=l.s*E(l.s*l,1/3))&&Math.abs(o)!=1/0?r=new h(o.toString()):(n=O(l.d),(o=((e=l.e)-n.length+1)%3)&&(n+=1==o||-2==o?"0":"00"),o=E(n,1/3),e=S((e+1)/3)-(e%3==(e<0?-1:2)),(r=new h(n=o==1/0?"5e"+e:(n=o.toExponential()).slice(0,n.indexOf("e")+1)+e)).s=l.s),i=(e=h.precision)+3;;)if(c=(u=(s=r).times(s).times(s)).plus(l),r=P(c.plus(l).times(s),c.plus(u),i+2,1),O(s.d).slice(0,i)===(n=O(r.d)).slice(0,i)){if("9999"!=(n=n.slice(i-3,i+1))&&(a||"4999"!=n)){+n&&(+n.slice(1)||"5"!=n.charAt(0))||(W(r,e+1,1),t=!r.times(r).times(r).eq(l));break}if(!a&&(W(s,e+1,0),s.times(s).times(s).eq(l))){r=s;break}i+=4,a=1}return v=!0,W(r,e,h.rounding,t)},M.decimalPlaces=M.dp=function(){var e,t=this.d,n=NaN;if(t){if(n=7*((e=t.length-1)-S(this.e/7)),e=t[e])for(;e%10==0;e/=10)n--;n<0&&(n=0)}return n},M.dividedBy=M.div=function(e){return P(this,new this.constructor(e))},M.dividedToIntegerBy=M.divToInt=function(e){var t=this.constructor;return W(P(this,new t(e),0,1,1),t.precision,t.rounding)},M.equals=M.eq=function(e){return 0===this.cmp(e)},M.floor=function(){return W(new this.constructor(this),this.e+1,3)},M.greaterThan=M.gt=function(e){return this.cmp(e)>0},M.greaterThanOrEqualTo=M.gte=function(e){var t=this.cmp(e);return 1==t||0===t},M.hyperbolicCosine=M.cosh=function(){var e,t,n,r,a,o=this,i=o.constructor,s=new i(1);if(!o.isFinite())return new i(o.s?1/0:NaN);if(o.isZero())return s;n=i.precision,r=i.rounding,i.precision=n+Math.max(o.e,o.sd())+4,i.rounding=1,(a=o.d.length)<32?t=(1/ne(4,e=Math.ceil(a/3))).toString():(e=16,t="2.3283064365386962890625e-10"),o=te(i,1,o.times(t),new i(1),!0);for(var u,c=e,l=new i(8);c--;)u=o.times(o),o=s.minus(u.times(l.minus(u.times(l))));return W(o,i.precision=n,i.rounding=r,!0)},M.hyperbolicSine=M.sinh=function(){var e,t,n,r,a=this,o=a.constructor;if(!a.isFinite()||a.isZero())return new o(a);if(t=o.precision,n=o.rounding,o.precision=t+Math.max(a.e,a.sd())+4,o.rounding=1,(r=a.d.length)<3)a=te(o,2,a,a,!0);else{e=(e=1.4*Math.sqrt(r))>16?16:0|e,a=te(o,2,a=a.times(1/ne(5,e)),a,!0);for(var i,s=new o(5),u=new o(16),c=new o(20);e--;)i=a.times(a),a=a.times(s.plus(i.times(u.times(i).plus(c))))}return o.precision=t,o.rounding=n,W(a,t,n,!0)},M.hyperbolicTangent=M.tanh=function(){var e,t,n=this,r=n.constructor;return n.isFinite()?n.isZero()?new r(n):(e=r.precision,t=r.rounding,r.precision=e+7,r.rounding=1,P(n.sinh(),n.cosh(),r.precision=e,r.rounding=t)):new r(n.s)},M.inverseCosine=M.acos=function(){var e,t=this,n=t.constructor,r=t.abs().cmp(1),a=n.precision,o=n.rounding;return-1!==r?0===r?t.isNeg()?j(n,a,o):new n(0):new n(NaN):t.isZero()?j(n,a+4,o).times(.5):(n.precision=a+6,n.rounding=1,t=t.asin(),e=j(n,a+4,o).times(.5),n.precision=a,n.rounding=o,e.minus(t))},M.inverseHyperbolicCosine=M.acosh=function(){var e,t,n=this,r=n.constructor;return n.lte(1)?new r(n.eq(1)?0:NaN):n.isFinite()?(e=r.precision,t=r.rounding,r.precision=e+Math.max(Math.abs(n.e),n.sd())+4,r.rounding=1,v=!1,n=n.times(n).minus(1).sqrt().plus(n),v=!0,r.precision=e,r.rounding=t,n.ln()):new r(n)},M.inverseHyperbolicSine=M.asinh=function(){var e,t,n=this,r=n.constructor;return!n.isFinite()||n.isZero()?new r(n):(e=r.precision,t=r.rounding,r.precision=e+2*Math.max(Math.abs(n.e),n.sd())+6,r.rounding=1,v=!1,n=n.times(n).plus(1).sqrt().plus(n),v=!0,r.precision=e,r.rounding=t,n.ln())},M.inverseHyperbolicTangent=M.atanh=function(){var e,t,n,r,a=this,o=a.constructor;return a.isFinite()?a.e>=0?new o(a.abs().eq(1)?a.s/0:a.isZero()?a:NaN):(e=o.precision,t=o.rounding,r=a.sd(),Math.max(r,e)<2*-a.e-1?W(new o(a),e,t,!0):(o.precision=n=r-a.e,a=P(a.plus(1),new o(1).minus(a),n+e,1),o.precision=e+4,o.rounding=1,a=a.ln(),o.precision=e,o.rounding=t,a.times(.5))):new o(NaN)},M.inverseSine=M.asin=function(){var e,t,n,r,a=this,o=a.constructor;return a.isZero()?new o(a):(t=a.abs().cmp(1),n=o.precision,r=o.rounding,-1!==t?0===t?((e=j(o,n+4,r).times(.5)).s=a.s,e):new o(NaN):(o.precision=n+6,o.rounding=1,a=a.div(new o(1).minus(a.times(a)).sqrt().plus(1)).atan(),o.precision=n,o.rounding=r,a.times(2)))},M.inverseTangent=M.atan=function(){var e,t,n,r,a,o,i,s,u,c=this,l=c.constructor,h=l.precision,d=l.rounding;if(c.isFinite()){if(c.isZero())return new l(c);if(c.abs().eq(1)&&h+4<=R)return(i=j(l,h+4,d).times(.25)).s=c.s,i}else{if(!c.s)return new l(NaN);if(h+4<=R)return(i=j(l,h+4,d).times(.5)).s=c.s,i}for(l.precision=s=h+10,l.rounding=1,e=n=Math.min(28,s/7+2|0);e;--e)c=c.div(c.times(c).plus(1).sqrt().plus(1));for(v=!1,t=Math.ceil(s/7),r=1,u=c.times(c),i=new l(c),a=c;-1!==e;)if(a=a.times(u),o=i.minus(a.div(r+=2)),a=a.times(u),void 0!==(i=o.plus(a.div(r+=2))).d[t])for(e=t;i.d[e]===o.d[e]&&e--;);return n&&(i=i.times(2<<n-1)),v=!0,W(i,l.precision=h,l.rounding=d,!0)},M.isFinite=function(){return!!this.d},M.isInteger=M.isInt=function(){return!!this.d&&S(this.e/7)>this.d.length-2},M.isNaN=function(){return!this.s},M.isNegative=M.isNeg=function(){return this.s<0},M.isPositive=M.isPos=function(){return this.s>0},M.isZero=function(){return!!this.d&&0===this.d[0]},M.lessThan=M.lt=function(e){return this.cmp(e)<0},M.lessThanOrEqualTo=M.lte=function(e){return this.cmp(e)<1},M.logarithm=M.log=function(e){var t,n,r,a,o,i,s,u,c=this,l=c.constructor,h=l.precision,d=l.rounding;if(null==e)e=new l(10),t=!0;else{if(n=(e=new l(e)).d,e.s<0||!n||!n[0]||e.eq(1))return new l(NaN);t=e.eq(10)}if(n=c.d,c.s<0||!n||!n[0]||c.eq(1))return new l(n&&!n[0]?-1/0:1!=c.s?NaN:n?0:1/0);if(t)if(n.length>1)o=!0;else{for(a=n[0];a%10===0;)a/=10;o=1!==a}if(v=!1,i=Z(c,s=h+5),r=t?G(l,s+10):Z(e,s),L((u=P(i,r,s,1)).d,a=h,d))do{if(i=Z(c,s+=10),r=t?G(l,s+10):Z(e,s),u=P(i,r,s,1),!o){+O(u.d).slice(a+1,a+15)+1==1e14&&(u=W(u,h+1,0));break}}while(L(u.d,a+=10,d));return v=!0,W(u,h,d)},M.minus=M.sub=function(e){var t,n,r,a,o,i,s,u,c,l,h,d,p=this,f=p.constructor;if(e=new f(e),!p.d||!e.d)return p.s&&e.s?p.d?e.s=-e.s:e=new f(e.d||p.s!==e.s?p:NaN):e=new f(NaN),e;if(p.s!=e.s)return e.s=-e.s,p.plus(e);if(c=p.d,d=e.d,s=f.precision,u=f.rounding,!c[0]||!d[0]){if(d[0])e.s=-e.s;else{if(!c[0])return new f(3===u?-0:0);e=new f(p)}return v?W(e,s,u):e}if(n=S(e.e/7),l=S(p.e/7),c=c.slice(),o=l-n){for((h=o<0)?(t=c,o=-o,i=d.length):(t=d,n=l,i=c.length),o>(r=Math.max(Math.ceil(s/7),i)+2)&&(o=r,t.length=1),t.reverse(),r=o;r--;)t.push(0);t.reverse()}else{for((h=(r=c.length)<(i=d.length))&&(i=r),r=0;r<i;r++)if(c[r]!=d[r]){h=c[r]<d[r];break}o=0}for(h&&(t=c,c=d,d=t,e.s=-e.s),i=c.length,r=d.length-i;r>0;--r)c[i++]=0;for(r=d.length;r>o;){if(c[--r]<d[r]){for(a=r;a&&0===c[--a];)c[a]=F-1;--c[a],c[r]+=F}c[r]-=d[r]}for(;0===c[--i];)c.pop();for(;0===c[0];c.shift())--n;return c[0]?(e.d=c,e.e=V(c,n),v?W(e,s,u):e):new f(3===u?-0:0)},M.modulo=M.mod=function(e){var t,n=this,r=n.constructor;return e=new r(e),!n.d||!e.s||e.d&&!e.d[0]?new r(NaN):!e.d||n.d&&!n.d[0]?W(new r(n),r.precision,r.rounding):(v=!1,9==r.modulo?(t=P(n,e.abs(),0,3,1)).s*=e.s:t=P(n,e,0,r.modulo,1),t=t.times(e),v=!0,n.minus(t))},M.naturalExponential=M.exp=function(){return Q(this)},M.naturalLogarithm=M.ln=function(){return Z(this)},M.negated=M.neg=function(){var e=new this.constructor(this);return e.s=-e.s,W(e)},M.plus=M.add=function(e){var t,n,r,a,o,i,s,u,c,l,h=this,d=h.constructor;if(e=new d(e),!h.d||!e.d)return h.s&&e.s?h.d||(e=new d(e.d||h.s===e.s?h:NaN)):e=new d(NaN),e;if(h.s!=e.s)return e.s=-e.s,h.minus(e);if(c=h.d,l=e.d,s=d.precision,u=d.rounding,!c[0]||!l[0])return l[0]||(e=new d(h)),v?W(e,s,u):e;if(o=S(h.e/7),r=S(e.e/7),c=c.slice(),a=o-r){for(a<0?(n=c,a=-a,i=l.length):(n=l,r=o,i=c.length),a>(i=(o=Math.ceil(s/7))>i?o+1:i+1)&&(a=i,n.length=1),n.reverse();a--;)n.push(0);n.reverse()}for((i=c.length)-(a=l.length)<0&&(a=i,n=l,l=c,c=n),t=0;a;)t=(c[--a]=c[a]+l[a]+t)/F|0,c[a]%=F;for(t&&(c.unshift(t),++r),i=c.length;0==c[--i];)c.pop();return e.d=c,e.e=V(c,r),v?W(e,s,u):e},M.precision=M.sd=function(e){var t,n=this;if(void 0!==e&&e!==!!e&&1!==e&&0!==e)throw Error(w+e);return n.d?(t=H(n.d),e&&n.e+1>t&&(t=n.e+1)):t=NaN,t},M.round=function(){var e=this,t=e.constructor;return W(new t(e),e.e+1,t.rounding)},M.sine=M.sin=function(){var e,t,n=this,r=n.constructor;return n.isFinite()?n.isZero()?new r(n):(e=r.precision,t=r.rounding,r.precision=e+Math.max(n.e,n.sd())+7,r.rounding=1,n=function(e,t){var n,r=t.d.length;if(r<3)return t.isZero()?t:te(e,2,t,t);n=(n=1.4*Math.sqrt(r))>16?16:0|n,t=t.times(1/ne(5,n)),t=te(e,2,t,t);for(var a,o=new e(5),i=new e(16),s=new e(20);n--;)a=t.times(t),t=t.times(o.plus(a.times(i.times(a).minus(s))));return t}(r,re(r,n)),r.precision=e,r.rounding=t,W(d>2?n.neg():n,e,t,!0)):new r(NaN)},M.squareRoot=M.sqrt=function(){var e,t,n,r,a,o,i=this,s=i.d,u=i.e,c=i.s,l=i.constructor;if(1!==c||!s||!s[0])return new l(!c||c<0&&(!s||s[0])?NaN:s?i:1/0);for(v=!1,0==(c=Math.sqrt(+i))||c==1/0?(((t=O(s)).length+u)%2==0&&(t+="0"),c=Math.sqrt(t),u=S((u+1)/2)-(u<0||u%2),r=new l(t=c==1/0?"5e"+u:(t=c.toExponential()).slice(0,t.indexOf("e")+1)+u)):r=new l(c.toString()),n=(u=l.precision)+3;;)if(r=(o=r).plus(P(i,o,n+2,1)).times(.5),O(o.d).slice(0,n)===(t=O(r.d)).slice(0,n)){if("9999"!=(t=t.slice(n-3,n+1))&&(a||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(W(r,u+1,1),e=!r.times(r).eq(i));break}if(!a&&(W(o,u+1,0),o.times(o).eq(i))){r=o;break}n+=4,a=1}return v=!0,W(r,u,l.rounding,e)},M.tangent=M.tan=function(){var e,t,n=this,r=n.constructor;return n.isFinite()?n.isZero()?new r(n):(e=r.precision,t=r.rounding,r.precision=e+10,r.rounding=1,(n=n.sin()).s=1,n=P(n,new r(1).minus(n.times(n)).sqrt(),e+10,0),r.precision=e,r.rounding=t,W(2==d||4==d?n.neg():n,e,t,!0)):new r(NaN)},M.times=M.mul=function(e){var t,n,r,a,o,i,s,u,c,l=this,h=l.constructor,d=l.d,p=(e=new h(e)).d;if(e.s*=l.s,!d||!d[0]||!p||!p[0])return new h(!e.s||d&&!d[0]&&!p||p&&!p[0]&&!d?NaN:d&&p?0*e.s:e.s/0);for(n=S(l.e/7)+S(e.e/7),(u=d.length)<(c=p.length)&&(o=d,d=p,p=o,i=u,u=c,c=i),o=[],r=i=u+c;r--;)o.push(0);for(r=c;--r>=0;){for(t=0,a=u+r;a>r;)s=o[a]+p[r]*d[a-r-1]+t,o[a--]=s%F|0,t=s/F|0;o[a]=(o[a]+t)%F|0}for(;!o[--i];)o.pop();return t?++n:o.shift(),e.d=o,e.e=V(o,n),v?W(e,h.precision,h.rounding):e},M.toBinary=function(e,t){return ae(this,2,e,t)},M.toDecimalPlaces=M.toDP=function(e,t){var n=this,r=n.constructor;return n=new r(n),void 0===e?n:(z(e,0,f),void 0===t?t=r.rounding:z(t,0,8),W(n,e+n.e+1,t))},M.toExponential=function(e,t){var n,r=this,a=r.constructor;return void 0===e?n=U(r,!0):(z(e,0,f),void 0===t?t=a.rounding:z(t,0,8),n=U(r=W(new a(r),e+1,t),!0,e+1)),r.isNeg()&&!r.isZero()?"-"+n:n},M.toFixed=function(e,t){var n,r,a=this,o=a.constructor;return void 0===e?n=U(a):(z(e,0,f),void 0===t?t=o.rounding:z(t,0,8),n=U(r=W(new o(a),e+a.e+1,t),!1,e+r.e+1)),a.isNeg()&&!a.isZero()?"-"+n:n},M.toFraction=function(e){var t,n,r,a,o,i,s,u,c,l,h,d,p=this,f=p.d,m=p.constructor;if(!f)return new m(p);if(c=n=new m(1),r=u=new m(0),i=(o=(t=new m(r)).e=H(f)-p.e-1)%7,t.d[0]=E(10,i<0?7+i:i),null==e)e=o>0?t:c;else{if(!(s=new m(e)).isInt()||s.lt(c))throw Error(w+s);e=s.gt(t)?o>0?t:c:s}for(v=!1,s=new m(O(f)),l=m.precision,m.precision=o=7*f.length*2;h=P(s,t,0,1,1),1!=(a=n.plus(h.times(r))).cmp(e);)n=r,r=a,a=c,c=u.plus(h.times(a)),u=a,a=t,t=s.minus(h.times(a)),s=a;return a=P(e.minus(n),r,0,1,1),u=u.plus(a.times(c)),n=n.plus(a.times(r)),u.s=c.s=p.s,d=P(c,r,o,1).minus(p).abs().cmp(P(u,n,o,1).minus(p).abs())<1?[c,r]:[u,n],m.precision=l,v=!0,d},M.toHexadecimal=M.toHex=function(e,t){return ae(this,16,e,t)},M.toNearest=function(e,t){var n=this,r=n.constructor;if(n=new r(n),null==e){if(!n.d)return n;e=new r(1),t=r.rounding}else{if(e=new r(e),void 0===t?t=r.rounding:z(t,0,8),!n.d)return e.s?n:e;if(!e.d)return e.s&&(e.s=n.s),e}return e.d[0]?(v=!1,n=P(n,e,0,t,1).times(e),v=!0,W(n)):(e.s=n.s,n=e),n},M.toNumber=function(){return+this},M.toOctal=function(e,t){return ae(this,8,e,t)},M.toPower=M.pow=function(e){var t,n,r,a,o,i,s=this,u=s.constructor,c=+(e=new u(e));if(!s.d||!e.d||!s.d[0]||!e.d[0])return new u(E(+s,c));if((s=new u(s)).eq(1))return s;if(r=u.precision,o=u.rounding,e.eq(1))return W(s,r,o);if((t=S(e.e/7))>=e.d.length-1&&(n=c<0?-c:c)<=9007199254740991)return a=K(u,s,n,r),e.s<0?new u(1).div(a):W(a,r,o);if((i=s.s)<0){if(t<e.d.length-1)return new u(NaN);if(0==(1&e.d[t])&&(i=1),0==s.e&&1==s.d[0]&&1==s.d.length)return s.s=i,s}return(t=0!=(n=E(+s,c))&&isFinite(n)?new u(n+"").e:S(c*(Math.log("0."+O(s.d))/Math.LN10+s.e+1)))>u.maxE+1||t<u.minE-1?new u(t>0?i/0:0):(v=!1,u.rounding=s.s=1,n=Math.min(12,(t+"").length),(a=Q(e.times(Z(s,r+n)),r)).d&&L((a=W(a,r+5,1)).d,r,o)&&(t=r+10,+O((a=W(Q(e.times(Z(s,t+n)),t),t+5,1)).d).slice(r+1,r+15)+1==1e14&&(a=W(a,r+1,0))),a.s=i,v=!0,u.rounding=o,W(a,r,o))},M.toPrecision=function(e,t){var n,r=this,a=r.constructor;return void 0===e?n=U(r,r.e<=a.toExpNeg||r.e>=a.toExpPos):(z(e,1,f),void 0===t?t=a.rounding:z(t,0,8),n=U(r=W(new a(r),e,t),e<=r.e||r.e<=a.toExpNeg,e)),r.isNeg()&&!r.isZero()?"-"+n:n},M.toSignificantDigits=M.toSD=function(e,t){var n=this.constructor;return void 0===e?(e=n.precision,t=n.rounding):(z(e,1,f),void 0===t?t=n.rounding:z(t,0,8)),W(new n(this),e,t)},M.toString=function(){var e=this,t=e.constructor,n=U(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()&&!e.isZero()?"-"+n:n},M.truncated=M.trunc=function(){return W(new this.constructor(this),this.e+1,1)},M.valueOf=M.toJSON=function(){var e=this,t=e.constructor,n=U(e,e.e<=t.toExpNeg||e.e>=t.toExpPos);return e.isNeg()?"-"+n:n};var P=function(){function e(e,t,n){var r,a=0,o=e.length;for(e=e.slice();o--;)r=e[o]*t+a,e[o]=r%n|0,a=r/n|0;return a&&e.unshift(a),e}function t(e,t,n,r){var a,o;if(n!=r)o=n>r?1:-1;else for(a=o=0;a<n;a++)if(e[a]!=t[a]){o=e[a]>t[a]?1:-1;break}return o}function n(e,t,n,r){for(var a=0;n--;)e[n]-=a,a=e[n]<t[n]?1:0,e[n]=a*r+e[n]-t[n];for(;!e[0]&&e.length>1;)e.shift()}return function(r,a,o,i,s,u){var c,l,d,p,f,m,g,y,b,v,x,w,k,C,D,E,I,N,T,A,_=r.constructor,R=r.s==a.s?1:-1,M=r.d,O=a.d;if(!M||!M[0]||!O||!O[0])return new _(r.s&&a.s&&(M?!O||M[0]!=O[0]:O)?M&&0==M[0]||!O?0*R:R/0:NaN);for(u?(f=1,l=r.e-a.e):(u=F,f=7,l=S(r.e/f)-S(a.e/f)),T=O.length,I=M.length,v=(b=new _(R)).d=[],d=0;O[d]==(M[d]||0);d++);if(O[d]>(M[d]||0)&&l--,null==o?(C=o=_.precision,i=_.rounding):C=s?o+(r.e-a.e)+1:o,C<0)v.push(1),m=!0;else{if(C=C/f+2|0,d=0,1==T){for(p=0,O=O[0],C++;(d<I||p)&&C--;d++)D=p*u+(M[d]||0),v[d]=D/O|0,p=D%O|0;m=p||d<I}else{for((p=u/(O[0]+1)|0)>1&&(O=e(O,p,u),M=e(M,p,u),T=O.length,I=M.length),E=T,w=(x=M.slice(0,T)).length;w<T;)x[w++]=0;(A=O.slice()).unshift(0),N=O[0],O[1]>=u/2&&++N;do{p=0,(c=t(O,x,T,w))<0?(k=x[0],T!=w&&(k=k*u+(x[1]||0)),(p=k/N|0)>1?(p>=u&&(p=u-1),1==(c=t(g=e(O,p,u),x,y=g.length,w=x.length))&&(p--,n(g,T<y?A:O,y,u))):(0==p&&(c=p=1),g=O.slice()),(y=g.length)<w&&g.unshift(0),n(x,g,w,u),-1==c&&(c=t(O,x,T,w=x.length))<1&&(p++,n(x,T<w?A:O,w,u)),w=x.length):0===c&&(p++,x=[0]),v[d++]=p,c&&x[0]?x[w++]=M[E]||0:(x=[M[E]],w=1)}while((E++<I||void 0!==x[0])&&C--);m=void 0!==x[0]}v[0]||v.shift()}if(1==f)b.e=l,h=m;else{for(d=1,p=v[0];p>=10;p/=10)d++;b.e=d+l*f-1,W(b,s?o+b.e+1:o,i,m)}return b}}();function W(e,t,n,r){var a,o,i,s,u,c,l,h,d,p=e.constructor;e:if(null!=t){if(!(h=e.d))return e;for(a=1,s=h[0];s>=10;s/=10)a++;if((o=t-a)<0)o+=7,i=t,u=(l=h[d=0])/E(10,a-i-1)%10|0;else if((d=Math.ceil((o+1)/7))>=(s=h.length)){if(!r)break e;for(;s++<=d;)h.push(0);l=u=0,a=1,i=(o%=7)-7+1}else{for(l=s=h[d],a=1;s>=10;s/=10)a++;u=(i=(o%=7)-7+a)<0?0:l/E(10,a-i-1)%10|0}if(r=r||t<0||void 0!==h[d+1]||(i<0?l:l%E(10,a-i-1)),c=n<4?(u||r)&&(0==n||n==(e.s<0?3:2)):u>5||5==u&&(4==n||r||6==n&&(o>0?i>0?l/E(10,a-i):0:h[d-1])%10&1||n==(e.s<0?8:7)),t<1||!h[0])return h.length=0,c?(t-=e.e+1,h[0]=E(10,(7-t%7)%7),e.e=-t||0):h[0]=e.e=0,e;if(0==o?(h.length=d,s=1,d--):(h.length=d+1,s=E(10,7-o),h[d]=i>0?(l/E(10,a-i)%E(10,i)|0)*s:0),c)for(;;){if(0==d){for(o=1,i=h[0];i>=10;i/=10)o++;for(i=h[0]+=s,s=1;i>=10;i/=10)s++;o!=s&&(e.e++,h[0]==F&&(h[0]=1));break}if(h[d]+=s,h[d]!=F)break;h[d--]=0,s=1}for(o=h.length;0===h[--o];)h.pop()}return v&&(e.e>p.maxE?(e.d=null,e.e=NaN):e.e<p.minE&&(e.e=0,e.d=[0])),e}function U(e,t,n){if(!e.isFinite())return J(e);var r,a=e.e,o=O(e.d),i=o.length;return t?(n&&(r=n-i)>0?o=o.charAt(0)+"."+o.slice(1)+q(r):i>1&&(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e<0?"e":"e+")+e.e):a<0?(o="0."+q(-a-1)+o,n&&(r=n-i)>0&&(o+=q(r))):a>=i?(o+=q(a+1-i),n&&(r=n-a-1)>0&&(o=o+"."+q(r))):((r=a+1)<i&&(o=o.slice(0,r)+"."+o.slice(r)),n&&(r=n-i)>0&&(a+1===i&&(o+="."),o+=q(r))),o}function V(e,t){var n=e[0];for(t*=7;n>=10;n/=10)t++;return t}function G(e,t,n){if(t>_)throw v=!0,n&&(e.precision=n),Error(k);return W(new e(g),t,1,!0)}function j(e,t,n){if(t>R)throw Error(k);return W(new e(y),t,n,!0)}function H(e){var t=e.length-1,n=7*t+1;if(t=e[t]){for(;t%10==0;t/=10)n--;for(t=e[0];t>=10;t/=10)n++}return n}function q(e){for(var t="";e--;)t+="0";return t}function K(e,t,n,r){var a,o=new e(1),i=Math.ceil(r/7+4);for(v=!1;;){if(n%2&&oe((o=o.times(t)).d,i)&&(a=!0),0===(n=S(n/2))){n=o.d.length-1,a&&0===o.d[n]&&++o.d[n];break}oe((t=t.times(t)).d,i)}return v=!0,o}function X(e){return 1&e.d[e.d.length-1]}function Y(e,t,n){for(var r,a=new e(t[0]),o=0;++o<t.length;){if(!(r=new e(t[o])).s){a=r;break}a[n](r)&&(a=r)}return a}function Q(e,t){var n,r,a,o,i,s,u,c=0,l=0,h=0,d=e.constructor,p=d.rounding,f=d.precision;if(!e.d||!e.d[0]||e.e>17)return new d(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:NaN);for(null==t?(v=!1,u=f):u=t,s=new d(.03125);e.e>-2;)e=e.times(s),h+=5;for(u+=r=Math.log(E(2,h))/Math.LN10*2+5|0,n=o=i=new d(1),d.precision=u;;){if(o=W(o.times(e),u,1),n=n.times(++l),O((s=i.plus(P(o,n,u,1))).d).slice(0,u)===O(i.d).slice(0,u)){for(a=h;a--;)i=W(i.times(i),u,1);if(null!=t)return d.precision=f,i;if(!(c<3&&L(i.d,u-r,p,c)))return W(i,d.precision=f,p,v=!0);d.precision=u+=10,n=o=s=new d(1),l=0,c++}i=s}}function Z(e,t){var n,r,a,o,i,s,u,c,l,h,d,p=1,f=e,m=f.d,g=f.constructor,y=g.rounding,b=g.precision;if(f.s<0||!m||!m[0]||!f.e&&1==m[0]&&1==m.length)return new g(m&&!m[0]?-1/0:1!=f.s?NaN:m?0:f);if(null==t?(v=!1,l=b):l=t,g.precision=l+=10,r=(n=O(m)).charAt(0),!(Math.abs(o=f.e)<15e14))return c=G(g,l+2,b).times(o+""),f=Z(new g(r+"."+n.slice(1)),l-10).plus(c),g.precision=b,null==t?W(f,b,y,v=!0):f;for(;r<7&&1!=r||1==r&&n.charAt(1)>3;)r=(n=O((f=f.times(e)).d)).charAt(0),p++;for(o=f.e,r>1?(f=new g("0."+n),o++):f=new g(r+"."+n.slice(1)),h=f,u=i=f=P(f.minus(1),f.plus(1),l,1),d=W(f.times(f),l,1),a=3;;){if(i=W(i.times(d),l,1),O((c=u.plus(P(i,new g(a),l,1))).d).slice(0,l)===O(u.d).slice(0,l)){if(u=u.times(2),0!==o&&(u=u.plus(G(g,l+2,b).times(o+""))),u=P(u,new g(p),l,1),null!=t)return g.precision=b,u;if(!L(u.d,l-10,y,s))return W(u,g.precision=b,y,v=!0);g.precision=l+=10,c=i=f=P(h.minus(1),h.plus(1),l,1),d=W(f.times(f),l,1),a=s=1}u=c,a+=2}}function J(e){return String(e.s*e.s/0)}function $(e,t){var n,r,a;for((n=t.indexOf("."))>-1&&(t=t.replace(".","")),(r=t.search(/e/i))>0?(n<0&&(n=r),n+=+t.slice(r+1),t=t.substring(0,r)):n<0&&(n=t.length),r=0;48===t.charCodeAt(r);r++);for(a=t.length;48===t.charCodeAt(a-1);--a);if(t=t.slice(r,a)){if(a-=r,e.e=n=n-r-1,e.d=[],r=(n+1)%7,n<0&&(r+=7),r<a){for(r&&e.d.push(+t.slice(0,r)),a-=7;r<a;)e.d.push(+t.slice(r,r+=7));r=7-(t=t.slice(r)).length}else r-=a;for(;r--;)t+="0";e.d.push(+t),v&&(e.e>e.constructor.maxE?(e.d=null,e.e=NaN):e.e<e.constructor.minE&&(e.e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function ee(e,t){var n,r,a,o,i,s,u,c,l;if(t.indexOf("_")>-1){if(t=t.replace(/(\d)_(?=\d)/g,"$1"),A.test(t))return $(e,t)}else if("Infinity"===t||"NaN"===t)return+t||(e.s=NaN),e.e=NaN,e.d=null,e;if(N.test(t))n=16,t=t.toLowerCase();else if(I.test(t))n=2;else{if(!T.test(t))throw Error(w+t);n=8}for((o=t.search(/p/i))>0?(u=+t.slice(o+1),t=t.substring(2,o)):t=t.slice(2),i=(o=t.indexOf("."))>=0,r=e.constructor,i&&(o=(s=(t=t.replace(".","")).length)-o,a=K(r,new r(n),o,2*o)),o=l=(c=B(t,n,F)).length-1;0===c[o];--o)c.pop();return o<0?new r(0*e.s):(e.e=V(c,l),e.d=c,v=!1,i&&(e=P(e,a,4*s)),u&&(e=e.times(Math.abs(u)<54?E(2,u):qe.pow(2,u))),v=!0,e)}function te(e,t,n,r,a){var o,i,s,u,c=e.precision,l=Math.ceil(c/7);for(v=!1,u=n.times(n),s=new e(r);;){if(i=P(s.times(u),new e(t++*t++),c,1),s=a?r.plus(i):r.minus(i),r=P(i.times(u),new e(t++*t++),c,1),void 0!==(i=s.plus(r)).d[l]){for(o=l;i.d[o]===s.d[o]&&o--;);if(-1==o)break}o=s,s=r,r=i,i=o}return v=!0,i.d.length=l+1,i}function ne(e,t){for(var n=e;--t;)n*=e;return n}function re(e,t){var n,r=t.s<0,a=j(e,e.precision,1),o=a.times(.5);if((t=t.abs()).lte(o))return d=r?4:1,t;if((n=t.divToInt(a)).isZero())d=r?3:2;else{if((t=t.minus(n.times(a))).lte(o))return d=X(n)?r?2:3:r?4:1,t;d=X(n)?r?1:4:r?3:2}return t.minus(a).abs()}function ae(e,t,n,r){var a,o,i,s,u,c,l,d,p,g=e.constructor,y=void 0!==n;if(y?(z(n,1,f),void 0===r?r=g.rounding:z(r,0,8)):(n=g.precision,r=g.rounding),e.isFinite()){for(y?(a=2,16==t?n=4*n-3:8==t&&(n=3*n-2)):a=t,(i=(l=U(e)).indexOf("."))>=0&&(l=l.replace(".",""),(p=new g(1)).e=l.length-i,p.d=B(U(p),10,a),p.e=p.d.length),o=u=(d=B(l,10,a)).length;0==d[--u];)d.pop();if(d[0]){if(i<0?o--:((e=new g(e)).d=d,e.e=o,d=(e=P(e,p,n,r,0,a)).d,o=e.e,c=h),i=d[n],s=a/2,c=c||void 0!==d[n+1],c=r<4?(void 0!==i||c)&&(0===r||r===(e.s<0?3:2)):i>s||i===s&&(4===r||c||6===r&&1&d[n-1]||r===(e.s<0?8:7)),d.length=n,c)for(;++d[--n]>a-1;)d[n]=0,n||(++o,d.unshift(1));for(u=d.length;!d[u-1];--u);for(i=0,l="";i<u;i++)l+=m.charAt(d[i]);if(y){if(u>1)if(16==t||8==t){for(i=16==t?4:3,--u;u%i;u++)l+="0";for(u=(d=B(l,a,t)).length;!d[u-1];--u);for(i=1,l="1.";i<u;i++)l+=m.charAt(d[i])}else l=l.charAt(0)+"."+l.slice(1);l=l+(o<0?"p":"p+")+o}else if(o<0){for(;++o;)l="0"+l;l="0."+l}else if(++o>u)for(o-=u;o--;)l+="0";else o<u&&(l=l.slice(0,o)+"."+l.slice(o))}else l=y?"0p+0":"0";l=(16==t?"0x":2==t?"0b":8==t?"0o":"")+l}else l=J(e);return e.s<0?"-"+l:l}function oe(e,t){if(e.length>t)return e.length=t,!0}function ie(e){return new this(e).abs()}function se(e){return new this(e).acos()}function ue(e){return new this(e).acosh()}function ce(e,t){return new this(e).plus(t)}function le(e){return new this(e).asin()}function he(e){return new this(e).asinh()}function de(e){return new this(e).atan()}function pe(e){return new this(e).atanh()}function fe(e,t){e=new this(e),t=new this(t);var n,r=this.precision,a=this.rounding,o=r+4;return e.s&&t.s?e.d||t.d?!t.d||e.isZero()?(n=t.s<0?j(this,r,a):new this(0)).s=e.s:!e.d||t.isZero()?(n=j(this,o,1).times(.5)).s=e.s:t.s<0?(this.precision=o,this.rounding=1,n=this.atan(P(e,t,o,1)),t=j(this,o,1),this.precision=r,this.rounding=a,n=e.s<0?n.minus(t):n.plus(t)):n=this.atan(P(e,t,o,1)):(n=j(this,o,1).times(t.s>0?.25:.75)).s=e.s:n=new this(NaN),n}function me(e){return new this(e).cbrt()}function ge(e){return W(e=new this(e),e.e+1,2)}function ye(e,t,n){return new this(e).clamp(t,n)}function be(e){if(!e||"object"!==typeof e)throw Error(x+"Object expected");var t,n,r,a=!0===e.defaults,o=["precision",1,f,"rounding",0,8,"toExpNeg",-p,0,"toExpPos",0,p,"maxE",0,p,"minE",-p,0,"modulo",0,9];for(t=0;t<o.length;t+=3)if(n=o[t],a&&(this[n]=b[n]),void 0!==(r=e[n])){if(!(S(r)===r&&r>=o[t+1]&&r<=o[t+2]))throw Error(w+n+": "+r);this[n]=r}if(n="crypto",a&&(this[n]=b[n]),void 0!==(r=e[n])){if(!0!==r&&!1!==r&&0!==r&&1!==r)throw Error(w+n+": "+r);if(r){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw Error(C);this[n]=!0}else this[n]=!1}return this}function ve(e){return new this(e).cos()}function xe(e){return new this(e).cosh()}function we(e,t){return new this(e).div(t)}function ke(e){return new this(e).exp()}function Ce(e){return W(e=new this(e),e.e+1,3)}function De(){var e,t,n=new this(0);for(v=!1,e=0;e<arguments.length;)if((t=new this(arguments[e++])).d)n.d&&(n=n.plus(t.times(t)));else{if(t.s)return v=!0,new this(1/0);n=t}return v=!0,n.sqrt()}function Se(e){return e instanceof qe||e&&e.toStringTag===D||!1}function Ee(e){return new this(e).ln()}function Ie(e,t){return new this(e).log(t)}function Ne(e){return new this(e).log(2)}function Te(e){return new this(e).log(10)}function Ae(){return Y(this,arguments,"lt")}function Fe(){return Y(this,arguments,"gt")}function _e(e,t){return new this(e).mod(t)}function Re(e,t){return new this(e).mul(t)}function Me(e,t){return new this(e).pow(t)}function Oe(e){var t,n,r,a,o=0,i=new this(1),s=[];if(void 0===e?e=this.precision:z(e,1,f),r=Math.ceil(e/7),this.crypto)if(crypto.getRandomValues)for(t=crypto.getRandomValues(new Uint32Array(r));o<r;)(a=t[o])>=429e7?t[o]=crypto.getRandomValues(new Uint32Array(1))[0]:s[o++]=a%1e7;else{if(!crypto.randomBytes)throw Error(C);for(t=crypto.randomBytes(r*=4);o<r;)(a=t[o]+(t[o+1]<<8)+(t[o+2]<<16)+((127&t[o+3])<<24))>=214e7?crypto.randomBytes(4).copy(t,o):(s.push(a%1e7),o+=4);o=r/4}else for(;o<r;)s[o++]=1e7*Math.random()|0;for(e%=7,(r=s[--o])&&e&&(a=E(10,7-e),s[o]=(r/a|0)*a);0===s[o];o--)s.pop();if(o<0)n=0,s=[0];else{for(n=-1;0===s[0];n-=7)s.shift();for(r=1,a=s[0];a>=10;a/=10)r++;r<7&&(n-=7-r)}return i.e=n,i.d=s,i}function ze(e){return W(e=new this(e),e.e+1,this.rounding)}function Le(e){return(e=new this(e)).d?e.d[0]?e.s:0*e.s:e.s||NaN}function Be(e){return new this(e).sin()}function Pe(e){return new this(e).sinh()}function We(e){return new this(e).sqrt()}function Ue(e,t){return new this(e).sub(t)}function Ve(){var e=0,t=arguments,n=new this(t[e]);for(v=!1;n.s&&++e<t.length;)n=n.plus(t[e]);return v=!0,W(n,this.precision,this.rounding)}function Ge(e){return new this(e).tan()}function je(e){return new this(e).tanh()}function He(e){return W(e=new this(e),e.e+1,1)}M[Symbol.for("nodejs.util.inspect.custom")]=M.toString,M[Symbol.toStringTag]="Decimal";var qe=M.constructor=function e(t){var n,r,a;function o(e){var t,n,r,a=this;if(!(a instanceof o))return new o(e);if(a.constructor=o,Se(e))return a.s=e.s,void(v?!e.d||e.e>o.maxE?(a.e=NaN,a.d=null):e.e<o.minE?(a.e=0,a.d=[0]):(a.e=e.e,a.d=e.d.slice()):(a.e=e.e,a.d=e.d?e.d.slice():e.d));if("number"===(r=typeof e)){if(0===e)return a.s=1/e<0?-1:1,a.e=0,void(a.d=[0]);if(e<0?(e=-e,a.s=-1):a.s=1,e===~~e&&e<1e7){for(t=0,n=e;n>=10;n/=10)t++;return void(v?t>o.maxE?(a.e=NaN,a.d=null):t<o.minE?(a.e=0,a.d=[0]):(a.e=t,a.d=[e]):(a.e=t,a.d=[e]))}return 0*e!==0?(e||(a.s=NaN),a.e=NaN,void(a.d=null)):$(a,e.toString())}if("string"!==r)throw Error(w+e);return 45===(n=e.charCodeAt(0))?(e=e.slice(1),a.s=-1):(43===n&&(e=e.slice(1)),a.s=1),A.test(e)?$(a,e):ee(a,e)}if(o.prototype=M,o.ROUND_UP=0,o.ROUND_DOWN=1,o.ROUND_CEIL=2,o.ROUND_FLOOR=3,o.ROUND_HALF_UP=4,o.ROUND_HALF_DOWN=5,o.ROUND_HALF_EVEN=6,o.ROUND_HALF_CEIL=7,o.ROUND_HALF_FLOOR=8,o.EUCLID=9,o.config=o.set=be,o.clone=e,o.isDecimal=Se,o.abs=ie,o.acos=se,o.acosh=ue,o.add=ce,o.asin=le,o.asinh=he,o.atan=de,o.atanh=pe,o.atan2=fe,o.cbrt=me,o.ceil=ge,o.clamp=ye,o.cos=ve,o.cosh=xe,o.div=we,o.exp=ke,o.floor=Ce,o.hypot=De,o.ln=Ee,o.log=Ie,o.log10=Te,o.log2=Ne,o.max=Ae,o.min=Fe,o.mod=_e,o.mul=Re,o.pow=Me,o.random=Oe,o.round=ze,o.sign=Le,o.sin=Be,o.sinh=Pe,o.sqrt=We,o.sub=Ue,o.sum=Ve,o.tan=Ge,o.tanh=je,o.trunc=He,void 0===t&&(t={}),t&&!0!==t.defaults)for(a=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],n=0;n<a.length;)t.hasOwnProperty(r=a[n++])||(t[r]=this[r]);return o.config(t),o}(b);g=new qe(g),y=new qe(y);const Ke=qe;function Xe(e,t){if(Qe(e,t))return e[t];if("function"===typeof e[t]&&Ze(e,t))throw new Error('Cannot access method "'+t+'" as a property');throw new Error('No access to property "'+t+'"')}function Ye(e,t,n){if(Qe(e,t))return e[t]=n,n;throw new Error('No access to property "'+t+'"')}function Qe(e,t){return!(!function(e){return"object"===typeof e&&e&&e.constructor===Object}(e)&&!Array.isArray(e))&&(!!qt(Je,t)||!(t in Object.prototype)&&!(t in Function.prototype))}function Ze(e,t){return null!==e&&void 0!==e&&"function"===typeof e[t]&&(!(qt(e,t)&&Object.getPrototypeOf&&t in Object.getPrototypeOf(e))&&(!!qt($e,t)||!(t in Object.prototype)&&!(t in Function.prototype)))}var Je={length:!0,name:!0},$e={toString:!0,valueOf:!0,toLocaleString:!0};class et{constructor(e){this.wrappedObject=e,this[Symbol.iterator]=this.entries}keys(){return Object.keys(this.wrappedObject).filter((e=>this.has(e))).values()}get(e){return Xe(this.wrappedObject,e)}set(e,t){return Ye(this.wrappedObject,e,t),this}has(e){return Qe(this.wrappedObject,e)&&e in this.wrappedObject}entries(){return tt(this.keys(),(e=>[e,this.get(e)]))}forEach(e){for(var t of this.keys())e(this.get(t),t,this)}delete(e){Qe(this.wrappedObject,e)&&delete this.wrappedObject[e]}clear(){for(var e of this.keys())this.delete(e)}get size(){return Object.keys(this.wrappedObject).length}}function tt(e,t){return{next:()=>{var n=e.next();return n.done?n:{value:t(n.value),done:!1}}}}function nt(e){return"number"===typeof e}function rt(e){return!(!e||"object"!==typeof e||"function"!==typeof e.constructor)&&(!0===e.isBigNumber&&"object"===typeof e.constructor.prototype&&!0===e.constructor.prototype.isBigNumber||"function"===typeof e.constructor.isDecimal&&!0===e.constructor.isDecimal(e))}function at(e){return"bigint"===typeof e}function ot(e){return e&&"object"===typeof e&&!0===Object.getPrototypeOf(e).isComplex||!1}function it(e){return e&&"object"===typeof e&&!0===Object.getPrototypeOf(e).isFraction||!1}function st(e){return e&&!0===e.constructor.prototype.isUnit||!1}function ut(e){return"string"===typeof e}var ct=Array.isArray;function lt(e){return e&&!0===e.constructor.prototype.isMatrix||!1}function ht(e){return Array.isArray(e)||lt(e)}function dt(e){return e&&e.isDenseMatrix&&!0===e.constructor.prototype.isMatrix||!1}function pt(e){return e&&e.isSparseMatrix&&!0===e.constructor.prototype.isMatrix||!1}function ft(e){return e&&!0===e.constructor.prototype.isRange||!1}function mt(e){return e&&!0===e.constructor.prototype.isIndex||!1}function gt(e){return"boolean"===typeof e}function yt(e){return e&&!0===e.constructor.prototype.isResultSet||!1}function bt(e){return e&&!0===e.constructor.prototype.isHelp||!1}function vt(e){return"function"===typeof e}function xt(e){return e instanceof Date}function wt(e){return e instanceof RegExp}function kt(e){return!(!e||"object"!==typeof e||e.constructor!==Object||ot(e)||it(e))}function Ct(e){return!!e&&(e instanceof Map||e instanceof et||"function"===typeof e.set&&"function"===typeof e.get&&"function"===typeof e.keys&&"function"===typeof e.has)}function Dt(e){return null===e}function St(e){return void 0===e}function Et(e){return e&&!0===e.isAccessorNode&&!0===e.constructor.prototype.isNode||!1}function It(e){return e&&!0===e.isArrayNode&&!0===e.constructor.prototype.isNode||!1}function Nt(e){return e&&!0===e.isAssignmentNode&&!0===e.constructor.prototype.isNode||!1}function Tt(e){return e&&!0===e.isBlockNode&&!0===e.constructor.prototype.isNode||!1}function At(e){return e&&!0===e.isConditionalNode&&!0===e.constructor.prototype.isNode||!1}function Ft(e){return e&&!0===e.isConstantNode&&!0===e.constructor.prototype.isNode||!1}function _t(e){return e&&!0===e.isFunctionAssignmentNode&&!0===e.constructor.prototype.isNode||!1}function Rt(e){return e&&!0===e.isFunctionNode&&!0===e.constructor.prototype.isNode||!1}function Mt(e){return e&&!0===e.isIndexNode&&!0===e.constructor.prototype.isNode||!1}function Ot(e){return e&&!0===e.isNode&&!0===e.constructor.prototype.isNode||!1}function zt(e){return e&&!0===e.isObjectNode&&!0===e.constructor.prototype.isNode||!1}function Lt(e){return e&&!0===e.isOperatorNode&&!0===e.constructor.prototype.isNode||!1}function Bt(e){return e&&!0===e.isParenthesisNode&&!0===e.constructor.prototype.isNode||!1}function Pt(e){return e&&!0===e.isRangeNode&&!0===e.constructor.prototype.isNode||!1}function Wt(e){return e&&!0===e.isRelationalNode&&!0===e.constructor.prototype.isNode||!1}function Ut(e){return e&&!0===e.isSymbolNode&&!0===e.constructor.prototype.isNode||!1}function Vt(e){return e&&!0===e.constructor.prototype.isChain||!1}function Gt(e){var t=typeof e;return"object"===t?null===e?"null":rt(e)?"BigNumber":e.constructor&&e.constructor.name?e.constructor.name:"Object":t}function jt(e){var t=typeof e;if("number"===t||"bigint"===t||"string"===t||"boolean"===t||null===e||void 0===e)return e;if("function"===typeof e.clone)return e.clone();if(Array.isArray(e))return e.map((function(e){return jt(e)}));if(e instanceof Date)return new Date(e.valueOf());if(rt(e))return e;if(kt(e))return function(e,t){var n={};for(var r in e)qt(e,r)&&(n[r]=t(e[r]));return n}(e,jt);if("function"===t)return e;throw new TypeError("Cannot clone: unknown type of value (value: ".concat(e,")"))}function Ht(e,t){var n,r,a;if(Array.isArray(e)){if(!Array.isArray(t))return!1;if(e.length!==t.length)return!1;for(r=0,a=e.length;r<a;r++)if(!Ht(e[r],t[r]))return!1;return!0}if("function"===typeof e)return e===t;if(e instanceof Object){if(Array.isArray(t)||!(t instanceof Object))return!1;for(n in e)if(!(n in t)||!Ht(e[n],t[n]))return!1;for(n in t)if(!(n in e))return!1;return!0}return e===t}function qt(e,t){return e&&Object.hasOwnProperty.call(e,t)}function Kt(e,t,n,r){function a(r){var a=function(e,t){for(var n={},r=0;r<t.length;r++){var a=t[r],o=e[a];void 0!==o&&(n[a]=o)}return n}(r,t.map(Xt));return function(e,t,n){var r=t.filter((e=>!function(e){return e&&"?"===e[0]}(e))).every((e=>void 0!==n[e]));if(!r){var a=t.filter((e=>void 0===n[e]));throw new Error('Cannot create function "'.concat(e,'", ')+"some dependencies are missing: ".concat(a.map((e=>'"'.concat(e,'"'))).join(", "),"."))}}(e,t,r),n(a)}return a.isFactory=!0,a.fn=e,a.dependencies=t.slice().sort(),r&&(a.meta=r),a}function Xt(e){return e&&"?"===e[0]?e.slice(1):e}var Yt=Kt("BigNumber",["?on","config"],(e=>{var{on:t,config:n}=e,r=Ke.clone({precision:n.precision,modulo:Ke.EUCLID});return r.prototype=Object.create(r.prototype),r.prototype.type="BigNumber",r.prototype.isBigNumber=!0,r.prototype.toJSON=function(){return{mathjs:"BigNumber",value:this.toString()}},r.fromJSON=function(e){return new r(e.value)},t&&t("config",(function(e,t){e.precision!==t.precision&&r.config({precision:e.precision})})),r}),{isClass:!0});const Qt=Math.cosh||function(e){return Math.abs(e)<1e-9?1-e:.5*(Math.exp(e)+Math.exp(-e))},Zt=Math.sinh||function(e){return Math.abs(e)<1e-9?e:.5*(Math.exp(e)-Math.exp(-e))},Jt=function(e,t){return(e=Math.abs(e))<(t=Math.abs(t))&&([e,t]=[t,e]),e<1e8?Math.sqrt(e*e+t*t):(t/=e,e*Math.sqrt(1+t*t))},$t=function(){throw SyntaxError("Invalid Param")};function en(e,t){const n=Math.abs(e),r=Math.abs(t);return 0===e?Math.log(r):0===t?Math.log(n):n<3e3&&r<3e3?.5*Math.log(e*e+t*t):(e*=.5,t*=.5,.5*Math.log(e*e+t*t)+Math.LN2)}const tn={re:0,im:0},nn=function(e,t){const n=tn;if(void 0===e||null===e)n.re=n.im=0;else if(void 0!==t)n.re=e,n.im=t;else switch(typeof e){case"object":if("im"in e&&"re"in e)n.re=e.re,n.im=e.im;else if("abs"in e&&"arg"in e){if(!isFinite(e.abs)&&isFinite(e.arg))return rn.INFINITY;n.re=e.abs*Math.cos(e.arg),n.im=e.abs*Math.sin(e.arg)}else if("r"in e&&"phi"in e){if(!isFinite(e.r)&&isFinite(e.phi))return rn.INFINITY;n.re=e.r*Math.cos(e.phi),n.im=e.r*Math.sin(e.phi)}else 2===e.length?(n.re=e[0],n.im=e[1]):$t();break;case"string":n.im=n.re=0;const t=e.replace(/_/g,"").match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);let r=1,a=0;null===t&&$t();for(let e=0;e<t.length;e++){const o=t[e];" "===o||"\t"===o||"\n"===o||("+"===o?r++:"-"===o?a++:"i"===o||"I"===o?(r+a===0&&$t()," "===t[e+1]||isNaN(t[e+1])?n.im+=parseFloat((a%2?"-":"")+"1"):(n.im+=parseFloat((a%2?"-":"")+t[e+1]),e++),r=a=0):((r+a===0||isNaN(o))&&$t(),"i"===t[e+1]||"I"===t[e+1]?(n.im+=parseFloat((a%2?"-":"")+o),e++):n.re+=parseFloat((a%2?"-":"")+o),r=a=0))}r+a>0&&$t();break;case"number":n.im=0,n.re=e;break;default:$t()}return isNaN(n.re)||isNaN(n.im),n};function rn(e,t){if(!(this instanceof rn))return new rn(e,t);const n=nn(e,t);this.re=n.re,this.im=n.im}function an(e){return"boolean"===typeof e||!!isFinite(e)&&e===Math.round(e)}rn.prototype={re:0,im:0,sign:function(){const e=Jt(this.re,this.im);return new rn(this.re/e,this.im/e)},add:function(e,t){const n=nn(e,t),r=this.isInfinite(),a=!(isFinite(n.re)&&isFinite(n.im));return r||a?r&&a?rn.NAN:rn.INFINITY:new rn(this.re+n.re,this.im+n.im)},sub:function(e,t){const n=nn(e,t),r=this.isInfinite(),a=!(isFinite(n.re)&&isFinite(n.im));return r||a?r&&a?rn.NAN:rn.INFINITY:new rn(this.re-n.re,this.im-n.im)},mul:function(e,t){const n=nn(e,t),r=this.isInfinite(),a=!(isFinite(n.re)&&isFinite(n.im)),o=0===this.re&&0===this.im,i=0===n.re&&0===n.im;return r&&i||a&&o?rn.NAN:r||a?rn.INFINITY:0===n.im&&0===this.im?new rn(this.re*n.re,0):new rn(this.re*n.re-this.im*n.im,this.re*n.im+this.im*n.re)},div:function(e,t){const n=nn(e,t),r=this.isInfinite(),a=!(isFinite(n.re)&&isFinite(n.im)),o=0===this.re&&0===this.im,i=0===n.re&&0===n.im;if(o&&i||r&&a)return rn.NAN;if(i||r)return rn.INFINITY;if(o||a)return rn.ZERO;if(0===n.im)return new rn(this.re/n.re,this.im/n.re);if(Math.abs(n.re)<Math.abs(n.im)){const e=n.re/n.im,t=n.re*e+n.im;return new rn((this.re*e+this.im)/t,(this.im*e-this.re)/t)}{const e=n.im/n.re,t=n.im*e+n.re;return new rn((this.re+this.im*e)/t,(this.im-this.re*e)/t)}},pow:function(e,t){const n=nn(e,t),r=0===this.re&&0===this.im;if(0===n.re&&0===n.im)return rn.ONE;if(0===n.im){if(0===this.im&&this.re>0)return new rn(Math.pow(this.re,n.re),0);if(0===this.re)switch((n.re%4+4)%4){case 0:return new rn(Math.pow(this.im,n.re),0);case 1:return new rn(0,Math.pow(this.im,n.re));case 2:return new rn(-Math.pow(this.im,n.re),0);case 3:return new rn(0,-Math.pow(this.im,n.re))}}if(r&&n.re>0)return rn.ZERO;const a=Math.atan2(this.im,this.re),o=en(this.re,this.im);let i=Math.exp(n.re*o-n.im*a),s=n.im*o+n.re*a;return new rn(i*Math.cos(s),i*Math.sin(s))},sqrt:function(){const e=this.re,t=this.im;if(0===t)return e>=0?new rn(Math.sqrt(e),0):new rn(0,Math.sqrt(-e));const n=Jt(e,t);let r=Math.sqrt(.5*(n+Math.abs(e))),a=Math.abs(t)/(2*r);return e>=0?new rn(r,t<0?-a:a):new rn(a,t<0?-r:r)},exp:function(){const e=Math.exp(this.re);return 0===this.im?new rn(e,0):new rn(e*Math.cos(this.im),e*Math.sin(this.im))},expm1:function(){const e=this.re,t=this.im;return new rn(Math.expm1(e)*Math.cos(t)+function(e){const t=Math.PI/4;if(-t>e||e>t)return Math.cos(e)-1;const n=e*e;return n*(n*(n*(n*(n*(n*(n*(n/20922789888e3-1/87178291200)+1/479001600)-1/3628800)+1/40320)-1/720)+1/24)-.5)}(t),Math.exp(e)*Math.sin(t))},log:function(){const e=this.re,t=this.im;return 0===t&&e>0?new rn(Math.log(e),0):new rn(en(e,t),Math.atan2(t,e))},abs:function(){return Jt(this.re,this.im)},arg:function(){return Math.atan2(this.im,this.re)},sin:function(){const e=this.re,t=this.im;return new rn(Math.sin(e)*Qt(t),Math.cos(e)*Zt(t))},cos:function(){const e=this.re,t=this.im;return new rn(Math.cos(e)*Qt(t),-Math.sin(e)*Zt(t))},tan:function(){const e=2*this.re,t=2*this.im,n=Math.cos(e)+Qt(t);return new rn(Math.sin(e)/n,Zt(t)/n)},cot:function(){const e=2*this.re,t=2*this.im,n=Math.cos(e)-Qt(t);return new rn(-Math.sin(e)/n,Zt(t)/n)},sec:function(){const e=this.re,t=this.im,n=.5*Qt(2*t)+.5*Math.cos(2*e);return new rn(Math.cos(e)*Qt(t)/n,Math.sin(e)*Zt(t)/n)},csc:function(){const e=this.re,t=this.im,n=.5*Qt(2*t)-.5*Math.cos(2*e);return new rn(Math.sin(e)*Qt(t)/n,-Math.cos(e)*Zt(t)/n)},asin:function(){const e=this.re,t=this.im,n=new rn(t*t-e*e+1,-2*e*t).sqrt(),r=new rn(n.re-t,n.im+e).log();return new rn(r.im,-r.re)},acos:function(){const e=this.re,t=this.im,n=new rn(t*t-e*e+1,-2*e*t).sqrt(),r=new rn(n.re-t,n.im+e).log();return new rn(Math.PI/2-r.im,r.re)},atan:function(){const e=this.re,t=this.im;if(0===e){if(1===t)return new rn(0,1/0);if(-1===t)return new rn(0,-1/0)}const n=e*e+(1-t)*(1-t),r=new rn((1-t*t-e*e)/n,-2*e/n).log();return new rn(-.5*r.im,.5*r.re)},acot:function(){const e=this.re,t=this.im;if(0===t)return new rn(Math.atan2(1,e),0);const n=e*e+t*t;return 0!==n?new rn(e/n,-t/n).atan():new rn(0!==e?e/0:0,0!==t?-t/0:0).atan()},asec:function(){const e=this.re,t=this.im;if(0===e&&0===t)return new rn(0,1/0);const n=e*e+t*t;return 0!==n?new rn(e/n,-t/n).acos():new rn(0!==e?e/0:0,0!==t?-t/0:0).acos()},acsc:function(){const e=this.re,t=this.im;if(0===e&&0===t)return new rn(Math.PI/2,1/0);const n=e*e+t*t;return 0!==n?new rn(e/n,-t/n).asin():new rn(0!==e?e/0:0,0!==t?-t/0:0).asin()},sinh:function(){const e=this.re,t=this.im;return new rn(Zt(e)*Math.cos(t),Qt(e)*Math.sin(t))},cosh:function(){const e=this.re,t=this.im;return new rn(Qt(e)*Math.cos(t),Zt(e)*Math.sin(t))},tanh:function(){const e=2*this.re,t=2*this.im,n=Qt(e)+Math.cos(t);return new rn(Zt(e)/n,Math.sin(t)/n)},coth:function(){const e=2*this.re,t=2*this.im,n=Qt(e)-Math.cos(t);return new rn(Zt(e)/n,-Math.sin(t)/n)},csch:function(){const e=this.re,t=this.im,n=Math.cos(2*t)-Qt(2*e);return new rn(-2*Zt(e)*Math.cos(t)/n,2*Qt(e)*Math.sin(t)/n)},sech:function(){const e=this.re,t=this.im,n=Math.cos(2*t)+Qt(2*e);return new rn(2*Qt(e)*Math.cos(t)/n,-2*Zt(e)*Math.sin(t)/n)},asinh:function(){let e=this.im;this.im=-this.re,this.re=e;const t=this.asin();return this.re=-this.im,this.im=e,e=t.re,t.re=-t.im,t.im=e,t},acosh:function(){const e=this.acos();if(e.im<=0){const t=e.re;e.re=-e.im,e.im=t}else{const t=e.im;e.im=-e.re,e.re=t}return e},atanh:function(){const e=this.re,t=this.im,n=e>1&&0===t,r=1-e,a=1+e,o=r*r+t*t,i=0!==o?new rn((a*r-t*t)/o,(t*r+a*t)/o):new rn(-1!==e?e/0:0,0!==t?t/0:0),s=i.re;return i.re=en(i.re,i.im)/2,i.im=Math.atan2(i.im,s)/2,n&&(i.im=-i.im),i},acoth:function(){const e=this.re,t=this.im;if(0===e&&0===t)return new rn(0,Math.PI/2);const n=e*e+t*t;return 0!==n?new rn(e/n,-t/n).atanh():new rn(0!==e?e/0:0,0!==t?-t/0:0).atanh()},acsch:function(){const e=this.re,t=this.im;if(0===t)return new rn(0!==e?Math.log(e+Math.sqrt(e*e+1)):1/0,0);const n=e*e+t*t;return 0!==n?new rn(e/n,-t/n).asinh():new rn(0!==e?e/0:0,0!==t?-t/0:0).asinh()},asech:function(){const e=this.re,t=this.im;if(this.isZero())return rn.INFINITY;const n=e*e+t*t;return 0!==n?new rn(e/n,-t/n).acosh():new rn(0!==e?e/0:0,0!==t?-t/0:0).acosh()},inverse:function(){if(this.isZero())return rn.INFINITY;if(this.isInfinite())return rn.ZERO;const e=this.re,t=this.im,n=e*e+t*t;return new rn(e/n,-t/n)},conjugate:function(){return new rn(this.re,-this.im)},neg:function(){return new rn(-this.re,-this.im)},ceil:function(e){return e=Math.pow(10,e||0),new rn(Math.ceil(this.re*e)/e,Math.ceil(this.im*e)/e)},floor:function(e){return e=Math.pow(10,e||0),new rn(Math.floor(this.re*e)/e,Math.floor(this.im*e)/e)},round:function(e){return e=Math.pow(10,e||0),new rn(Math.round(this.re*e)/e,Math.round(this.im*e)/e)},equals:function(e,t){const n=nn(e,t);return Math.abs(n.re-this.re)<=rn.EPSILON&&Math.abs(n.im-this.im)<=rn.EPSILON},clone:function(){return new rn(this.re,this.im)},toString:function(){let e=this.re,t=this.im,n="";return this.isNaN()?"NaN":this.isInfinite()?"Infinity":(Math.abs(e)<rn.EPSILON&&(e=0),Math.abs(t)<rn.EPSILON&&(t=0),0===t?n+e:(0!==e?(n+=e,n+=" ",t<0?(t=-t,n+="-"):n+="+",n+=" "):t<0&&(t=-t,n+="-"),1!==t&&(n+=t),n+"i"))},toVector:function(){return[this.re,this.im]},valueOf:function(){return 0===this.im?this.re:null},isNaN:function(){return isNaN(this.re)||isNaN(this.im)},isZero:function(){return 0===this.im&&0===this.re},isFinite:function(){return isFinite(this.re)&&isFinite(this.im)},isInfinite:function(){return!this.isFinite()}},rn.ZERO=new rn(0,0),rn.ONE=new rn(1,0),rn.I=new rn(0,1),rn.PI=new rn(Math.PI,0),rn.E=new rn(Math.E,0),rn.INFINITY=new rn(1/0,1/0),rn.NAN=new rn(NaN,NaN),rn.EPSILON=1e-15;var on=Math.sign||function(e){return e>0?1:e<0?-1:0},sn=Math.log2||function(e){return Math.log(e)/Math.LN2},un=Math.log10||function(e){return Math.log(e)/Math.LN10},cn=(Math.log1p,Math.cbrt||function(e){if(0===e)return e;var t,n=e<0;return n&&(e=-e),t=isFinite(e)?(e/((t=Math.exp(Math.log(e)/3))*t)+2*t)/3:e,n?-t:t}),ln=Math.expm1||function(e){return e>=2e-4||e<=-2e-4?Math.exp(e)-1:e+e*e/2+e*e*e/6};function hn(e,t,n){var r={2:"0b",8:"0o",16:"0x"}[t],a="";if(n){if(n<1)throw new Error("size must be in greater than 0");if(!an(n))throw new Error("size must be an integer");if(e>2**(n-1)-1||e<-(2**(n-1)))throw new Error("Value must be in range [-2^".concat(n-1,", 2^").concat(n-1,"-1]"));if(!an(e))throw new Error("Value must be an integer");e<0&&(e+=2**n),a="i".concat(n)}var o="";return e<0&&(e=-e,o="-"),"".concat(o).concat(r).concat(e.toString(t)).concat(a)}function dn(e,t){if("function"===typeof t)return t(e);if(e===1/0)return"Infinity";if(e===-1/0)return"-Infinity";if(isNaN(e))return"NaN";var{notation:n,precision:r,wordSize:a}=pn(t);switch(n){case"fixed":return mn(e,r);case"exponential":return gn(e,r);case"engineering":return function(e,t){if(isNaN(e)||!isFinite(e))return String(e);var n=fn(e),r=yn(n,t),a=r.exponent,o=r.coefficients,i=a%3===0?a:a<0?a-3-a%3:a-a%3;if(nt(t))for(;t>o.length||a-i+1>o.length;)o.push(0);else for(var s=Math.abs(a-i)-(o.length-1),u=0;u<s;u++)o.push(0);var c=Math.abs(a-i),l=1;for(;c>0;)l++,c--;var h=o.slice(l).join(""),d=nt(t)&&h.length||h.match(/[1-9]/)?"."+h:"",p=o.slice(0,l).join("")+d+"e"+(a>=0?"+":"")+i.toString();return r.sign+p}(e,r);case"bin":return hn(e,2,a);case"oct":return hn(e,8,a);case"hex":return hn(e,16,a);case"auto":return function(e,t,n){if(isNaN(e)||!isFinite(e))return String(e);var r=Sn(null===n||void 0===n?void 0:n.lowerExp,-3),a=Sn(null===n||void 0===n?void 0:n.upperExp,5),o=fn(e),i=t?yn(o,t):o;if(i.exponent<r||i.exponent>=a)return gn(e,t);var s=i.coefficients,u=i.exponent;s.length<t&&(s=s.concat(bn(t-s.length))),s=s.concat(bn(u-s.length+1+(s.length<t?t-s.length:0)));var c=u>0?u:0;return c<(s=bn(-u).concat(s)).length-1&&s.splice(c+1,0,"."),i.sign+s.join("")}(e,r,t).replace(/((\.\d*?)(0+))($|e)/,(function(){var e=arguments[2],t=arguments[4];return"."!==e?e+t:t}));default:throw new Error('Unknown notation "'+n+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function pn(e){var t,n,r="auto";if(void 0!==e)if(nt(e))t=e;else if(rt(e))t=e.toNumber();else{if(!kt(e))throw new Error("Unsupported type of options, number, BigNumber, or object expected");void 0!==e.precision&&(t=Dn(e.precision,(()=>{throw new Error('Option "precision" must be a number or BigNumber')}))),void 0!==e.wordSize&&(n=Dn(e.wordSize,(()=>{throw new Error('Option "wordSize" must be a number or BigNumber')}))),e.notation&&(r=e.notation)}return{notation:r,precision:t,wordSize:n}}function fn(e){var t=String(e).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);if(!t)throw new SyntaxError("Invalid number "+e);var n=t[1],r=t[2],a=parseFloat(t[4]||"0"),o=r.indexOf(".");a+=-1!==o?o-1:r.length-1;var i=r.replace(".","").replace(/^0*/,(function(e){return a-=e.length,""})).replace(/0*$/,"").split("").map((function(e){return parseInt(e)}));return 0===i.length&&(i.push(0),a++),{sign:n,coefficients:i,exponent:a}}function mn(e,t){if(isNaN(e)||!isFinite(e))return String(e);var n=fn(e),r="number"===typeof t?yn(n,n.exponent+1+t):n,a=r.coefficients,o=r.exponent+1,i=o+(t||0);return a.length<i&&(a=a.concat(bn(i-a.length))),o<0&&(a=bn(1-o).concat(a),o=1),o<a.length&&a.splice(o,0,0===o?"0.":"."),r.sign+a.join("")}function gn(e,t){if(isNaN(e)||!isFinite(e))return String(e);var n=fn(e),r=t?yn(n,t):n,a=r.coefficients,o=r.exponent;a.length<t&&(a=a.concat(bn(t-a.length)));var i=a.shift();return r.sign+i+(a.length>0?"."+a.join(""):"")+"e"+(o>=0?"+":"")+o}function yn(e,t){for(var n={sign:e.sign,coefficients:e.coefficients,exponent:e.exponent},r=n.coefficients;t<=0;)r.unshift(0),n.exponent++,t++;if(r.length>t&&r.splice(t,r.length-t)[0]>=5){var a=t-1;for(r[a]++;10===r[a];)r.pop(),0===a&&(r.unshift(0),n.exponent++,a++),r[--a]++}return n}function bn(e){for(var t=[],n=0;n<e;n++)t.push(0);return t}Number.EPSILON;function vn(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e-8,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(n<=0)throw new Error("Relative tolerance must be greater than 0");if(r<0)throw new Error("Absolute tolerance must be at least 0");return!isNaN(e)&&!isNaN(t)&&(isFinite(e)&&isFinite(t)?e===t||Math.abs(e-t)<=Math.max(n*Math.max(Math.abs(e),Math.abs(t)),r):e===t)}var xn=Math.acosh||function(e){return Math.log(Math.sqrt(e*e-1)+e)},wn=Math.asinh||function(e){return Math.log(Math.sqrt(e*e+1)+e)},kn=Math.atanh||function(e){return Math.log((1+e)/(1-e))/2},Cn=(Math.cosh,Math.sinh||function(e){return(Math.exp(e)-Math.exp(-e))/2});Math.tanh;function Dn(e,t){return nt(e)?e:rt(e)?e.toNumber():void t()}function Sn(e,t){return nt(e)?e:rt(e)?e.toNumber():t}var En=Kt("Complex",[],(()=>(Object.defineProperty(rn,"name",{value:"Complex"}),rn.prototype.constructor=rn,rn.prototype.type="Complex",rn.prototype.isComplex=!0,rn.prototype.toJSON=function(){return{mathjs:"Complex",re:this.re,im:this.im}},rn.prototype.toPolar=function(){return{r:this.abs(),phi:this.arg()}},rn.prototype.format=function(e){var t=this.im,n=this.re,r=dn(this.re,e),a=dn(this.im,e),o=nt(e)?e:e?e.precision:null;if(null!==o){var i=Math.pow(10,-o);Math.abs(n/t)<i&&(n=0),Math.abs(t/n)<i&&(t=0)}return 0===t?r:0===n?1===t?"i":-1===t?"-i":a+"i":t<0?-1===t?r+" - i":r+" - "+a.substring(1)+"i":1===t?r+" + i":r+" + "+a+"i"},rn.fromPolar=function(e){switch(arguments.length){case 1:var t=arguments[0];if("object"===typeof t)return rn(t);throw new TypeError("Input has to be an object with r and phi keys.");case 2:var n=arguments[0],r=arguments[1];if(nt(n)){if(st(r)&&r.hasBase("ANGLE")&&(r=r.toNumber("rad")),nt(r))return new rn({r:n,phi:r});throw new TypeError("Phi is not a number nor an angle unit.")}throw new TypeError("Radius r is not a number.");default:throw new SyntaxError("Wrong number of arguments in function fromPolar")}},rn.prototype.valueOf=rn.prototype.toString,rn.fromJSON=function(e){return new rn(e)},rn.compare=function(e,t){return e.re>t.re?1:e.re<t.re?-1:e.im>t.im?1:e.im<t.im?-1:0},rn)),{isClass:!0});function In(e){var t=0,n=1,r=Object.create(null),a=Object.create(null),o=0,i=function(e){var i=a[e];if(i&&(delete r[i],delete a[e],--t,n===i)){if(!t)return o=0,void(n=1);for(;!Object.prototype.hasOwnProperty.call(r,++n););}};return e=Math.abs(e),{hit:function(s){var u=a[s],c=++o;if(r[c]=s,a[s]=c,!u){if(++t<=e)return;return s=r[n],i(s),s}if(delete r[u],n===u)for(;!Object.prototype.hasOwnProperty.call(r,++n););},delete:i,clear:function(){t=o=0,n=1,r=Object.create(null),a=Object.create(null)}}}function Nn(e){var{hasher:t,limit:n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return n=null==n?Number.POSITIVE_INFINITY:n,t=null==t?JSON.stringify:t,function r(){"object"!==typeof r.cache&&(r.cache={values:new Map,lru:In(n||Number.POSITIVE_INFINITY)});for(var a=[],o=0;o<arguments.length;o++)a[o]=arguments[o];var i=t(a);if(r.cache.values.has(i))return r.cache.lru.hit(i),r.cache.values.get(i);var s=e.apply(e,a);return r.cache.values.set(i,s),r.cache.values.delete(r.cache.lru.hit(i)),s}}Nn((function(e){return new e(1).exp()}),{hasher:An}),Nn((function(e){return new e(1).plus(new e(5).sqrt()).div(2)}),{hasher:An});var Tn=Nn((function(e){return e.acos(-1)}),{hasher:An});Nn((function(e){return Tn(e).times(2)}),{hasher:An});function An(e){return e[0].precision}Math.PI,Math.PI,Math.E;Fn("fineStructure",.0072973525693),Fn("weakMixingAngle",.2229),Fn("efimovFactor",22.7),Fn("sackurTetrode",-1.16487052358);function Fn(e,t){return Kt(e,["config","BigNumber"],(e=>{var{config:n,BigNumber:r}=e;return"BigNumber"===n.number?new r(t):t}))}"undefined"===typeof BigInt&&(BigInt=function(e){if(isNaN(e))throw new Error("");return e});const _n=BigInt(0),Rn=BigInt(1),Mn=BigInt(2),On=BigInt(5),zn=BigInt(10),Ln={s:Rn,n:_n,d:Rn};function Bn(e,t){try{e=BigInt(e)}catch(n){throw Kn()}return e*t}function Pn(e){return"bigint"===typeof e?e:Math.floor(e)}function Wn(e,t){if(t===_n)throw qn();const n=Object.create(Hn.prototype);n.s=e<_n?-Rn:Rn;const r=jn(e=e<_n?-e:e,t);return n.n=e/r,n.d=t/r,n}function Un(e){const t={};let n=e,r=Mn,a=On-Rn;for(;a<=n;){for(;n%r===_n;)n/=r,t[r]=(t[r]||_n)+Rn;a+=Rn+Mn*r++}return n!==e?n>1&&(t[n]=(t[n]||_n)+Rn):t[e]=(t[e]||_n)+Rn,t}const Vn=function(e,t){let n=_n,r=Rn,a=Rn;if(void 0===e||null===e);else if(void 0!==t){if("bigint"===typeof e)n=e;else{if(isNaN(e))throw Kn();if(e%1!==0)throw Xn();n=BigInt(e)}if("bigint"===typeof t)r=t;else{if(isNaN(t))throw Kn();if(t%1!==0)throw Xn();r=BigInt(t)}a=n*r}else if("object"===typeof e){if("d"in e&&"n"in e)n=BigInt(e.n),r=BigInt(e.d),"s"in e&&(n*=BigInt(e.s));else if(0 in e)n=BigInt(e[0]),1 in e&&(r=BigInt(e[1]));else{if("bigint"!==typeof e)throw Kn();n=e}a=n*r}else if("number"===typeof e){if(isNaN(e))throw Kn();if(e<0&&(a=-Rn,e=-e),e%1===0)n=BigInt(e);else if(e>0){let t=1,a=0,o=1,i=1,s=1,u=1e7;for(e>=1&&(t=10**Math.floor(1+Math.log10(e)),e/=t);o<=u&&s<=u;){let t=(a+i)/(o+s);if(e===t){o+s<=u?(n=a+i,r=o+s):s>o?(n=i,r=s):(n=a,r=o);break}e>t?(a+=i,o+=s):(i+=a,s+=o),o>u?(n=i,r=s):(n=a,r=o)}n=BigInt(n)*BigInt(t),r=BigInt(r)}}else if("string"===typeof e){let t=0,o=_n,i=_n,s=_n,u=Rn,c=Rn,l=e.replace(/_/g,"").match(/\d+|./g);if(null===l)throw Kn();if("-"===l[t]?(a=-Rn,t++):"+"===l[t]&&t++,l.length===t+1?i=Bn(l[t++],a):"."===l[t+1]||"."===l[t]?("."!==l[t]&&(o=Bn(l[t++],a)),t++,(t+1===l.length||"("===l[t+1]&&")"===l[t+3]||"'"===l[t+1]&&"'"===l[t+3])&&(i=Bn(l[t],a),u=zn**BigInt(l[t].length),t++),("("===l[t]&&")"===l[t+2]||"'"===l[t]&&"'"===l[t+2])&&(s=Bn(l[t+1],a),c=zn**BigInt(l[t+1].length)-Rn,t+=3)):"/"===l[t+1]||":"===l[t+1]?(i=Bn(l[t],a),u=Bn(l[t+2],Rn),t+=3):"/"===l[t+3]&&" "===l[t+1]&&(o=Bn(l[t],a),i=Bn(l[t+2],a),u=Bn(l[t+4],Rn),t+=5),!(l.length<=t))throw Kn();r=u*c,a=n=s+r*o+c*i}else{if("bigint"!==typeof e)throw Kn();n=e,a=e,r=Rn}if(r===_n)throw qn();Ln.s=a<_n?-Rn:Rn,Ln.n=n<_n?-n:n,Ln.d=r<_n?-r:r};function Gn(e,t,n){let r=Rn,a=function(e,t,n){let r=Rn;for(;t>_n;e=e*e%n,t>>=Rn)t&Rn&&(r=r*e%n);return r}(zn,n,t);for(let o=0;o<300;o++){if(r===a)return BigInt(o);r=r*zn%t,a=a*zn%t}return 0}function jn(e,t){if(!e)return t;if(!t)return e;for(;;){if(!(e%=t))return t;if(!(t%=e))return e}}function Hn(e,t){if(Vn(e,t),!(this instanceof Hn))return Wn(Ln.s*Ln.n,Ln.d);e=jn(Ln.d,Ln.n),this.s=Ln.s,this.n=Ln.n/e,this.d=Ln.d/e}var qn=function(){return new Error("Division by Zero")},Kn=function(){return new Error("Invalid argument")},Xn=function(){return new Error("Parameters must be integer")};Hn.prototype={s:Rn,n:_n,d:Rn,abs:function(){return Wn(this.n,this.d)},neg:function(){return Wn(-this.s*this.n,this.d)},add:function(e,t){return Vn(e,t),Wn(this.s*this.n*Ln.d+Ln.s*this.d*Ln.n,this.d*Ln.d)},sub:function(e,t){return Vn(e,t),Wn(this.s*this.n*Ln.d-Ln.s*this.d*Ln.n,this.d*Ln.d)},mul:function(e,t){return Vn(e,t),Wn(this.s*Ln.s*this.n*Ln.n,this.d*Ln.d)},div:function(e,t){return Vn(e,t),Wn(this.s*Ln.s*this.n*Ln.d,this.d*Ln.n)},clone:function(){return Wn(this.s*this.n,this.d)},mod:function(e,t){if(void 0===e)return Wn(this.s*this.n%this.d,Rn);if(Vn(e,t),_n===Ln.n*this.d)throw qn();return Wn(this.s*(Ln.d*this.n)%(Ln.n*this.d),Ln.d*this.d)},gcd:function(e,t){return Vn(e,t),Wn(jn(Ln.n,this.n)*jn(Ln.d,this.d),Ln.d*this.d)},lcm:function(e,t){return Vn(e,t),Ln.n===_n&&this.n===_n?Wn(_n,Rn):Wn(Ln.n*this.n,jn(Ln.n,this.n)*jn(Ln.d,this.d))},inverse:function(){return Wn(this.s*this.d,this.n)},pow:function(e,t){if(Vn(e,t),Ln.d===Rn)return Ln.s<_n?Wn((this.s*this.d)**Ln.n,this.n**Ln.n):Wn((this.s*this.n)**Ln.n,this.d**Ln.n);if(this.s<_n)return null;let n=Un(this.n),r=Un(this.d),a=Rn,o=Rn;for(let i in n)if("1"!==i){if("0"===i){a=_n;break}if(n[i]*=Ln.n,n[i]%Ln.d!==_n)return null;n[i]/=Ln.d,a*=BigInt(i)**n[i]}for(let i in r)if("1"!==i){if(r[i]*=Ln.n,r[i]%Ln.d!==_n)return null;r[i]/=Ln.d,o*=BigInt(i)**r[i]}return Ln.s<_n?Wn(o,a):Wn(a,o)},log:function(e,t){if(Vn(e,t),this.s<=_n||Ln.s<=_n)return null;const n={},r=Un(Ln.n),a=Un(Ln.d),o=Un(this.n),i=Un(this.d);for(const c in a)r[c]=(r[c]||_n)-a[c];for(const c in i)o[c]=(o[c]||_n)-i[c];for(const c in r)"1"!==c&&(n[c]=!0);for(const c in o)"1"!==c&&(n[c]=!0);let s=null,u=null;for(const c in n){const e=r[c]||_n,t=o[c]||_n;if(e===_n){if(t!==_n)return null;continue}let n=t,a=e;const i=jn(n,a);if(n/=i,a/=i,null===s&&null===u)s=n,u=a;else if(n*u!==s*a)return null}return null!==s&&null!==u?Wn(s,u):null},equals:function(e,t){return Vn(e,t),this.s*this.n*Ln.d===Ln.s*Ln.n*this.d},lt:function(e,t){return Vn(e,t),this.s*this.n*Ln.d<Ln.s*Ln.n*this.d},lte:function(e,t){return Vn(e,t),this.s*this.n*Ln.d<=Ln.s*Ln.n*this.d},gt:function(e,t){return Vn(e,t),this.s*this.n*Ln.d>Ln.s*Ln.n*this.d},gte:function(e,t){return Vn(e,t),this.s*this.n*Ln.d>=Ln.s*Ln.n*this.d},compare:function(e,t){Vn(e,t);let n=this.s*this.n*Ln.d-Ln.s*Ln.n*this.d;return(_n<n)-(n<_n)},ceil:function(e){return e=zn**BigInt(e||0),Wn(Pn(this.s*e*this.n/this.d)+(e*this.n%this.d>_n&&this.s>=_n?Rn:_n),e)},floor:function(e){return e=zn**BigInt(e||0),Wn(Pn(this.s*e*this.n/this.d)-(e*this.n%this.d>_n&&this.s<_n?Rn:_n),e)},round:function(e){return e=zn**BigInt(e||0),Wn(Pn(this.s*e*this.n/this.d)+this.s*((this.s>=_n?Rn:_n)+Mn*(e*this.n%this.d)>this.d?Rn:_n),e)},roundTo:function(e,t){Vn(e,t);const n=this.n*Ln.d,r=this.d*Ln.n,a=n%r;let o=Pn(n/r);return a+a>=r&&o++,Wn(this.s*o*Ln.n,Ln.d)},divisible:function(e,t){return Vn(e,t),!(!(Ln.n*this.d)||this.n*Ln.d%(Ln.n*this.d))},valueOf:function(){return Number(this.s*this.n)/Number(this.d)},toString:function(e){let t=this.n,n=this.d;e=e||15;let r=function(e,t){for(;t%Mn===_n;t/=Mn);for(;t%On===_n;t/=On);if(t===Rn)return _n;let n=zn%t,r=1;for(;n!==Rn;r++)if(n=n*zn%t,r>2e3)return _n;return BigInt(r)}(0,n),a=Gn(0,n,r),o=this.s<_n?"-":"";if(o+=Pn(t/n),t%=n,t*=zn,t&&(o+="."),r){for(let e=a;e--;)o+=Pn(t/n),t%=n,t*=zn;o+="(";for(let e=r;e--;)o+=Pn(t/n),t%=n,t*=zn;o+=")"}else for(let i=e;t&&i--;)o+=Pn(t/n),t%=n,t*=zn;return o},toFraction:function(e){let t=this.n,n=this.d,r=this.s<_n?"-":"";if(n===Rn)r+=t;else{let a=Pn(t/n);e&&a>_n&&(r+=a,r+=" ",t%=n),r+=t,r+="/",r+=n}return r},toLatex:function(e){let t=this.n,n=this.d,r=this.s<_n?"-":"";if(n===Rn)r+=t;else{let a=Pn(t/n);e&&a>_n&&(r+=a,t%=n),r+="\\frac{",r+=t,r+="}{",r+=n,r+="}"}return r},toContinued:function(){let e=this.n,t=this.d,n=[];do{n.push(Pn(e/t));let r=e%t;e=t,t=r}while(e!==Rn);return n},simplify:function(e){const t=BigInt(1/(e||.001)|0),n=this.abs(),r=n.toContinued();for(let a=1;a<r.length;a++){let e=Wn(r[a-1],Rn);for(let t=a-2;t>=0;t--)e=e.inverse().add(r[t]);let o=e.sub(n);if(o.n*t<o.d)return e.mul(this.s)}return this}};var Yn=Kt("Fraction",[],(()=>(Object.defineProperty(Hn,"name",{value:"Fraction"}),Hn.prototype.constructor=Hn,Hn.prototype.type="Fraction",Hn.prototype.isFraction=!0,Hn.prototype.toJSON=function(){return{mathjs:"Fraction",n:String(this.s*this.n),d:String(this.d)}},Hn.fromJSON=function(e){return new Hn(e)},Hn)),{isClass:!0}),Qn=Kt("Matrix",[],(()=>{function e(){if(!(this instanceof e))throw new SyntaxError("Constructor must be called with the new operator")}return e.prototype.type="Matrix",e.prototype.isMatrix=!0,e.prototype.storage=function(){throw new Error("Cannot invoke storage on a Matrix interface")},e.prototype.datatype=function(){throw new Error("Cannot invoke datatype on a Matrix interface")},e.prototype.create=function(e,t){throw new Error("Cannot invoke create on a Matrix interface")},e.prototype.subset=function(e,t,n){throw new Error("Cannot invoke subset on a Matrix interface")},e.prototype.get=function(e){throw new Error("Cannot invoke get on a Matrix interface")},e.prototype.set=function(e,t,n){throw new Error("Cannot invoke set on a Matrix interface")},e.prototype.resize=function(e,t){throw new Error("Cannot invoke resize on a Matrix interface")},e.prototype.reshape=function(e,t){throw new Error("Cannot invoke reshape on a Matrix interface")},e.prototype.clone=function(){throw new Error("Cannot invoke clone on a Matrix interface")},e.prototype.size=function(){throw new Error("Cannot invoke size on a Matrix interface")},e.prototype.map=function(e,t){throw new Error("Cannot invoke map on a Matrix interface")},e.prototype.forEach=function(e){throw new Error("Cannot invoke forEach on a Matrix interface")},e.prototype[Symbol.iterator]=function(){throw new Error("Cannot iterate a Matrix interface")},e.prototype.toArray=function(){throw new Error("Cannot invoke toArray on a Matrix interface")},e.prototype.valueOf=function(){throw new Error("Cannot invoke valueOf on a Matrix interface")},e.prototype.format=function(e){throw new Error("Cannot invoke format on a Matrix interface")},e.prototype.toString=function(){throw new Error("Cannot invoke toString on a Matrix interface")},e}),{isClass:!0});function Zn(e,t,n){var r=new(0,e.constructor)(2),a="";if(n){if(n<1)throw new Error("size must be in greater than 0");if(!an(n))throw new Error("size must be an integer");if(e.greaterThan(r.pow(n-1).sub(1))||e.lessThan(r.pow(n-1).mul(-1)))throw new Error("Value must be in range [-2^".concat(n-1,", 2^").concat(n-1,"-1]"));if(!e.isInteger())throw new Error("Value must be an integer");e.lessThan(0)&&(e=e.add(r.pow(n))),a="i".concat(n)}switch(t){case 2:return"".concat(e.toBinary()).concat(a);case 8:return"".concat(e.toOctal()).concat(a);case 16:return"".concat(e.toHexadecimal()).concat(a);default:throw new Error("Base ".concat(t," not supported "))}}function Jn(e,t){if("function"===typeof t)return t(e);if(!e.isFinite())return e.isNaN()?"NaN":e.gt(0)?"Infinity":"-Infinity";var{notation:n,precision:r,wordSize:a}=pn(t);switch(n){case"fixed":return function(e,t){return e.toFixed(t)}(e,r);case"exponential":return $n(e,r);case"engineering":return function(e,t){var n=e.e,r=n%3===0?n:n<0?n-3-n%3:n-n%3,a=e.mul(Math.pow(10,-r)),o=a.toPrecision(t);if(o.includes("e")){o=new(0,e.constructor)(o).toFixed()}return o+"e"+(n>=0?"+":"")+r.toString()}(e,r);case"bin":return Zn(e,2,a);case"oct":return Zn(e,8,a);case"hex":return Zn(e,16,a);case"auto":var o=er(null===t||void 0===t?void 0:t.lowerExp,-3),i=er(null===t||void 0===t?void 0:t.upperExp,5);if(e.isZero())return"0";var s=e.toSignificantDigits(r),u=s.e;return(u>=o&&u<i?s.toFixed():$n(e,r)).replace(/((\.\d*?)(0+))($|e)/,(function(){var e=arguments[2],t=arguments[4];return"."!==e?e+t:t}));default:throw new Error('Unknown notation "'+n+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function $n(e,t){return void 0!==t?e.toExponential(t-1):e.toExponential()}function er(e,t){return nt(e)?e:rt(e)?e.toNumber():t}function tr(e,t){var n=function(e,t){if("number"===typeof e)return dn(e,t);if(rt(e))return Jn(e,t);if(function(e){return e&&"object"===typeof e&&"bigint"===typeof e.s&&"bigint"===typeof e.n&&"bigint"===typeof e.d||!1}(e))return t&&"decimal"===t.fraction?e.toString():"".concat(e.s*e.n,"/").concat(e.d);if(Array.isArray(e))return ar(e,t);if(ut(e))return nr(e);if("function"===typeof e)return e.syntax?String(e.syntax):"function";if(e&&"object"===typeof e){return"function"===typeof e.format?e.format(t):e&&e.toString(t)!=={}.toString()?e.toString(t):"{"+Object.keys(e).map((n=>nr(n)+": "+tr(e[n],t))).join(", ")+"}"}return String(e)}(e,t);return t&&"object"===typeof t&&"truncate"in t&&n.length>t.truncate?n.substring(0,t.truncate-3)+"...":n}function nr(e){for(var t=String(e),n="",r=0;r<t.length;){var a=t.charAt(r);n+=a in rr?rr[a]:a,r++}return'"'+n+'"'}var rr={'"':'\\"',"\\":"\\\\","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"};function ar(e,t){if(Array.isArray(e)){for(var n="[",r=e.length,a=0;a<r;a++)0!==a&&(n+=", "),n+=ar(e[a],t);return n+="]"}return tr(e,t)}function or(e,t){if(!ut(e))throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: "+Gt(e)+", index: 0)");if(!ut(t))throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: "+Gt(t)+", index: 1)");return e===t?0:e>t?1:-1}function ir(e,t,n){if(!(this instanceof ir))throw new SyntaxError("Constructor must be called with the new operator");this.actual=e,this.expected=t,this.relation=n,this.message="Dimension mismatch ("+(Array.isArray(e)?"["+e.join(", ")+"]":e)+" "+(this.relation||"!=")+" "+(Array.isArray(t)?"["+t.join(", ")+"]":t)+")",this.stack=(new Error).stack}function sr(e,t,n){if(!(this instanceof sr))throw new SyntaxError("Constructor must be called with the new operator");this.index=e,arguments.length<3?(this.min=0,this.max=t):(this.min=t,this.max=n),void 0!==this.min&&this.index<this.min?this.message="Index out of range ("+this.index+" < "+this.min+")":void 0!==this.max&&this.index>=this.max?this.message="Index out of range ("+this.index+" > "+(this.max-1)+")":this.message="Index out of range ("+this.index+")",this.stack=(new Error).stack}function ur(e){for(var t=[];Array.isArray(e);)t.push(e.length),e=e[0];return t}function cr(e,t,n){var r,a=e.length;if(a!==t[n])throw new ir(a,t[n]);if(n<t.length-1){var o=n+1;for(r=0;r<a;r++){var i=e[r];if(!Array.isArray(i))throw new ir(t.length-1,t.length,"<");cr(e[r],t,o)}}else for(r=0;r<a;r++)if(Array.isArray(e[r]))throw new ir(t.length+1,t.length,">")}function lr(e,t){if(0===t.length){if(Array.isArray(e))throw new ir(e.length,0)}else cr(e,t,0)}function hr(e,t){if(void 0!==e){if(!nt(e)||!an(e))throw new TypeError("Index must be an integer (value: "+e+")");if(e<0||"number"===typeof t&&e>=t)throw new sr(e,t)}}function dr(e,t,n){if(!Array.isArray(t))throw new TypeError("Array expected");if(0===t.length)throw new Error("Resizing to scalar is not supported");return t.forEach((function(e){if(!nt(e)||!an(e)||e<0)throw new TypeError("Invalid size, must contain positive integers (size: "+tr(t)+")")})),(nt(e)||rt(e))&&(e=[e]),pr(e,t,0,void 0!==n?n:0),e}function pr(e,t,n,r){var a,o,i=e.length,s=t[n],u=Math.min(i,s);if(e.length=s,n<t.length-1){var c=n+1;for(a=0;a<u;a++)o=e[a],Array.isArray(o)||(o=[o],e[a]=o),pr(o,t,c,r);for(a=u;a<s;a++)o=[],e[a]=o,pr(o,t,c,r)}else{for(a=0;a<u;a++)for(;Array.isArray(e[a]);)e[a]=e[a][0];for(a=u;a<s;a++)e[a]=r}}function fr(e,t){var n=vr(e),r=n.length;if(!Array.isArray(e)||!Array.isArray(t))throw new TypeError("Array expected");if(0===t.length)throw new ir(0,r,"!=");var a=gr(t=mr(t,r));if(r!==a)throw new ir(a,r,"!=");try{return function(e,t){for(var n,r=e,a=t.length-1;a>0;a--){var o=t[a];n=[];for(var i=r.length/o,s=0;s<i;s++)n.push(r.slice(s*o,(s+1)*o));r=n}return r}(n,t)}catch(o){if(o instanceof ir)throw new ir(a,r,"!=");throw o}}function mr(e,t){var n=gr(e),r=e.slice(),a=e.indexOf(-1);if(e.indexOf(-1,a+1)>=0)throw new Error("More than one wildcard in sizes");if(a>=0){if(!(t%n===0))throw new Error("Could not replace wildcard, since "+t+" is no multiple of "+-n);r[a]=-t/n}return r}function gr(e){return e.reduce(((e,t)=>e*t),1)}function yr(e,t,n,r){var a=r||ur(e);if(n)for(var o=0;o<n;o++)e=[e],a.unshift(1);for(e=br(e,t,0);a.length<t;)a.push(1);return e}function br(e,t,n){var r,a;if(Array.isArray(e)){var o=n+1;for(r=0,a=e.length;r<a;r++)e[r]=br(e[r],t,o)}else for(var i=n;i<t;i++)e=[e];return e}function vr(e){if(!Array.isArray(e))return e;var t=[];return e.forEach((function e(n){Array.isArray(n)?n.forEach(e):t.push(n)})),t}function xr(e,t){for(var n,r=0,a=0;a<e.length;a++){var o=e[a],i=Array.isArray(o);if(0===a&&i&&(r=o.length),i&&o.length!==r)return;var s=i?xr(o,t):t(o);if(void 0===n)n=s;else if(n!==s)return"mixed"}return n}function wr(e,t,n,r){if(r<n){if(e.length!==t.length)throw new ir(e.length,t.length);for(var a=[],o=0;o<e.length;o++)a[o]=wr(e[o],t[o],n,r+1);return a}return e.concat(t)}function kr(){var e=Array.prototype.slice.call(arguments,0,-1),t=Array.prototype.slice.call(arguments,-1);if(1===e.length)return e[0];if(e.length>1)return e.slice(1).reduce((function(e,n){return wr(e,n,t,0)}),e[0]);throw new Error("Wrong number of arguments in function concat")}function Cr(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(var r=t.map((e=>e.length)),a=Math.max(...r),o=new Array(a).fill(null),i=0;i<t.length;i++)for(var s=t[i],u=r[i],c=0;c<u;c++){var l=a-u+c;s[c]>o[l]&&(o[l]=s[c])}for(var h=0;h<t.length;h++)Dr(t[h],o);return o}function Dr(e,t){for(var n=t.length,r=e.length,a=0;a<r;a++){var o=n-r+a;if(e[a]<t[o]&&e[a]>1||e[a]>t[o])throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(e,") not possible to broadcast dimension ").concat(r," with size ").concat(e[a]," to size ").concat(t[o]))}}function Sr(e,t){var n=ur(e);if(Ht(n,t))return e;Dr(n,t);var r,a,o,s=Cr(n,t),u=s.length,c=[...Array(u-n.length).fill(1),...n],l=function(e){return i([],e)}(e);n.length<u&&(n=ur(l=fr(l,c)));for(var h=0;h<u;h++)n[h]<s[h]&&(r=l,a=s[h],o=h,n=ur(l=kr(...Array(a).fill(r),o)));return l}function Er(e,t){if(!Array.isArray(e))throw new Error("Array expected");var n=ur(e);if(t.length!==n.length)throw new ir(t.length,n.length);for(var r=0;r<t.length;r++)hr(t[r],n[r]);return t.reduce(((e,t)=>e[t]),e)}ir.prototype=new RangeError,ir.prototype.constructor=RangeError,ir.prototype.name="DimensionError",ir.prototype.isDimensionError=!0,sr.prototype=new RangeError,sr.prototype.constructor=RangeError,sr.prototype.name="IndexError",sr.prototype.isIndexError=!0;var Ir=__webpack_require__(422);function Nr(e,t,n){if(Ir.isTypedFunction(e)){var r=(t.isMatrix?t.size():ur(t)).map((()=>0)),a=t.isMatrix?t.get(r):Er(t,r),o=1===Object.keys(e.signatures).length,i=function(e,t,n,r){for(var a=[t,n,r],o=3;o>0;o--){var i=a.slice(0,o);if(null!==Ir.resolve(e,i))return o}}(e,a,r,t),s=o?Object.values(e.signatures)[0]:e;return i>=1&&i<=3?function(){for(var t=arguments.length,r=new Array(t),a=0;a<t;a++)r[a]=arguments[a];return Tr(s,r.slice(0,i),n,e.name)}:function(){for(var t=arguments.length,r=new Array(t),a=0;a<t;a++)r[a]=arguments[a];return Tr(s,r,n,e.name)}}return e}function Tr(e,t,n,r){try{return e(...t)}catch(a){!function(e,t,n,r){var a;if(e instanceof TypeError&&"wrongType"===(null===(a=e.data)||void 0===a?void 0:a.category)){var o=[];throw o.push("value: ".concat(Gt(t[0]))),t.length>=2&&o.push("index: ".concat(Gt(t[1]))),t.length>=3&&o.push("array: ".concat(Gt(t[2]))),new TypeError("Function ".concat(n," cannot apply callback arguments ")+"".concat(r,"(").concat(o.join(", "),") at index ").concat(JSON.stringify(t[1])))}throw new TypeError("Function ".concat(n," cannot apply callback arguments ")+"to function ".concat(r,": ").concat(e.message))}(a,t,n,r)}}var Ar=Kt("DenseMatrix",["Matrix"],(e=>{var{Matrix:t}=e;function n(e,t){if(!(this instanceof n))throw new SyntaxError("Constructor must be called with the new operator");if(t&&!ut(t))throw new Error("Invalid datatype: "+t);if(lt(e))"DenseMatrix"===e.type?(this._data=jt(e._data),this._size=jt(e._size),this._datatype=t||e._datatype):(this._data=e.toArray(),this._size=e.size(),this._datatype=t||e._datatype);else if(e&&ct(e.data)&&ct(e.size))this._data=e.data,this._size=e.size,lr(this._data,this._size),this._datatype=t||e.datatype;else if(ct(e))this._data=s(e),this._size=ur(this._data),lr(this._data,this._size),this._datatype=t;else{if(e)throw new TypeError("Unsupported type of data ("+Gt(e)+")");this._data=[],this._size=[0],this._datatype=t}}function r(e,t,n,a){var o=a===n-1,i=t.dimension(a);return o?i.map((function(t){return hr(t,e.length),e[t]})).valueOf():i.map((function(o){return hr(o,e.length),r(e[o],t,n,a+1)})).valueOf()}function a(e,t,n,r,o){var i=o===r-1,s=t.dimension(o);i?s.forEach((function(t,r){hr(t),e[t]=n[r[0]]})):s.forEach((function(i,s){hr(i),a(e[i],t,n[s[0]],r,o+1)}))}function o(e,t,n){if(0===t.length){for(var r=e._data;ct(r);)r=r[0];return r}return e._size=t.slice(0),e._data=dr(e._data,e._size,n),e}function i(e,t,n){for(var r=e._size.slice(0),a=!1;r.length<t.length;)r.push(0),a=!0;for(var i=0,s=t.length;i<s;i++)t[i]>r[i]&&(r[i]=t[i],a=!0);a&&o(e,r,n)}function s(e){return lt(e)?s(e.valueOf()):ct(e)?e.map(s):e}return n.prototype=new t,n.prototype.createDenseMatrix=function(e,t){return new n(e,t)},Object.defineProperty(n,"name",{value:"DenseMatrix"}),n.prototype.constructor=n,n.prototype.type="DenseMatrix",n.prototype.isDenseMatrix=!0,n.prototype.getDataType=function(){return xr(this._data,Gt)},n.prototype.storage=function(){return"dense"},n.prototype.datatype=function(){return this._datatype},n.prototype.create=function(e,t){return new n(e,t)},n.prototype.subset=function(e,t,o){switch(arguments.length){case 1:return function(e,t){if(!mt(t))throw new TypeError("Invalid index");var a=t.isScalar();if(a)return e.get(t.min());var o=t.size();if(o.length!==e._size.length)throw new ir(o.length,e._size.length);for(var i=t.min(),s=t.max(),u=0,c=e._size.length;u<c;u++)hr(i[u],e._size[u]),hr(s[u],e._size[u]);return new n(r(e._data,t,o.length,0),e._datatype)}(this,e);case 2:case 3:return function(e,t,n,r){if(!t||!0!==t.isIndex)throw new TypeError("Invalid index");var o,s=t.size(),u=t.isScalar();lt(n)?(o=n.size(),n=n.valueOf()):o=ur(n);if(u){if(0!==o.length)throw new TypeError("Scalar expected");e.set(t.min(),n,r)}else{if(!Ht(o,s))try{o=ur(n=0===o.length?Sr([n],s):Sr(n,s))}catch(f){}if(s.length<e._size.length)throw new ir(s.length,e._size.length,"<");if(o.length<s.length){for(var c=0,l=0;1===s[c]&&1===o[c];)c++;for(;1===s[c];)l++,c++;n=yr(n,s.length,l,o)}if(!Ht(s,o))throw new ir(s,o,">");var h=t.max().map((function(e){return e+1}));i(e,h,r);var d=s.length,p=0;a(e._data,t,n,d,p)}return e}(this,e,t,o);default:throw new SyntaxError("Wrong number of arguments")}},n.prototype.get=function(e){return Er(this._data,e)},n.prototype.set=function(e,t,n){if(!ct(e))throw new TypeError("Array expected");if(e.length<this._size.length)throw new ir(e.length,this._size.length,"<");var r,a,o,s=e.map((function(e){return e+1}));i(this,s,n);var u=this._data;for(r=0,a=e.length-1;r<a;r++)hr(o=e[r],u.length),u=u[o];return hr(o=e[e.length-1],u.length),u[o]=t,this},n.prototype.resize=function(e,t,n){if(!ht(e))throw new TypeError("Array or Matrix expected");var r=e.valueOf().map((e=>Array.isArray(e)&&1===e.length?e[0]:e));return o(n?this.clone():this,r,t)},n.prototype.reshape=function(e,t){var n=t?this.clone():this;n._data=fr(n._data,e);var r=n._size.reduce(((e,t)=>e*t));return n._size=mr(e,r),n},n.prototype.clone=function(){return new n({data:jt(this._data),size:jt(this._size),datatype:this._datatype})},n.prototype.size=function(){return this._size.slice(0)},n.prototype._forEach=function(e){var t=this,n=t.size();if(1!==n.length){var r=Array(n.length).fill(0),a=Array(n.length-1),o=a.length-1;a[0]=t._data[0];for(var i=0;i<o;i++)a[i+1]=a[i][0];for(r[o]=-1;;){var s=void 0;for(s=o;s>=0;s--){if(r[s]++,r[s]!==n[s]){a[s]=0===s?t._data[r[s]]:a[s-1][r[s]];for(var u=s;u<o;u++)a[u+1]=a[u][0];for(var c=0;c<n[a.length];c++)r[a.length]=c,e(a[o],c,r.slice(0));break}r[s]=0}if(-1===s)break}}else for(var l=0;l<n[0];l++)e(t._data,l,[l])},n.prototype.map=function(e){var t=this,r=new n(t),a=Nr(e,t._data,"map");return r._forEach((function(e,n,r){e[n]=a(e[n],r,t)})),r},n.prototype.forEach=function(e){var t=this,n=Nr(e,t._data,"map");t._forEach((function(e,r,a){n(e[r],a,t)}))},n.prototype[Symbol.iterator]=function*(){var e=function*(t,n){if(ct(t))for(var r=0;r<t.length;r++)yield*e(t[r],n.concat(r));else yield{value:t,index:n}};yield*e(this._data,[])},n.prototype.rows=function(){var e=[];if(2!==this.size().length)throw new TypeError("Rows can only be returned for a 2D matrix.");var t=this._data;for(var r of t)e.push(new n([r],this._datatype));return e},n.prototype.columns=function(){var e=this,t=[],r=this.size();if(2!==r.length)throw new TypeError("Rows can only be returned for a 2D matrix.");for(var a=this._data,o=function(r){var o=a.map((e=>[e[r]]));t.push(new n(o,e._datatype))},i=0;i<r[1];i++)o(i);return t},n.prototype.toArray=function(){return jt(this._data)},n.prototype.valueOf=function(){return this._data},n.prototype.format=function(e){return tr(this._data,e)},n.prototype.toString=function(){return tr(this._data)},n.prototype.toJSON=function(){return{mathjs:"DenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},n.prototype.diagonal=function(e){if(e){if(rt(e)&&(e=e.toNumber()),!nt(e)||!an(e))throw new TypeError("The parameter k must be an integer number")}else e=0;for(var t=e>0?e:0,r=e<0?-e:0,a=this._size[0],o=this._size[1],i=Math.min(a-r,o-t),s=[],u=0;u<i;u++)s[u]=this._data[u+r][u+t];return new n({data:s,size:[i],datatype:this._datatype})},n.diagonal=function(e,t,r,a){if(!ct(e))throw new TypeError("Array expected, size parameter");if(2!==e.length)throw new Error("Only two dimensions matrix are supported");if(e=e.map((function(e){if(rt(e)&&(e=e.toNumber()),!nt(e)||!an(e)||e<1)throw new Error("Size values must be positive integers");return e})),r){if(rt(r)&&(r=r.toNumber()),!nt(r)||!an(r))throw new TypeError("The parameter k must be an integer number")}else r=0;var o,i=r>0?r:0,s=r<0?-r:0,u=e[0],c=e[1],l=Math.min(u-s,c-i);if(ct(t)){if(t.length!==l)throw new Error("Invalid value array length");o=function(e){return t[e]}}else if(lt(t)){var h=t.size();if(1!==h.length||h[0]!==l)throw new Error("Invalid matrix length");o=function(e){return t.get([e])}}else o=function(){return t};a||(a=rt(o(0))?o(0).mul(0):0);var d=[];if(e.length>0){d=dr(d,e,a);for(var p=0;p<l;p++)d[p+s][p+i]=o(p)}return new n({data:d,size:[u,c]})},n.fromJSON=function(e){return new n(e)},n.prototype.swapRows=function(e,t){if(!nt(e)||!an(e)||!nt(t)||!an(t))throw new Error("Row index must be positive integers");if(2!==this._size.length)throw new Error("Only two dimensional matrix is supported");return hr(e,this._size[0]),hr(t,this._size[0]),n._swapRows(e,t,this._data),this},n._swapRows=function(e,t,n){var r=n[e];n[e]=n[t],n[t]=r},n}),{isClass:!0}),Fr=function(){return Fr=Ir.create,Ir},_r=Kt("typed",["?BigNumber","?Complex","?DenseMatrix","?Fraction"],(function(e){var{BigNumber:t,Complex:n,DenseMatrix:r,Fraction:a}=e,o=Fr();return o.clear(),o.addTypes([{name:"number",test:nt},{name:"Complex",test:ot},{name:"BigNumber",test:rt},{name:"bigint",test:at},{name:"Fraction",test:it},{name:"Unit",test:st},{name:"identifier",test:e=>ut&&/^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDDC0-\uDDF3\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDD4A-\uDD65\uDD6F-\uDD85\uDE80-\uDEA9\uDEB0\uDEB1\uDEC2-\uDEC4\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61\uDF80-\uDF89\uDF8B\uDF8E\uDF90-\uDFB5\uDFB7\uDFD1\uDFD3]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8\uDFC0-\uDFE0]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD80E\uD80F\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46\uDC60-\uDFFF]|\uD810[\uDC00-\uDFFA]|\uD811[\uDC00-\uDE46]|\uD818[\uDD00-\uDD1D]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDD40-\uDD6C\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDCFF-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDDD0-\uDDED\uDDF0\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(e)},{name:"string",test:ut},{name:"Chain",test:Vt},{name:"Array",test:ct},{name:"Matrix",test:lt},{name:"DenseMatrix",test:dt},{name:"SparseMatrix",test:pt},{name:"Range",test:ft},{name:"Index",test:mt},{name:"boolean",test:gt},{name:"ResultSet",test:yt},{name:"Help",test:bt},{name:"function",test:vt},{name:"Date",test:xt},{name:"RegExp",test:wt},{name:"null",test:Dt},{name:"undefined",test:St},{name:"AccessorNode",test:Et},{name:"ArrayNode",test:It},{name:"AssignmentNode",test:Nt},{name:"BlockNode",test:Tt},{name:"ConditionalNode",test:At},{name:"ConstantNode",test:Ft},{name:"FunctionNode",test:Rt},{name:"FunctionAssignmentNode",test:_t},{name:"IndexNode",test:Mt},{name:"Node",test:Ot},{name:"ObjectNode",test:zt},{name:"OperatorNode",test:Lt},{name:"ParenthesisNode",test:Bt},{name:"RangeNode",test:Pt},{name:"RelationalNode",test:Wt},{name:"SymbolNode",test:Ut},{name:"Map",test:Ct},{name:"Object",test:kt}]),o.addConversions([{from:"number",to:"BigNumber",convert:function(e){if(t||Rr(e),e.toExponential().replace(/e.*$/,"").replace(/^0\.?0*|\./,"").length>15)throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: "+e+"). Use function bignumber(x) to convert to BigNumber.");return new t(e)}},{from:"number",to:"Complex",convert:function(e){return n||Mr(e),new n(e,0)}},{from:"BigNumber",to:"Complex",convert:function(e){return n||Mr(e),new n(e.toNumber(),0)}},{from:"bigint",to:"number",convert:function(e){if(e>Number.MAX_SAFE_INTEGER)throw new TypeError("Cannot implicitly convert bigint to number: value exceeds the max safe integer value (value: "+e+")");return Number(e)}},{from:"bigint",to:"BigNumber",convert:function(e){return t||Rr(e),new t(e.toString())}},{from:"bigint",to:"Fraction",convert:function(e){return a||Or(e),new a(e)}},{from:"Fraction",to:"BigNumber",convert:function(e){throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.")}},{from:"Fraction",to:"Complex",convert:function(e){return n||Mr(e),new n(e.valueOf(),0)}},{from:"number",to:"Fraction",convert:function(e){a||Or(e);var t=new a(e);if(t.valueOf()!==e)throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: "+e+"). Use function fraction(x) to convert to Fraction.");return t}},{from:"string",to:"number",convert:function(e){var t=Number(e);if(isNaN(t))throw new Error('Cannot convert "'+e+'" to a number');return t}},{from:"string",to:"BigNumber",convert:function(e){t||Rr(e);try{return new t(e)}catch(n){throw new Error('Cannot convert "'+e+'" to BigNumber')}}},{from:"string",to:"bigint",convert:function(e){try{return BigInt(e)}catch(t){throw new Error('Cannot convert "'+e+'" to BigInt')}}},{from:"string",to:"Fraction",convert:function(e){a||Or(e);try{return new a(e)}catch(t){throw new Error('Cannot convert "'+e+'" to Fraction')}}},{from:"string",to:"Complex",convert:function(e){n||Mr(e);try{return new n(e)}catch(t){throw new Error('Cannot convert "'+e+'" to Complex')}}},{from:"boolean",to:"number",convert:function(e){return+e}},{from:"boolean",to:"BigNumber",convert:function(e){return t||Rr(e),new t(+e)}},{from:"boolean",to:"bigint",convert:function(e){return BigInt(+e)}},{from:"boolean",to:"Fraction",convert:function(e){return a||Or(e),new a(+e)}},{from:"boolean",to:"string",convert:function(e){return String(e)}},{from:"Array",to:"Matrix",convert:function(e){return r||function(){throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided")}(),new r(e)}},{from:"Matrix",to:"Array",convert:function(e){return e.valueOf()}}]),o.onMismatch=(e,t,n)=>{var r=o.createError(e,t,n);if(["wrongType","mismatch"].includes(r.data.category)&&1===t.length&&ht(t[0])&&n.some((e=>!e.params.includes(",")))){var a=new TypeError("Function '".concat(e,"' doesn't apply to matrices. To call it ")+"elementwise on a matrix 'M', try 'map(M, ".concat(e,")'."));throw a.data=r.data,a}throw r},o.onMismatch=(e,t,n)=>{var r=o.createError(e,t,n);if(["wrongType","mismatch"].includes(r.data.category)&&1===t.length&&ht(t[0])&&n.some((e=>!e.params.includes(",")))){var a=new TypeError("Function '".concat(e,"' doesn't apply to matrices. To call it ")+"elementwise on a matrix 'M', try 'map(M, ".concat(e,")'."));throw a.data=r.data,a}throw r},o}));function Rr(e){throw new Error("Cannot convert value ".concat(e," into a BigNumber: no class 'BigNumber' provided"))}function Mr(e){throw new Error("Cannot convert value ".concat(e," into a Complex number: no class 'Complex' provided"))}function Or(e){throw new Error("Cannot convert value ".concat(e," into a Fraction, no class 'Fraction' provided."))}function zr(e,t,n){return e&&"function"===typeof e.map?e.map((function(e){return zr(e,t,n)})):t(e)}var Lr="number",Br="number, number";function Pr(e){return Math.abs(e)}function Wr(e,t){return e+t}function Ur(e,t){return e-t}function Vr(e,t){return e*t}function Gr(e){return-e}function jr(e){return e}function Hr(e){return cn(e)}function qr(e){return e*e*e}function Kr(e){return Math.exp(e)}function Xr(e){return ln(e)}function Yr(e,t){if(!an(e)||!an(t))throw new Error("Parameters in function lcm must be integer numbers");if(0===e||0===t)return 0;for(var n,r=e*t;0!==t;)t=e%(n=t),e=n;return Math.abs(r/e)}function Qr(e){return un(e)}function Zr(e){return sn(e)}function Jr(e){return on(e)}function $r(e){return e*e}function ea(e,t){var n,r,a,o=0,i=1,s=1,u=0;if(!an(e)||!an(t))throw new Error("Parameters in function xgcd must be integer numbers");for(;t;)a=e-(r=Math.floor(e/t))*t,n=o,o=i-r*o,i=n,n=s,s=u-r*s,u=n,e=t,t=a;return e<0?[-e,-i,-u]:[e,e?i:0,u]}function ta(e,t){return e*e<1&&t===1/0||e*e>1&&t===-1/0?0:Math.pow(e,t)}Pr.signature=Lr,Wr.signature=Br,Ur.signature=Br,Vr.signature=Br,Gr.signature=Lr,jr.signature=Lr,Hr.signature=Lr,qr.signature=Lr,Kr.signature=Lr,Xr.signature=Lr,Yr.signature=Br,Qr.signature=Lr,Zr.signature=Lr,Jr.signature=Lr,$r.signature=Lr,ea.signature=Br,ta.signature=Br;var na="number";function ra(e){return xn(e)}function aa(e){return Math.atan(1/e)}function oa(e){return isFinite(e)?(Math.log((e+1)/e)+Math.log(e/(e-1)))/2:0}function ia(e){return Math.asin(1/e)}function sa(e){var t=1/e;return Math.log(t+Math.sqrt(t*t+1))}function ua(e){return Math.acos(1/e)}function ca(e){var t=1/e,n=Math.sqrt(t*t-1);return Math.log(n+t)}function la(e){return wn(e)}function ha(e){return kn(e)}function da(e){return 1/Math.tan(e)}function pa(e){var t=Math.exp(2*e);return(t+1)/(t-1)}function fa(e){return 1/Math.sin(e)}function ma(e){return 0===e?Number.POSITIVE_INFINITY:Math.abs(2/(Math.exp(e)-Math.exp(-e)))*on(e)}function ga(e){return 1/Math.cos(e)}function ya(e){return 2/(Math.exp(e)+Math.exp(-e))}function ba(e){return Cn(e)}ra.signature=na,aa.signature=na,oa.signature=na,ia.signature=na,sa.signature=na,ua.signature=na,ca.signature=na,la.signature=na,ha.signature=na,da.signature=na,pa.signature=na,fa.signature=na,ma.signature=na,ga.signature=na,ya.signature=na,ba.signature=na;var va="addScalar",xa=Kt(va,["typed"],(e=>{var{typed:t}=e;return t(va,{"number, number":Wr,"Complex, Complex":function(e,t){return e.add(t)},"BigNumber, BigNumber":function(e,t){return e.plus(t)},"bigint, bigint":function(e,t){return e+t},"Fraction, Fraction":function(e,t){return e.add(t)},"Unit, Unit":t.referToSelf((e=>(n,r)=>{if(null===n.value||void 0===n.value)throw new Error("Parameter x contains a unit with undefined value");if(null===r.value||void 0===r.value)throw new Error("Parameter y contains a unit with undefined value");if(!n.equalBase(r))throw new Error("Units do not match");var a=n.clone();return a.value=t.find(e,[a.valueType(),r.valueType()])(a.value,r.value),a.fixPrefix=!1,a}))})}));var wa="number, number";function ka(e,t){if(!an(e)||!an(t))throw new Error("Integers expected in function bitAnd");return e&t}function Ca(e){if(!an(e))throw new Error("Integer expected in function bitNot");return~e}function Da(e,t){if(!an(e)||!an(t))throw new Error("Integers expected in function bitOr");return e|t}function Sa(e,t){if(!an(e)||!an(t))throw new Error("Integers expected in function bitXor");return e^t}function Ea(e,t){if(!an(e)||!an(t))throw new Error("Integers expected in function leftShift");return e<<t}function Ia(e,t){if(!an(e)||!an(t))throw new Error("Integers expected in function rightArithShift");return e>>t}function Na(e,t){if(!an(e)||!an(t))throw new Error("Integers expected in function rightLogShift");return e>>>t}ka.signature=wa,Ca.signature="number",Da.signature=wa,Sa.signature=wa,Ea.signature=wa,Ia.signature=wa,Na.signature=wa;function Ta(e,t){if(t<e)return 1;if(t===e)return t;var n=t+e>>1;return Ta(e,n)*Ta(n+1,t)}function Aa(e,t){if(!an(e)||e<0)throw new TypeError("Positive integer value expected in function combinations");if(!an(t)||t<0)throw new TypeError("Positive integer value expected in function combinations");if(t>e)throw new TypeError("k must be less than or equal to n");for(var n=e-t,r=1,a=2,o=t<n?t:n,i=t<n?n+1:t+1;i<=e;++i)for(r*=i;a<=o&&r%a===0;)r/=a,++a;return a<=o&&(r/=Ta(a,o)),r}Aa.signature="number, number";var Fa="conj",_a=Kt(Fa,["typed"],(e=>{var{typed:t}=e;return t(Fa,{"number | BigNumber | Fraction":e=>e,Complex:e=>e.conjugate(),"Array | Matrix":t.referToSelf((e=>t=>zr(t,e)))})}));function Ra(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e-9,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(n<=0)throw new Error("Relative tolerance must be greater than 0");if(r<0)throw new Error("Absolute tolerance must be at least 0");return!e.isNaN()&&!t.isNaN()&&(e.isFinite()&&t.isFinite()?!!e.eq(t)||e.minus(t).abs().lte(e.constructor.max(e.constructor.max(e.abs(),t.abs()).mul(n),r)):e.eq(t))}var Ma=Kt("compareUnits",["typed"],(e=>{var{typed:t}=e;return{"Unit, Unit":t.referToSelf((e=>(n,r)=>{if(!n.equalBase(r))throw new Error("Cannot compare units with different base");return t.find(e,[n.valueType(),r.valueType()])(n.value,r.value)}))}})),Oa="equalScalar",za=Kt(Oa,["typed","config"],(e=>{var{typed:t,config:n}=e,r=Ma({typed:t});return t(Oa,{"boolean, boolean":function(e,t){return e===t},"number, number":function(e,t){return vn(e,t,n.relTol,n.absTol)},"BigNumber, BigNumber":function(e,t){return e.eq(t)||Ra(e,t,n.relTol,n.absTol)},"bigint, bigint":function(e,t){return e===t},"Fraction, Fraction":function(e,t){return e.equals(t)},"Complex, Complex":function(e,t){return function(e,t,n,r){return vn(e.re,t.re,n,r)&&vn(e.im,t.im,n,r)}(e,t,n.relTol,n.absTol)}},r)}));Kt(Oa,["typed","config"],(e=>{var{typed:t,config:n}=e;return t(Oa,{"number, number":function(e,t){return vn(e,t,n.relTol,n.absTol)}})})),Math.pow(2,53);Kt("hex",["typed","format"],(e=>{var{typed:t,format:n}=e;return t("hex",{"number | BigNumber":function(e){return n(e,{notation:"hex"})},"number | BigNumber, number | BigNumber":function(e,t){return n(e,{notation:"hex",wordSize:t})}})}));var La="number";function Ba(e){return e<0}function Pa(e){return e>0}function Wa(e){return Number.isNaN(e)}Ba.signature=La,Pa.signature=La,Wa.signature=La;function Ua(e){var t;if(an(e))return e<=0?isFinite(e)?1/0:NaN:e>171?1/0:Ta(1,e-1);if(e<.5)return Math.PI/(Math.sin(Math.PI*e)*Ua(1-e));if(e>=171.35)return 1/0;if(e>85){var n=e*e,r=n*e,a=r*e,o=a*e;return Math.sqrt(2*Math.PI/e)*Math.pow(e/Math.E,e)*(1+1/(12*e)+1/(288*n)-139/(51840*r)-571/(2488320*a)+163879/(209018880*o)+5246819/(75246796800*o*e))}--e,t=Ga[0];for(var i=1;i<Ga.length;++i)t+=Ga[i]/(e+i);var s=e+Va+.5;return Math.sqrt(2*Math.PI)*Math.pow(s,e+.5)*Math.exp(-s)*t}Ua.signature="number";var Va=4.7421875,Ga=[.9999999999999971,57.15623566586292,-59.59796035547549,14.136097974741746,-.4919138160976202,3399464998481189e-20,4652362892704858e-20,-9837447530487956e-20,.0001580887032249125,-.00021026444172410488,.00021743961811521265,-.0001643181065367639,8441822398385275e-20,-26190838401581408e-21,36899182659531625e-22],ja=.9189385332046728,Ha=[1.000000000190015,76.18009172947146,-86.50532032941678,24.01409824083091,-1.231739572450155,.001208650973866179,-5395239384953e-18];function qa(e){if(e<0)return NaN;if(0===e)return 1/0;if(!isFinite(e))return e;if(e<.5)return Math.log(Math.PI/Math.sin(Math.PI*e))-qa(1-e);for(var t=(e-=1)+5+.5,n=Ha[0],r=6;r>=1;r--)n+=Ha[r]/(e+r);return ja+(e+.5)*Math.log(t)-t+Math.log(n)}qa.signature="number";var Ka=Kt("multiplyScalar",["typed"],(e=>{var{typed:t}=e;return t("multiplyScalar",{"number, number":Vr,"Complex, Complex":function(e,t){return e.mul(t)},"BigNumber, BigNumber":function(e,t){return e.times(t)},"bigint, bigint":function(e,t){return e*t},"Fraction, Fraction":function(e,t){return e.mul(t)},"number | Fraction | BigNumber | Complex, Unit":(e,t)=>t.multiply(e),"Unit, number | Fraction | BigNumber | Complex | Unit":(e,t)=>e.multiply(t)})})),Xa="number, number";function Ya(e){return!e}function Qa(e,t){return!(!e&&!t)}function Za(e,t){return!!e!==!!t}function Ja(e,t){return!(!e||!t)}Ya.signature="number",Qa.signature=Xa,Za.signature=Xa,Ja.signature=Xa;Kt("oct",["typed","format"],(e=>{var{typed:t,format:n}=e;return t("oct",{"number | BigNumber":function(e){return n(e,{notation:"oct"})},"number | BigNumber, number | BigNumber":function(e,t){return n(e,{notation:"oct",wordSize:t})}})}));var $a=__webpack_require__(334);Date.now();var eo=Kt("SparseMatrix",["typed","equalScalar","Matrix"],(e=>{var{typed:t,equalScalar:n,Matrix:r}=e;function a(e,t){if(!(this instanceof a))throw new SyntaxError("Constructor must be called with the new operator");if(t&&!ut(t))throw new Error("Invalid datatype: "+t);if(lt(e))!function(e,t,n){"SparseMatrix"===t.type?(e._values=t._values?jt(t._values):void 0,e._index=jt(t._index),e._ptr=jt(t._ptr),e._size=jt(t._size),e._datatype=n||t._datatype):o(e,t.valueOf(),n||t._datatype)}(this,e,t);else if(e&&ct(e.index)&&ct(e.ptr)&&ct(e.size))this._values=e.values,this._index=e.index,this._ptr=e.ptr,this._size=e.size,this._datatype=t||e.datatype;else if(ct(e))o(this,e,t);else{if(e)throw new TypeError("Unsupported type of data ("+Gt(e)+")");this._values=[],this._index=[],this._ptr=[0],this._size=[0,0],this._datatype=t}}function o(e,r,a){e._values=[],e._index=[],e._ptr=[],e._datatype=a;var o=r.length,i=0,s=n,u=0;if(ut(a)&&(s=t.find(n,[a,a])||n,u=t.convert(0,a)),o>0){var c=0;do{e._ptr.push(e._index.length);for(var l=0;l<o;l++){var h=r[l];if(ct(h)){if(0===c&&i<h.length&&(i=h.length),c<h.length){var d=h[c];s(d,u)||(e._values.push(d),e._index.push(l))}}else 0===c&&i<1&&(i=1),s(h,u)||(e._values.push(h),e._index.push(l))}c++}while(c<i)}e._ptr.push(e._index.length),e._size=[o,i]}function i(e,t,n,r){if(n-t===0)return n;for(var a=t;a<n;a++)if(r[a]===e)return a;return t}function s(e,t,n,r,a,o,i){a.splice(e,0,r),o.splice(e,0,t);for(var s=n+1;s<i.length;s++)i[s]++}function u(e,r,a,o){var i=o||0,s=n,u=0;ut(e._datatype)&&(s=t.find(n,[e._datatype,e._datatype])||n,u=t.convert(0,e._datatype),i=t.convert(i,e._datatype));var c,l,h,d=!s(i,u),p=e._size[0],f=e._size[1];if(a>f){for(l=f;l<a;l++)if(e._ptr[l]=e._values.length,d)for(c=0;c<p;c++)e._values.push(i),e._index.push(c);e._ptr[a]=e._values.length}else a<f&&(e._ptr.splice(a+1,f-a),e._values.splice(e._ptr[a],e._values.length),e._index.splice(e._ptr[a],e._index.length));if(f=a,r>p){if(d){var m=0;for(l=0;l<f;l++){e._ptr[l]=e._ptr[l]+m,h=e._ptr[l+1]+m;var g=0;for(c=p;c<r;c++,g++)e._values.splice(h+g,0,i),e._index.splice(h+g,0,c),m++}e._ptr[f]=e._values.length}}else if(r<p){var y=0;for(l=0;l<f;l++){e._ptr[l]=e._ptr[l]-y;var b=e._ptr[l],v=e._ptr[l+1]-y;for(h=b;h<v;h++)(c=e._index[h])>r-1&&(e._values.splice(h,1),e._index.splice(h,1),y++)}e._ptr[l]=e._values.length}return e._size[0]=r,e._size[1]=a,e}function c(e,t,n,r,a){var o,i,s=r[0],u=r[1],c=[];for(o=0;o<s;o++)for(c[o]=[],i=0;i<u;i++)c[o][i]=0;for(i=0;i<u;i++)for(var l=n[i],h=n[i+1],d=l;d<h;d++)c[o=t[d]][i]=e?a?jt(e[d]):e[d]:1;return c}return a.prototype=new r,a.prototype.createSparseMatrix=function(e,t){return new a(e,t)},Object.defineProperty(a,"name",{value:"SparseMatrix"}),a.prototype.constructor=a,a.prototype.type="SparseMatrix",a.prototype.isSparseMatrix=!0,a.prototype.getDataType=function(){return xr(this._values,Gt)},a.prototype.storage=function(){return"sparse"},a.prototype.datatype=function(){return this._datatype},a.prototype.create=function(e,t){return new a(e,t)},a.prototype.density=function(){var e=this._size[0],t=this._size[1];return 0!==e&&0!==t?this._index.length/(e*t):0},a.prototype.subset=function(e,t,n){if(!this._values)throw new Error("Cannot invoke subset on a Pattern only matrix");switch(arguments.length){case 1:return function(e,t){if(!mt(t))throw new TypeError("Invalid index");if(t.isScalar())return e.get(t.min());var n,r,o,i,s=t.size();if(s.length!==e._size.length)throw new ir(s.length,e._size.length);var u=t.min(),c=t.max();for(n=0,r=e._size.length;n<r;n++)hr(u[n],e._size[n]),hr(c[n],e._size[n]);var l=e._values,h=e._index,d=e._ptr,p=t.dimension(0),f=t.dimension(1),m=[],g=[];p.forEach((function(e,t){g[e]=t[0],m[e]=!0}));var y=l?[]:void 0,b=[],v=[];return f.forEach((function(e){for(v.push(b.length),o=d[e],i=d[e+1];o<i;o++)n=h[o],!0===m[n]&&(b.push(g[n]),y&&y.push(l[o]))})),v.push(b.length),new a({values:y,index:b,ptr:v,size:s,datatype:e._datatype})}(this,e);case 2:case 3:return function(e,t,n,r){if(!t||!0!==t.isIndex)throw new TypeError("Invalid index");var a,o=t.size(),i=t.isScalar();lt(n)?(a=n.size(),n=n.toArray()):a=ur(n);if(i){if(0!==a.length)throw new TypeError("Scalar expected");e.set(t.min(),n,r)}else{if(1!==o.length&&2!==o.length)throw new ir(o.length,e._size.length,"<");if(a.length<o.length){for(var s=0,u=0;1===o[s]&&1===a[s];)s++;for(;1===o[s];)u++,s++;n=yr(n,o.length,u,a)}if(!Ht(o,a))throw new ir(o,a,">");if(1===o.length){t.dimension(0).forEach((function(t,a){hr(t),e.set([t,0],n[a[0]],r)}))}else{var c=t.dimension(0),l=t.dimension(1);c.forEach((function(t,a){hr(t),l.forEach((function(o,i){hr(o),e.set([t,o],n[a[0]][i[0]],r)}))}))}}return e}(this,e,t,n);default:throw new SyntaxError("Wrong number of arguments")}},a.prototype.get=function(e){if(!ct(e))throw new TypeError("Array expected");if(e.length!==this._size.length)throw new ir(e.length,this._size.length);if(!this._values)throw new Error("Cannot invoke get on a Pattern only matrix");var t=e[0],n=e[1];hr(t,this._size[0]),hr(n,this._size[1]);var r=i(t,this._ptr[n],this._ptr[n+1],this._index);return r<this._ptr[n+1]&&this._index[r]===t?this._values[r]:0},a.prototype.set=function(e,r,a){if(!ct(e))throw new TypeError("Array expected");if(e.length!==this._size.length)throw new ir(e.length,this._size.length);if(!this._values)throw new Error("Cannot invoke set on a Pattern only matrix");var o=e[0],c=e[1],l=this._size[0],h=this._size[1],d=n,p=0;ut(this._datatype)&&(d=t.find(n,[this._datatype,this._datatype])||n,p=t.convert(0,this._datatype)),(o>l-1||c>h-1)&&(u(this,Math.max(o+1,l),Math.max(c+1,h),a),l=this._size[0],h=this._size[1]),hr(o,l),hr(c,h);var f=i(o,this._ptr[c],this._ptr[c+1],this._index);return f<this._ptr[c+1]&&this._index[f]===o?d(r,p)?function(e,t,n,r,a){n.splice(e,1),r.splice(e,1);for(var o=t+1;o<a.length;o++)a[o]--}(f,c,this._values,this._index,this._ptr):this._values[f]=r:d(r,p)||s(f,o,c,r,this._values,this._index,this._ptr),this},a.prototype.resize=function(e,t,n){if(!ht(e))throw new TypeError("Array or Matrix expected");var r=e.valueOf().map((e=>Array.isArray(e)&&1===e.length?e[0]:e));if(2!==r.length)throw new Error("Only two dimensions matrix are supported");return r.forEach((function(e){if(!nt(e)||!an(e)||e<0)throw new TypeError("Invalid size, must contain positive integers (size: "+tr(r)+")")})),u(n?this.clone():this,r[0],r[1],t)},a.prototype.reshape=function(e,t){if(!ct(e))throw new TypeError("Array expected");if(2!==e.length)throw new Error("Sparse matrices can only be reshaped in two dimensions");e.forEach((function(t){if(!nt(t)||!an(t)||t<=-2||0===t)throw new TypeError("Invalid size, must contain positive integers or -1 (size: "+tr(e)+")")}));var n=this._size[0]*this._size[1];if(n!==(e=mr(e,n))[0]*e[1])throw new Error("Reshaping sparse matrix will result in the wrong number of elements");var r=t?this.clone():this;if(this._size[0]===e[0]&&this._size[1]===e[1])return r;for(var a=[],o=0;o<r._ptr.length;o++)for(var u=0;u<r._ptr[o+1]-r._ptr[o];u++)a.push(o);for(var c=r._values.slice(),l=r._index.slice(),h=0;h<r._index.length;h++){var d=l[h],p=a[h],f=d*r._size[1]+p;a[h]=f%e[1],l[h]=Math.floor(f/e[1])}r._values.length=0,r._index.length=0,r._ptr.length=e[1]+1,r._size=e.slice();for(var m=0;m<r._ptr.length;m++)r._ptr[m]=0;for(var g=0;g<c.length;g++){var y=l[g],b=a[g],v=c[g];s(i(y,r._ptr[b],r._ptr[b+1],r._index),y,b,v,r._values,r._index,r._ptr)}return r},a.prototype.clone=function(){return new a({values:this._values?jt(this._values):void 0,index:jt(this._index),ptr:jt(this._ptr),size:jt(this._size),datatype:this._datatype})},a.prototype.size=function(){return this._size.slice(0)},a.prototype.map=function(e,r){if(!this._values)throw new Error("Cannot invoke map on a Pattern only matrix");var o=this,i=this._size[0],s=this._size[1],u=Nr(e,o,"map");return function(e,r,o,i,s,u,c){var l=[],h=[],d=[],p=n,f=0;ut(e._datatype)&&(p=t.find(n,[e._datatype,e._datatype])||n,f=t.convert(0,e._datatype));for(var m=function(e,t,n){var r=u(e,t,n);p(r,f)||(l.push(r),h.push(t))},g=i;g<=s;g++){d.push(l.length);var y=e._ptr[g],b=e._ptr[g+1];if(c)for(var v=y;v<b;v++){var x=e._index[v];x>=r&&x<=o&&m(e._values[v],x-r,g-i)}else{for(var w={},k=y;k<b;k++){w[e._index[k]]=e._values[k]}for(var C=r;C<=o;C++){m(C in w?w[C]:0,C-r,g-i)}}}return d.push(l.length),new a({values:l,index:h,ptr:d,size:[o-r+1,s-i+1]})}(this,0,i-1,0,s-1,(function(e,t,n){return u(e,[t,n],o)}),r)},a.prototype.forEach=function(e,t){if(!this._values)throw new Error("Cannot invoke forEach on a Pattern only matrix");for(var n=this,r=this._size[0],a=this._size[1],o=Nr(e,n,"forEach"),i=0;i<a;i++){var s=this._ptr[i],u=this._ptr[i+1];if(t)for(var c=s;c<u;c++){var l=this._index[c];o(this._values[c],[l,i],n)}else{for(var h={},d=s;d<u;d++){h[this._index[d]]=this._values[d]}for(var p=0;p<r;p++){o(p in h?h[p]:0,[p,i],n)}}}},a.prototype[Symbol.iterator]=function*(){if(!this._values)throw new Error("Cannot iterate a Pattern only matrix");for(var e=this._size[1],t=0;t<e;t++)for(var n=this._ptr[t],r=this._ptr[t+1],a=n;a<r;a++){var o=this._index[a];yield{value:this._values[a],index:[o,t]}}},a.prototype.toArray=function(){return c(this._values,this._index,this._ptr,this._size,!0)},a.prototype.valueOf=function(){return c(this._values,this._index,this._ptr,this._size,!1)},a.prototype.format=function(e){for(var t=this._size[0],n=this._size[1],r=this.density(),a="Sparse Matrix ["+tr(t,e)+" x "+tr(n,e)+"] density: "+tr(r,e)+"\n",o=0;o<n;o++)for(var i=this._ptr[o],s=this._ptr[o+1],u=i;u<s;u++){a+="\n    ("+tr(this._index[u],e)+", "+tr(o,e)+") ==> "+(this._values?tr(this._values[u],e):"X")}return a},a.prototype.toString=function(){return tr(this.toArray())},a.prototype.toJSON=function(){return{mathjs:"SparseMatrix",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}},a.prototype.diagonal=function(e){if(e){if(rt(e)&&(e=e.toNumber()),!nt(e)||!an(e))throw new TypeError("The parameter k must be an integer number")}else e=0;var t=e>0?e:0,n=e<0?-e:0,r=this._size[0],o=this._size[1],i=Math.min(r-n,o-t),s=[],u=[],c=[];c[0]=0;for(var l=t;l<o&&s.length<i;l++)for(var h=this._ptr[l],d=this._ptr[l+1],p=h;p<d;p++){var f=this._index[p];if(f===l-t+n){s.push(this._values[p]),u[s.length-1]=f-n;break}}return c.push(s.length),new a({values:s,index:u,ptr:c,size:[i,1]})},a.fromJSON=function(e){return new a(e)},a.diagonal=function(e,r,o,i,s){if(!ct(e))throw new TypeError("Array expected, size parameter");if(2!==e.length)throw new Error("Only two dimensions matrix are supported");if(e=e.map((function(e){if(rt(e)&&(e=e.toNumber()),!nt(e)||!an(e)||e<1)throw new Error("Size values must be positive integers");return e})),o){if(rt(o)&&(o=o.toNumber()),!nt(o)||!an(o))throw new TypeError("The parameter k must be an integer number")}else o=0;var u=n,c=0;ut(s)&&(u=t.find(n,[s,s])||n,c=t.convert(0,s));var l,h=o>0?o:0,d=o<0?-o:0,p=e[0],f=e[1],m=Math.min(p-d,f-h);if(ct(r)){if(r.length!==m)throw new Error("Invalid value array length");l=function(e){return r[e]}}else if(lt(r)){var g=r.size();if(1!==g.length||g[0]!==m)throw new Error("Invalid matrix length");l=function(e){return r.get([e])}}else l=function(){return r};for(var y=[],b=[],v=[],x=0;x<f;x++){v.push(y.length);var w=x-h;if(w>=0&&w<m){var k=l(w);u(k,c)||(b.push(w+d),y.push(k))}}return v.push(y.length),new a({values:y,index:b,ptr:v,size:[p,f]})},a.prototype.swapRows=function(e,t){if(!nt(e)||!an(e)||!nt(t)||!an(t))throw new Error("Row index must be positive integers");if(2!==this._size.length)throw new Error("Only two dimensional matrix is supported");return hr(e,this._size[0]),hr(t,this._size[0]),a._swapRows(e,t,this._size[1],this._values,this._index,this._ptr),this},a._forEachRow=function(e,t,n,r,a){for(var o=r[e],i=r[e+1],s=o;s<i;s++)a(n[s],t[s])},a._swapRows=function(e,t,n,r,a,o){for(var s=0;s<n;s++){var u=o[s],c=o[s+1],l=i(e,u,c,a),h=i(t,u,c,a);if(l<c&&h<c&&a[l]===e&&a[h]===t){if(r){var d=r[l];r[l]=r[h],r[h]=d}}else if(l<c&&a[l]===e&&(h>=c||a[h]!==t)){var p=r?r[l]:void 0;a.splice(h,0,t),r&&r.splice(h,0,p),a.splice(h<=l?l+1:l,1),r&&r.splice(h<=l?l+1:l,1)}else if(h<c&&a[h]===t&&(l>=c||a[l]!==e)){var f=r?r[h]:void 0;a.splice(l,0,e),r&&r.splice(l,0,f),a.splice(l<=h?h+1:h,1),r&&r.splice(l<=h?h+1:h,1)}}},a}),{isClass:!0});Kt("bin",["typed","format"],(e=>{var{typed:t,format:n}=e;return t("bin",{"number | BigNumber":function(e){return n(e,{notation:"bin"})},"number | BigNumber, number | BigNumber":function(e,t){return n(e,{notation:"bin",wordSize:t})}})}));var to="matrix",no=Kt(to,["typed","Matrix","DenseMatrix","SparseMatrix"],(e=>{var{typed:t,Matrix:n,DenseMatrix:r,SparseMatrix:a}=e;return t(to,{"":function(){return o([])},string:function(e){return o([],e)},"string, string":function(e,t){return o([],e,t)},Array:function(e){return o(e)},Matrix:function(e){return o(e,e.storage())},"Array | Matrix, string":o,"Array | Matrix, string, string":o});function o(e,t,n){if("dense"===t||"default"===t||void 0===t)return new r(e,n);if("sparse"===t)return new a(e,n);throw new TypeError("Unknown matrix type "+JSON.stringify(t)+".")}}));function ro(){throw new Error('No "matrix" implementation available')}var ao="size",oo=Kt(ao,["typed","config","?matrix"],(e=>{var{typed:t,config:n,matrix:r}=e;return t(ao,{Matrix:function(e){return e.create(e.size(),"number")},Array:ur,string:function(e){return"Array"===n.matrix?[e.length]:r([e.length],"dense","number")},"number | Complex | BigNumber | Unit | boolean | null":function(e){return"Array"===n.matrix?[]:r?r([],"dense","number"):ro()}})})),io=Kt("matAlgo11xS0s",["typed","equalScalar"],(e=>{var{typed:t,equalScalar:n}=e;return function(e,r,a,o){var i=e._values,s=e._index,u=e._ptr,c=e._size,l=e._datatype;if(!i)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var h,d=c[0],p=c[1],f=n,m=0,g=a;"string"===typeof l&&(h=l,f=t.find(n,[h,h]),m=t.convert(0,h),r=t.convert(r,h),g=t.find(a,[h,h]));for(var y=[],b=[],v=[],x=0;x<p;x++){v[x]=b.length;for(var w=u[x],k=u[x+1],C=w;C<k;C++){var D=s[C],S=o?g(r,i[C]):g(i[C],r);f(S,m)||(b.push(D),y.push(S))}}return v[p]=b.length,e.createSparseMatrix({values:y,index:b,ptr:v,size:[d,p],datatype:h})}})),so=Kt("matAlgo14xDs",["typed"],(e=>{var{typed:t}=e;return function(e,r,a,o){var i,s=e._data,u=e._size,c=e._datatype,l=a;"string"===typeof c&&(i=c,r=t.convert(r,i),l=t.find(a,[i,i]));var h=u.length>0?n(l,0,u,u[0],s,r,o):[];return e.createDenseMatrix({data:h,size:jt(u),datatype:i})};function n(e,t,r,a,o,i,s){var u=[];if(t===r.length-1)for(var c=0;c<a;c++)u[c]=s?e(i,o[c]):e(o[c],i);else for(var l=0;l<a;l++)u[l]=n(e,t+1,r,r[t+1],o[l],i,s);return u}}));var uo="equal";Kt(uo,["typed","equalScalar"],(e=>{var{typed:t,equalScalar:n}=e;return t(uo,{"any, any":function(e,t){return null===e?null===t:null===t?null===e:void 0===e?void 0===t:void 0===t?void 0===e:n(e,t)}})}));function co(e,t,n,r){if(!(this instanceof co))throw new SyntaxError("Constructor must be called with the new operator");this.fn=e,this.count=t,this.min=n,this.max=r,this.message="Wrong number of arguments in function "+e+" ("+t+" provided, "+n+(void 0!==r&&null!==r?"-"+r:"")+" expected)",this.stack=(new Error).stack}co.prototype=new Error,co.prototype.constructor=Error,co.prototype.name="ArgumentsError",co.prototype.isArgumentsError=!0;or.signature="any, any";var lo=Kt("dot",["typed","addScalar","multiplyScalar","conj","size"],(e=>{var{typed:t,addScalar:n,multiplyScalar:r,conj:a,size:o}=e;return t("dot",{"Array | DenseMatrix, Array | DenseMatrix":function(e,o){var u=i(e,o),c=lt(e)?e._data:e,l=lt(e)?e._datatype||e.getDataType():void 0,h=lt(o)?o._data:o,d=lt(o)?o._datatype||o.getDataType():void 0,p=2===s(e).length,f=2===s(o).length,m=n,g=r;if(l&&d&&l===d&&"string"===typeof l&&"mixed"!==l){var y=l;m=t.find(n,[y,y]),g=t.find(r,[y,y])}if(!p&&!f){for(var b=g(a(c[0]),h[0]),v=1;v<u;v++)b=m(b,g(a(c[v]),h[v]));return b}if(!p&&f){for(var x=g(a(c[0]),h[0][0]),w=1;w<u;w++)x=m(x,g(a(c[w]),h[w][0]));return x}if(p&&!f){for(var k=g(a(c[0][0]),h[0]),C=1;C<u;C++)k=m(k,g(a(c[C][0]),h[C]));return k}if(p&&f){for(var D=g(a(c[0][0]),h[0][0]),S=1;S<u;S++)D=m(D,g(a(c[S][0]),h[S][0]));return D}},"SparseMatrix, SparseMatrix":function(e,t){i(e,t);var a=e._index,o=e._values,s=t._index,u=t._values,c=0,l=n,h=r,d=0,p=0;for(;d<a.length&&p<s.length;){var f=a[d],m=s[p];f<m?d++:f>m?p++:f===m&&(c=l(c,h(o[d],u[p])),d++,p++)}return c}});function i(e,t){var n,r,a=s(e),o=s(t);if(1===a.length)n=a[0];else{if(2!==a.length||1!==a[1])throw new RangeError("Expected a column vector, instead got a matrix of size ("+a.join(", ")+")");n=a[0]}if(1===o.length)r=o[0];else{if(2!==o.length||1!==o[1])throw new RangeError("Expected a column vector, instead got a matrix of size ("+o.join(", ")+")");r=o[0]}if(n!==r)throw new RangeError("Vectors must have equal length ("+n+" != "+r+")");if(0===n)throw new RangeError("Cannot calculate the dot product of empty vectors");return n}function s(e){return lt(e)?e.size():o(e)}})),ho="number | BigNumber | Fraction | Matrix | Array";"".concat(ho,", ").concat(ho,", ...").concat(ho);var po="multiply",fo=Kt(po,["typed","matrix","addScalar","multiplyScalar","equalScalar","dot"],(e=>{var{typed:t,matrix:n,addScalar:r,multiplyScalar:a,equalScalar:o,dot:i}=e,s=io({typed:t,equalScalar:o}),u=so({typed:t});function c(e,t){switch(e.length){case 1:switch(t.length){case 1:if(e[0]!==t[0])throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");break;case 2:if(e[0]!==t[0])throw new RangeError("Dimension mismatch in multiplication. Vector length ("+e[0]+") must match Matrix rows ("+t[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+t.length+" dimensions)")}break;case 2:switch(t.length){case 1:if(e[1]!==t[0])throw new RangeError("Dimension mismatch in multiplication. Matrix columns ("+e[1]+") must match Vector length ("+t[0]+")");break;case 2:if(e[1]!==t[0])throw new RangeError("Dimension mismatch in multiplication. Matrix A columns ("+e[1]+") must match Matrix B rows ("+t[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+t.length+" dimensions)")}break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has "+e.length+" dimensions)")}}function l(e,n){if("dense"!==n.storage())throw new Error("Support for SparseMatrix not implemented");return function(e,n){var o,i=e._data,s=e._size,u=e._datatype||e.getDataType(),c=n._data,l=n._size,h=n._datatype||n.getDataType(),d=s[0],p=l[1],f=r,m=a;u&&h&&u===h&&"string"===typeof u&&"mixed"!==u&&(o=u,f=t.find(r,[o,o]),m=t.find(a,[o,o]));for(var g=[],y=0;y<p;y++){for(var b=m(i[0],c[0][y]),v=1;v<d;v++)b=f(b,m(i[v],c[v][y]));g[y]=b}return e.createDenseMatrix({data:g,size:[p],datatype:u===e._datatype&&h===n._datatype?o:void 0})}(e,n)}var h=t("_multiplyMatrixVector",{"DenseMatrix, any":function(e,n){var o,i=e._data,s=e._size,u=e._datatype||e.getDataType(),c=n._data,l=n._datatype||n.getDataType(),h=s[0],d=s[1],p=r,f=a;u&&l&&u===l&&"string"===typeof u&&"mixed"!==u&&(o=u,p=t.find(r,[o,o]),f=t.find(a,[o,o]));for(var m=[],g=0;g<h;g++){for(var y=i[g],b=f(y[0],c[0]),v=1;v<d;v++)b=p(b,f(y[v],c[v]));m[g]=b}return e.createDenseMatrix({data:m,size:[h],datatype:u===e._datatype&&l===n._datatype?o:void 0})},"SparseMatrix, any":function(e,n){var i=e._values,s=e._index,u=e._ptr,c=e._datatype||void 0===e._data?e._datatype:e.getDataType();if(!i)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var l,h=n._data,d=n._datatype||n.getDataType(),p=e._size[0],f=n._size[0],m=[],g=[],y=[],b=r,v=a,x=o,w=0;c&&d&&c===d&&"string"===typeof c&&"mixed"!==c&&(l=c,b=t.find(r,[l,l]),v=t.find(a,[l,l]),x=t.find(o,[l,l]),w=t.convert(0,l));var k=[],C=[];y[0]=0;for(var D=0;D<f;D++){var S=h[D];if(!x(S,w))for(var E=u[D],I=u[D+1],N=E;N<I;N++){var T=s[N];C[T]?k[T]=b(k[T],v(S,i[N])):(C[T]=!0,g.push(T),k[T]=v(S,i[N]))}}for(var A=g.length,F=0;F<A;F++){var _=g[F];m[F]=k[_]}return y[1]=g.length,e.createSparseMatrix({values:m,index:g,ptr:y,size:[p,1],datatype:c===e._datatype&&d===n._datatype?l:void 0})}}),d=t("_multiplyMatrixMatrix",{"DenseMatrix, DenseMatrix":function(e,n){var o,i=e._data,s=e._size,u=e._datatype||e.getDataType(),c=n._data,l=n._size,h=n._datatype||n.getDataType(),d=s[0],p=s[1],f=l[1],m=r,g=a;u&&h&&u===h&&"string"===typeof u&&"mixed"!==u&&"mixed"!==u&&(o=u,m=t.find(r,[o,o]),g=t.find(a,[o,o]));for(var y=[],b=0;b<d;b++){var v=i[b];y[b]=[];for(var x=0;x<f;x++){for(var w=g(v[0],c[0][x]),k=1;k<p;k++)w=m(w,g(v[k],c[k][x]));y[b][x]=w}}return e.createDenseMatrix({data:y,size:[d,f],datatype:u===e._datatype&&h===n._datatype?o:void 0})},"DenseMatrix, SparseMatrix":function(e,n){var i=e._data,s=e._size,u=e._datatype||e.getDataType(),c=n._values,l=n._index,h=n._ptr,d=n._size,p=n._datatype||void 0===n._data?n._datatype:n.getDataType();if(!c)throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");var f,m=s[0],g=d[1],y=r,b=a,v=o,x=0;u&&p&&u===p&&"string"===typeof u&&"mixed"!==u&&(f=u,y=t.find(r,[f,f]),b=t.find(a,[f,f]),v=t.find(o,[f,f]),x=t.convert(0,f));for(var w=[],k=[],C=[],D=n.createSparseMatrix({values:w,index:k,ptr:C,size:[m,g],datatype:u===e._datatype&&p===n._datatype?f:void 0}),S=0;S<g;S++){C[S]=k.length;var E=h[S],I=h[S+1];if(I>E)for(var N=0,T=0;T<m;T++){for(var A=T+1,F=void 0,_=E;_<I;_++){var R=l[_];N!==A?(F=b(i[T][R],c[_]),N=A):F=y(F,b(i[T][R],c[_]))}N!==A||v(F,x)||(k.push(T),w.push(F))}}return C[g]=k.length,D},"SparseMatrix, DenseMatrix":function(e,n){var i=e._values,s=e._index,u=e._ptr,c=e._datatype||void 0===e._data?e._datatype:e.getDataType();if(!i)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var l,h=n._data,d=n._datatype||n.getDataType(),p=e._size[0],f=n._size[0],m=n._size[1],g=r,y=a,b=o,v=0;c&&d&&c===d&&"string"===typeof c&&"mixed"!==c&&(l=c,g=t.find(r,[l,l]),y=t.find(a,[l,l]),b=t.find(o,[l,l]),v=t.convert(0,l));for(var x=[],w=[],k=[],C=e.createSparseMatrix({values:x,index:w,ptr:k,size:[p,m],datatype:c===e._datatype&&d===n._datatype?l:void 0}),D=[],S=[],E=0;E<m;E++){k[E]=w.length;for(var I=E+1,N=0;N<f;N++){var T=h[N][E];if(!b(T,v))for(var A=u[N],F=u[N+1],_=A;_<F;_++){var R=s[_];S[R]!==I?(S[R]=I,w.push(R),D[R]=y(T,i[_])):D[R]=g(D[R],y(T,i[_]))}}for(var M=k[E],O=w.length,z=M;z<O;z++){var L=w[z];x[z]=D[L]}}return k[m]=w.length,C},"SparseMatrix, SparseMatrix":function(e,n){var o,i=e._values,s=e._index,u=e._ptr,c=e._datatype||void 0===e._data?e._datatype:e.getDataType(),l=n._values,h=n._index,d=n._ptr,p=n._datatype||void 0===n._data?n._datatype:n.getDataType(),f=e._size[0],m=n._size[1],g=i&&l,y=r,b=a;c&&p&&c===p&&"string"===typeof c&&"mixed"!==c&&(o=c,y=t.find(r,[o,o]),b=t.find(a,[o,o]));for(var v,x,w,k,C,D,S,E,I=g?[]:void 0,N=[],T=[],A=e.createSparseMatrix({values:I,index:N,ptr:T,size:[f,m],datatype:c===e._datatype&&p===n._datatype?o:void 0}),F=g?[]:void 0,_=[],R=0;R<m;R++){T[R]=N.length;var M=R+1;for(C=d[R],D=d[R+1],k=C;k<D;k++)if(E=h[k],g)for(x=u[E],w=u[E+1],v=x;v<w;v++)_[S=s[v]]!==M?(_[S]=M,N.push(S),F[S]=b(l[k],i[v])):F[S]=y(F[S],b(l[k],i[v]));else for(x=u[E],w=u[E+1],v=x;v<w;v++)_[S=s[v]]!==M&&(_[S]=M,N.push(S));if(g)for(var O=T[R],z=N.length,L=O;L<z;L++){var B=N[L];I[L]=F[B]}}return T[m]=N.length,A}});return t(po,a,{"Array, Array":t.referTo("Matrix, Matrix",(e=>(t,r)=>{c(ur(t),ur(r));var a=e(n(t),n(r));return lt(a)?a.valueOf():a})),"Matrix, Matrix":function(e,t){var n=e.size(),r=t.size();return c(n,r),1===n.length?1===r.length?function(e,t,n){if(0===n)throw new Error("Cannot multiply two empty vectors");return i(e,t)}(e,t,n[0]):l(e,t):1===r.length?h(e,t):d(e,t)},"Matrix, Array":t.referTo("Matrix,Matrix",(e=>(t,r)=>e(t,n(r)))),"Array, Matrix":t.referToSelf((e=>(t,r)=>e(n(t,r.storage()),r))),"SparseMatrix, any":function(e,t){return s(e,t,a,!1)},"DenseMatrix, any":function(e,t){return u(e,t,a,!1)},"any, SparseMatrix":function(e,t){return s(t,e,a,!0)},"any, DenseMatrix":function(e,t){return u(t,e,a,!0)},"Array, any":function(e,t){return u(n(e),t,a,!1).valueOf()},"any, Array":function(e,t){return u(n(t),e,a,!0).valueOf()},"any, any":a,"any, any, ...any":t.referToSelf((e=>(t,n,r)=>{for(var a=e(t,n),o=0;o<r.length;o++)a=e(a,r[o]);return a}))})}));__webpack_require__(939);var mo="unequal";Kt(mo,["typed","equalScalar"],(e=>{var{typed:t,equalScalar:n}=e;return t(mo,{"any, any":function(e,t){return null===e?null!==t:null===t?null!==e:void 0===e?void 0!==t:void 0===t?void 0!==e:!n(e,t)}})}));var go=Yt({config:l}),yo=En({}),bo=Yn({}),vo=Qn({}),xo=Ar({Matrix:vo}),wo=_r({BigNumber:go,Complex:yo,DenseMatrix:xo,Fraction:bo}),ko=xa({typed:wo}),Co=_a({typed:wo}),Do=za({config:l,typed:wo}),So=Ka({typed:wo}),Eo=eo({Matrix:vo,equalScalar:Do,typed:wo}),Io=no({DenseMatrix:xo,Matrix:vo,SparseMatrix:Eo,typed:wo}),No=oo({matrix:Io,config:l,typed:wo}),To=lo({addScalar:ko,conj:Co,multiplyScalar:So,size:No,typed:wo}),Ao=fo({addScalar:ko,dot:To,equalScalar:Do,matrix:Io,multiplyScalar:So,typed:wo}),Fo=__webpack_require__(554),_o=__webpack_require__.n(Fo);class Ro{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Mo{refCount(e){return Oo("refCount")}incRef(e){return Oo("incRef")}timerAvailable(){return!0}time(e){return Oo("time")}read(e){return Oo("read")}readSync(e){return Oo("readSync")}readToGPU(e,t){return Oo("readToGPU")}numDataIds(){return Oo("numDataIds")}disposeData(e,t){return Oo("disposeData")}write(e,t,n){return Oo("write")}move(e,t,n,r,a){return Oo("move")}createTensorFromGPUData(e,t,n){return Oo("createTensorFromGPUData")}memory(){return Oo("memory")}floatPrecision(){return Oo("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Oo("dispose")}}function Oo(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function zo(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Po(e,t,n)}function Lo(e,t,n){return Math.max(e,Math.min(t,n))}function Bo(e){return e%2===0?e:e+1}function Po(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function Wo(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function Uo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Wo(jo(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function Vo(e){Wo(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Go(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function jo(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Ho(e){return e%1===0}function qo(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Ko(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Xo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,o)=>{let i=0;const s=()=>{if(e())return void a();i++;const u=t(i);null!=n&&i>=n?o():null!=r?r(s,u):setTimeout(s,u)};s()}))}function Yo(e,t){let n=1,r=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==r)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(r," and dim ").concat(o));r=o}else if(e[o]<0)throw Error("Shapes can not be < 0. Found ".concat(e[o]," at dim ").concat(o));if(-1===r){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const a=e.slice();return a[r]=t/n,a}function Qo(e,t){const n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),Wo(e.every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),Wo(e.every((e=>Ho(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function Zo(e,t){const n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||a?null:Qo(t,e).sort();let i=0;for(let s=0;s<e.length;++s){if(null!=o){if(o[i]===s&&1!==e[s])throw new Error("Can't squeeze axis ".concat(s," since its dim '").concat(e[s],"' is not 1"));(null==o[i]||o[i]>s)&&1===e[s]&&(n.push(e[s]),r.push(s)),o[i]<=s&&i++}1!==e[s]&&(n.push(e[s]),r.push(s))}return{newShape:n,keptDims:r}}function Jo(e,t){return $o(e,t)}function $o(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function ei(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function ti(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function ni(e){return"string"===typeof e||e instanceof String}function ri(e){return"number"===typeof e}function ai(e){return Array.isArray(e)?ai(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":ri(e)?"float32":ni(e)?"string":"boolean"===typeof e?"bool":"float32"}function oi(e){return!!(e&&e.constructor&&e.call&&e.apply)}function ii(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function si(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function ui(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let t=0;t<o;t++)a[t]=n[e+t]}else{const o=t[0],i=t.slice(1),s=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<o;t++)a[t]=ui(e+t*s,i,n,r)}return a}function ci(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return ui(0,e,t,n)}function li(e,t){const n=hi(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function hi(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function di(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return ci(e,new Float32Array(n));if("int32"===t)return ci(e,new Int32Array(n));if("bool"===t)return ci(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function pi(e){e.forEach((t=>{Wo(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function fi(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function mi(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function gi(e){return e&&e.then&&"function"===typeof e.then}const yi="tfjsflags";class bi{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=vi,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(xi().getBool("IS_TEST")||xi().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];xi().getBool("IS_TEST")||xi().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(gi(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(yi in e){e[yi].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)}))}}}function vi(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function xi(){return ki}let wi,ki=null;function Ci(){if(null==wi){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof __webpack_require__.g)e=__webpack_require__.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}wi=e}return wi}function Di(e,t){const n=function(){const e=Ci();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Si="Abs",Ei="Acos",Ii="Acosh",Ni="Add",Ti="AddN",Ai="All",Fi="Any",_i="ArgMax",Ri="ArgMin",Mi="Asin",Oi="Asinh",zi="Atan",Li="Atanh",Bi="Atan2",Pi="AvgPool",Wi="AvgPoolGrad",Ui="AvgPool3D",Vi="AvgPool3DGrad",Gi="BatchMatMul",ji="BatchToSpaceND",Hi="Bincount",qi="BitwiseAnd",Ki="BroadcastArgs",Xi="Cast",Yi="Ceil",Qi="ClipByValue",Zi="Complex",Ji="ComplexAbs",$i="Concat",es="Conv2D",ts="Conv2DBackpropFilter",ns="Conv2DBackpropInput",rs="Conv3D",as="Conv3DBackpropFilterV2",os="Conv3DBackpropInputV2",is="Cos",ss="Cosh",us="Cumprod",cs="Cumsum",ls="CropAndResize",hs="DenseBincount",ds="DepthToSpace",ps="DepthwiseConv2dNative",fs="DepthwiseConv2dNativeBackpropFilter",ms="DepthwiseConv2dNativeBackpropInput",gs="Diag",ys="Dilation2D",bs="Dilation2DBackpropInput",vs="Dilation2DBackpropFilter",xs="Draw",ws="RealDiv",ks="Einsum",Cs="Elu",Ds="EluGrad",Ss="Erf",Es="Equal",Is="Exp",Ns="ExpandDims",Ts="Expm1",As="FFT",Fs="Fill",_s="FlipLeftRight",Rs="Floor",Ms="FloorDiv",Os="FusedBatchNorm",zs="GatherV2",Ls="GatherNd",Bs="Greater",Ps="GreaterEqual",Ws="Identity",Us="IFFT",Vs="Imag",Gs="IsFinite",js="IsInf",Hs="IsNan",qs="LeakyRelu",Ks="Less",Xs="LessEqual",Ys="LinSpace",Qs="Log",Zs="Log1p",Js="LogicalAnd",$s="LogicalNot",eu="LogicalOr",tu="LRN",nu="LRNGrad",ru="Max",au="Maximum",ou="MaxPool",iu="MaxPoolGrad",su="MaxPool3D",uu="MaxPool3DGrad",cu="MaxPoolWithArgmax",lu="Mean",hu="Min",du="Minimum",pu="MirrorPad",fu="Mod",mu="Multinomial",gu="Multiply",yu="Neg",bu="NotEqual",vu="NonMaxSuppressionV3",xu="NonMaxSuppressionV4",wu="NonMaxSuppressionV5",ku="OnesLike",Cu="OneHot",Du="Pack",Su="PadV2",Eu="Pow",Iu="Prelu",Nu="Prod",Tu="RaggedGather",Au="RaggedRange",Fu="RaggedTensorToTensor",_u="Range",Ru="Real",Mu="Reciprocal",Ou="Relu",zu="Reshape",Lu="ResizeNearestNeighbor",Bu="ResizeNearestNeighborGrad",Pu="ResizeBilinear",Wu="ResizeBilinearGrad",Uu="Relu6",Vu="Reverse",Gu="Round",ju="Rsqrt",Hu="ScatterNd",qu="TensorScatterUpdate",Ku="SearchSorted",Xu="Select",Yu="Selu",Qu="Slice",Zu="Sin",Ju="Sinh",$u="Sign",ec="Sigmoid",tc="Softplus",nc="Sqrt",rc="Sum",ac="SpaceToBatchND",oc="SplitV",ic="Softmax",sc="SparseFillEmptyRows",uc="SparseReshape",cc="SparseSegmentMean",lc="SparseSegmentSum",hc="SparseToDense",dc="SquaredDifference",pc="Square",fc="StaticRegexReplace",mc="StridedSlice",gc="StringNGrams",yc="StringSplit",bc="StringToHashBucketFast",vc="Sub",xc="Tan",wc="Tanh",kc="Tile",Cc="TopK",Dc="Transform",Sc="Transpose",Ec="Unique",Ic="Unpack",Nc="UnsortedSegmentSum",Tc="ZerosLike",Ac="Step",Fc="FromPixels",_c="RotateWithOffset",Rc="_FusedMatMul",Mc="FusedConv2D",Oc="FusedDepthwiseConv2D";function zc(){xi().getBool("IS_TEST")||xi().getBool("PROD")||console.warn(...arguments)}function Lc(){xi().getBool("IS_TEST")||xi().getBool("PROD")||console.log(...arguments)}const Bc=Di("kernelRegistry",(()=>new Map)),Pc=Di("gradRegistry",(()=>new Map));function Wc(e,t){const n=Hc(e,t);return Bc.get(n)}function Uc(e){return Pc.get(e)}function Vc(e){const t=Bc.entries(),n=[];for(;;){const{done:r,value:a}=t.next();if(r)break;const[o,i]=a,[s]=o.split("_");s===e&&n.push(i)}return n}function Gc(e){const{kernelName:t,backendName:n}=e,r=Hc(t,n);Bc.has(r)&&zc("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),Bc.set(r,e)}function jc(e){const{kernelName:t}=e;Pc.has(t)&&xi().getBool("DEBUG")&&zc("Overriding the gradient for '".concat(t,"'")),Pc.set(t,e)}function Hc(e,t){return"".concat(t,"_").concat(e)}function qc(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Kc=__webpack_require__(353);const Xc=__webpack_require__.n(Kc)()||Kc;function Yc(e){return Xc.fromString(e,!0,16)}const Qc=Yc("c3a5c85c97cb3127"),Zc=Yc("b492b66fbe98f273"),Jc=Yc("9ae16a3b2f90404f");function $c(e){return e.xor(e.shru(47))}function el(e,t,n){const r=e.slice(t,t+n);return Xc.fromBytes(Array.from(r),!0,!0)}function tl(e,t){return el(e,t,8)}function nl(e,t){return el(e,t,4)}function rl(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function al(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Yc("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function ol(e,t,n,r){return function(e,t,n,r,a,o){a=a.add(e),o=rl(o.add(a).add(r),21);const i=a;return a=(a=a.add(t)).add(n),o=o.add(rl(a,44)),[a.add(r),o.add(i)]}(tl(e,t),tl(e,t+8),tl(e,t+16),tl(e,t+24),n,r)}function il(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Xc.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=Jc.add(2*t),r=tl(e,0).add(Jc),a=tl(e,t-8);return al(rl(a,37).mul(n).add(r),rl(r,25).add(a).mul(n),n)}if(t>=4){const n=Jc.add(2*t);return al(nl(e,0).shl(3).add(t),nl(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return $c(Jc.mul(n).xor(Qc.mul(r))).mul(Jc)}return Jc}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Jc.add(2*t),r=tl(e,0).mul(Zc),a=tl(e,8),o=tl(e,t-8).mul(n),i=tl(e,t-16).mul(Jc);return al(rl(r.add(a),43).add(rl(o,30)).add(i),r.add(rl(a.add(Jc),18)).add(o),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Jc.add(2*t),r=tl(e,0).mul(Jc),a=tl(e,8),o=tl(e,t-8).mul(n),i=tl(e,t-16).mul(Jc),s=rl(r.add(a),43).add(rl(o,30)).add(i),u=al(s,r.add(rl(a.add(Jc),18)).add(o),n),c=tl(e,16).mul(n),l=tl(e,24),h=s.add(tl(e,t-32)).mul(n),d=u.add(tl(e,t-24)).mul(n);return al(rl(c.add(l),43).add(rl(h,30)).add(d),c.add(rl(l.add(r),18)).add(h),n)}(e,t);let r=n,a=n.mul(Zc).add(113),o=$c(a.mul(Jc).add(113)).mul(Jc),i=[Xc.UZERO,Xc.UZERO],s=[Xc.UZERO,Xc.UZERO];r=r.mul(Jc).add(tl(e,0));let u=0;const c=64*(t-1>>6),l=c+(t-1&63)-63;do{r=rl(r.add(a).add(i[0]).add(tl(e,u+8)),37).mul(Zc),a=rl(a.add(i[1]).add(tl(e,u+48)),42).mul(Zc),r=r.xor(s[1]),a=a.add(i[0]).add(tl(e,u+40)),o=rl(o.add(s[0]),33).mul(Zc),i=ol(e,u,i[1].mul(Zc),r.add(s[0])),s=ol(e,u+32,o.add(s[1]),a.add(tl(e,u+16))),[o,r]=[r,o],u+=64}while(u!==c);const h=Zc.add(o.and(255).shl(1));return u=l,s[0]=s[0].add(t-1&63),i[0]=i[0].add(s[0]),s[0]=s[0].add(i[0]),r=rl(r.add(a).add(i[0]).add(tl(e,u+8)),37).mul(h),a=rl(a.add(i[1]).add(tl(e,u+48)),42).mul(h),r=r.xor(s[1].mul(9)),a=a.add(i[0].mul(9).add(tl(e,u+40))),o=rl(o.add(s[0]),33).mul(h),i=ol(e,u,i[1].mul(h),r.add(s[0])),s=ol(e,u+32,o.add(s[1]),a.add(tl(e,u+16))),[o,r]=[r,o],al(al(i[0],s[0],h).add($c(a).mul(Qc)).add(o),al(i[1],s[1],h).add(r),h)}function sl(e,t){return"string"===t?ll(e):ul([e],t)}function ul(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=pl(e)),xi().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(r,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function cl(){return xi().platform.now()}function ll(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",xi().platform.encode(e,t)}function hl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",xi().platform.decode(e,t)}function dl(e){return null!=xi().platform.isTypedArray?xi().platform.isTypedArray(e):qc(e)}function pl(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||gi(e)||null==e||dl(e)&&n)t.push(e);else if(Array.isArray(e)||dl(e))for(let r=0;r<e.length;++r)pl(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)pl(e[a],t,n)}return t}class fl{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new gl)}profileKernel(e,t,n){let r;const a=()=>{r=n()};let o;const i=cl();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const e of r)e.dataSync();o=Promise.resolve({kernelMs:cl()-i})}if(xi().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let s=0;s<r.length;s++){const t=r[s];t.data().then((n=>{ml(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then((e=>e.kernelMs)),extraInfo:o.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:o}=e;n.forEach((e=>{Promise.all([e.data(),r,o]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}function ml(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class gl{logKernelProfile(e,t,n,r,a,o){const i="number"===typeof r?Ko("".concat(r,"ms"),9):r.error,s=Ko(e,25),u=t.rank,c=t.size,l=Ko(t.shape.toString(),14);let h="";for(const d in a){const e=a[d];if(null!=e){const n=e.shape||t.shape,r=n.length;h+="".concat(d,": ").concat(r,"D ").concat(r>0?n:""," ")}}console.log("%c".concat(s,"\t%c").concat(i,"\t%c").concat(u,"D ").concat(l,"\t%c").concat(c,"\t%c").concat(h,"\t%c").concat(o),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function yl(e,t,n,r){const a=si(t),o=function(e,t,n,r){const a=Go(t),o=r[r.length-1],i=new Array(o).fill(0),s=t.length,u="complex64"===n?wl(e):e;if(s>1)for(let c=0;c<a/o;c++){const e=c*o;for(let t=0;t<o;t++)i[t]=Math.max(i[t],bl(u[e+t],0,n).length)}return i}(e,t,n,a),i=t.length,s=xl(e,t,n,a,o),u=["Tensor"];return r&&(u.push("  dtype: ".concat(n)),u.push("  rank: ".concat(i)),u.push("  shape: [".concat(t,"]")),u.push("  values:")),u.push(s.map((e=>"    "+e)).join("\n")),u.join("\n")}function bl(e,t,n){let r;return r=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(7))," + ")+"".concat(parseFloat(e[1].toFixed(7)),"j"):ni(e)?"'".concat(e,"'"):"bool"===n?vl(e):parseFloat(e.toFixed(7)).toString(),Ko(r,t)}function vl(e){return 0===e?"false":"true"}function xl(e,t,n,r,a){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,s=t[0],u=t.length;if(0===u){if("complex64"===n){return[bl(wl(e)[0],0,n)]}return"bool"===n?[vl(e[0])]:[e[0].toString()]}if(1===u){if(s>20){const t=3*i;let r=Array.from(e.slice(0,t)),o=Array.from(e.slice((s-3)*i,s*i));return"complex64"===n&&(r=wl(r),o=wl(o)),["["+r.map(((e,t)=>bl(e,a[t],n))).join(", ")+", ..., "+o.map(((e,t)=>bl(e,a[s-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?wl(e):Array.from(e)).map(((e,t)=>bl(e,a[t],n))).join(", ")+"]"]}const c=t.slice(1),l=r.slice(1),h=r[0]*i,d=[];if(s>20){for(let t=0;t<3;t++){const r=t*h,o=r+h;d.push(...xl(e.slice(r,o),c,n,l,a,!1))}d.push("...");for(let t=s-3;t<s;t++){const r=t*h,o=r+h;d.push(...xl(e.slice(r,o),c,n,l,a,t===s-1))}}else for(let m=0;m<s;m++){const t=m*h,r=t+h;d.push(...xl(e.slice(t,r),c,n,l,a,m===s-1))}const p=2===u?",":"";d[0]="["+(s>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<u;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":f),d}function wl(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class kl{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Go(e),null!=n){const e=n.length;Wo(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||$o(t,this.size),this.strides=si(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),Wo(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const a=this.locToIndex(n);this.values[a]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const o of t){if(o<0||o>=this.shape[r]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}r++}let a=t[t.length-1];for(let o=0;o<t.length-1;++o)a+=this.strides[o]*t[o];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Cl().makeTensor(this.values,this.shape,this.dtype)}}let Cl=null,Dl=null,Sl=null;class El{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Go(e),this.strides=si(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Dl.buffer(this.shape,this.dtype,e)}bufferSync(){return Dl.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ci(this.shape,e,"complex64"===this.dtype)}arraySync(){return ci(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Cl().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>hl(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Cl().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Cl().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>hl(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Cl().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Cl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Dl.print(this,e)}clone(){return this.throwIfDisposed(),Dl.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return yl(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Dl.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Cl().makeVariable(this,e,t,n)}}function Il(){return Di("Tensor",(()=>El))}Object.defineProperty(El,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Il();class Nl extends El{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!jo(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));Cl().disposeTensor(this),this.dataId=e.dataId,Cl().incRef(this,null)}dispose(){Cl().disposeVariable(this),this.isDisposedInternal=!0}}var Tl,Al,Fl,_l,Rl;Object.defineProperty(Nl,Symbol.hasInstance,{value:e=>e instanceof El&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Tl||(Tl={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Al||(Al={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Fl||(Fl={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(_l||(_l={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Rl||(Rl={}));const Ml={float32:_l,int32:Al,bool:Fl,complex64:Rl};function Ol(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return Ml[e][t]}function zl(e){return Ol(e,"int32")}function Ll(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Bl(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Pl(e,t){if(e.dtype===t.dtype)return[e,t];const n=Ol(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Wl(e,t){return t.some((t=>t.id===e.id))}function Ul(e){const t=[];return Vl(e,t,new Set),t}function Vl(e,t,n){if(null==e)return;if(e instanceof El)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=e;for(const o in a){const e=a[o];n.has(e)||(n.add(e),Vl(e,t,n))}}function Gl(e){return null!=e.kernelName}class jl{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Hl{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new jl}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(zc("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new fl(this.backendInstance),!0}setupRegisteredKernels(){Vc(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Vc(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof Mo||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,zc("Initialization of backend ".concat(e," failed")),zc(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return zc("Initialization of backend ".concat(e," failed")),zc(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Hl.nextTensorId++}nextVariableId(){return Hl.nextVariableId++}clone(e){const t=Kl.runKernel(Ws,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Kl.runKernel(Xi,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Wc(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-o;if(i>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(i," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;let i,s;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=Gl(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Gl(e)){const{kernelName:t,inputs:a,attrs:o}=e;null==this.backendName&&this.backend;const u=Wc(t,this.backendName);Wo(null!=u,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),i=()=>{const e=this.backend.numDataIds();s=u.kernelFunc({inputs:a,attrs:o,backend:this.backend});const i=Array.isArray(s)?s:[s];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const c=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,a,c);n=this.saveTensorsForBackwardMode(e)}return c}}else{const{forwardFunc:t}=e,a=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();s=this.tidy((()=>t(this.backend,a)));const n=Array.isArray(s)?s:[s];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:c,attrs:l}=e,h=Gl(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(u,c,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()})),r&&this.addTapeNode(u,c,t,h,n,l),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((e=>null!=c[e]?c[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(s)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const r=Uc(e);if(null!=r){const e=r.inputsToSave||[],a=r.outputsToSave||[];let o;r.saveAllInputs?(Wo(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),o=Object.keys(t).map((e=>t[e]))):o=e.map((e=>t[e]));const i=n.filter(((e,t)=>a[t]));return o.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&ni(e[0])&&(a=e.map((e=>ll(e))));const o=r.write(a,t,n),i=new El(t,n,o,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(o),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e,o=new El(r,a,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const a=new Nl(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error("Variable with name ".concat(a.name," was already registered"));return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*ti(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Nl||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*ti(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},s=Uc(e);null!=s&&(r=s.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=hi(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Ul(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const e=this.state.activeScope.track[a];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Wo(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Wo(a instanceof El,(()=>"The result y returned by f() must be a tensor."));const o=function(e,t,n){const r={},a={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){const n=e[u],o=n.inputs;for(const e in o){const i=o[e];let s=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),s=!0,a[n.id]=!0;break}if(s)break}}const o={};o[n.id]=!0;const i={};for(let u=e.length-1;u>=0;u--){const t=e[u],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(o[t.outputs[e].id]){for(const e in n)o[n[e].id]=!0,i[t.id]=!0;break}}const s=[];for(let u=0;u<e.length;u++){const t=e[u];if(a[t.id]&&i[t.id]){const e={};for(const a in t.inputs){const n=t.inputs[a];r[n.id]&&(e[a]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,s.push(n)}}return s}(this.state.activeTape,t,a);if(!r&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[a.id]=null==n?function(e){const t=li(Go(e),"float32");return Kl.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){const o=t[a],i=[];if(o.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==o.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(o.kernelName,"."));const s=o.gradient(i);for(const t in o.inputs){if(!(t in s))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(s),"."));const a=n((()=>s[t]()));if("float32"!==a.dtype)throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(a.dtype,"'"));const i=o.inputs[t];if(!jo(a.shape,i.shape))throw new Error("Error in gradient for op ".concat(o.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(a.shape,"', which does not match ")+"the shape of the input '".concat(i.shape,"'"));if(null==e[i.id])e[i.id]=a;else{const t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,o,(e=>this.tidy(e)),Xl);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return Wo(oi(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let o;Wo(r.every((e=>e instanceof El)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(o=e(...r,n),Wo(o.value instanceof El,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Wo(oi(o.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),o.value),backwardsFunc:(e,t)=>{const n=o.gradFunc(e,t),a=Array.isArray(n)?n:[n];Wo(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Wo(a.every((e=>e instanceof El)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=cl(),n=await this.backend.time(e);return n.wallMs=cl()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new jl;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function ql(){const e=Ci();if(null==e._tfengine){const t=new bi(e);e._tfengine=new Hl(t)}var t;return t=e._tfengine.ENV,ki=t,Cl=()=>e._tfengine,e._tfengine}Hl.nextTensorId=0,Hl.nextVariableId=0;const Kl=ql();function Xl(e,t){const n={a:e,b:t};return Kl.runKernel(Ni,n)}let Yl;function Ql(e){if(void 0!==Yl)return Yl;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Zl(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Jl=xi();function $l(e,t){let n=e;if(dl(e))return"string"===t?[]:[e.length];if(Ll(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Bl(e))return[e.buffer.size/(null==t?4:ti(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||dl(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&xi().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&eh(e,r,[]),r}function eh(e,t,n){if(n=n||[],!Array.isArray(e)&&!dl(e))return void Wo(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));Wo(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),Wo(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const r=t.slice(1);for(let a=0;a<e.length;++a)eh(e[a],r,n.concat(a))}function th(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(r,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function nh(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof Il())return th(r,e.dtype,t,n),e;let a=ai(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),th(r,a,t,n),null==e||!dl(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(r,"'"))}const o=$l(e,a);dl(e)||Array.isArray(e)||(e=[e]);const i="string"!==a?ul(e,a):pl(e,[],!0);return Kl.makeTensor(i,o,a)}function rh(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,a)=>nh(e,"".concat(t,"[").concat(a,"]"),n,r)))}Jl.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Jl.registerFlag("IS_BROWSER",(()=>Zl())),Jl.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Jl.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Jl.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Jl.registerFlag("PROD",(()=>!1)),Jl.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Jl.getBool("DEBUG"))),Jl.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Jl.registerFlag("IS_TEST",(()=>!1)),Jl.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Jl.getBool("DEBUG"))),Jl.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Jl.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Jl.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function ah(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const a=function(){Kl.startScope(n);try{const e=r(...arguments);return gi(e)&&console.error("Cannot return a Promise inside of tidy."),Kl.endScope(e),e}catch(e){throw Kl.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const oh=ah({complex_:function(e,t){const n=nh(e,"real","complex"),r=nh(t,"imag","complex");Uo(n.shape,r.shape,"real and imag shapes, ".concat(n.shape," and ").concat(r.shape,", ")+"must match in call to tf.complex().");const a={real:n,imag:r};return Kl.runKernel(Zi,a)}});function ih(e,t,n,r){if(null==r)r=ai(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Bl(e)||Ll(e)){if("float32"!==r&&"int32"!==r)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(r,"."));return Kl.backend.createTensorFromGPUData(e,t||n,r)}if(!dl(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){pi(t);const e=Go(t),r=Go(n);Wo(e===r,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(r)));for(let a=0;a<n.length;++a){const e=n[a],r=a!==n.length-1||e!==Go(t.slice(a));Wo(n[a]===t[a]||!r,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return dl(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?ul(e,r):pl(e,[],!0),Kl.makeTensor(e,t,r)}function sh(e,t,n){return ih(e,t,$l(e,n),n)}class uh{static join(e){return new uh(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>dl(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const r=new ArrayBuffer(t-e),a=new Uint8Array(r);let o=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+o-n.start,s=o,u=Math.min(t,n.end)-n.start,c=new Uint8Array(n.buffer,r,u-r);if(a.set(c,s),o+=c.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,o=t(e[a]);if(0===o)return a;o<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function ch(){return Kl}function lh(){return Kl.memory()}function hh(e,t){return Kl.tidy(e,t)}function dh(e){Ul(e).forEach((e=>e.dispose()))}function ph(e){return Kl.keep(e)}function fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Kl.registerBackend(e,t,n)}function mh(){return Kl.backend}Sl=function(e){xi().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};async function gh(e,t){const n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let o=0;o<a.length;++o){const i=a[o],s=Array.isArray(e)?e[o].tensor:e[i];if("float32"!==s.dtype&&"int32"!==s.dtype&&"bool"!==s.dtype&&"string"!==s.dtype&&"complex64"!==s.dtype)throw new Error("Unsupported dtype in weight '".concat(i,"': ").concat(s.dtype));const u={name:i,shape:s.shape,dtype:s.dtype};if("string"===s.dtype){const e=new Promise((async e=>{const t=await s.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,r=new Uint8Array(n);let a=0;for(let o=0;o<t.length;o++){const e=t[o],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=4,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(s.data());null!=t&&(u.group=t),n.push(u)}return{data:yh(await Promise.all(r)),specs:n}}function yh(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const r=new Uint8Array(t);let a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}const bh="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function vh(e){return bh?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function xh(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function wh(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),function(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}(e,n,r)}function kh(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:vh(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:vh(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new uh(e.weightData).byteLength}}function Ch(e){const t=[];for(const n of e)t.push(...n.weights);return t}class Dh{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Dh.instance&&(Dh.instance=new Dh),Dh.instance}static registerSaveRouter(e){Dh.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Dh.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Dh.getHandlers(e,"save")}static getLoadHandlers(e,t){return Dh.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?Dh.getInstance().loadRouters:Dh.getInstance().saveRouters).forEach((t=>{const a=t(e,n);null!==a&&r.push(a)})),r}}const Sh="tensorflowjs",Eh="models_store",Ih="model_info_store";function Nh(){if(!xi().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Th(e){const t=e.result;t.createObjectStore(Eh,{keyPath:"modelPath"}),t.createObjectStore(Ih,{keyPath:"modelPath"})}class Ah{constructor(e){if(this.indexedDB=Nh(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(Sh,1);r.onupgradeneeded=()=>Th(r),r.onsuccess=()=>{const a=r.result;if(null==t){const t=a.transaction(Eh,"readonly"),r=t.objectStore(Eh).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=uh.join(t.weightData);const r=kh(t),i=a.transaction(Ih,"readwrite");let s,u,c=i.objectStore(Ih);try{s=c.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(o){return n(o)}s.onsuccess=()=>{u=a.transaction(Eh,"readwrite");const s=u.objectStore(Eh);let l;try{l=s.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(o){return n(o)}l.onsuccess=()=>e({modelArtifactsInfo:r}),l.onerror=e=>{c=i.objectStore(Ih);const t=c.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(l.error)),t.onerror=e=>(a.close(),n(l.error))}},s.onerror=e=>(a.close(),n(s.error)),i.oncomplete=()=>{null==u?a.close():u.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}}Ah.URL_SCHEME="indexeddb://";const Fh=e=>{return xi().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ah.URL_SCHEME)?(t=e.slice(Ah.URL_SCHEME.length),new Ah(t)):null;var t};Dh.registerSaveRouter(Fh),Dh.registerLoadRouter(Fh);class _h{constructor(){this.indexedDB=Nh()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(Sh,1);n.onupgradeneeded=()=>Th(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(Ih,"readonly"),o=a.objectStore(Ih).getAll();o.onsuccess=()=>{const t={};for(const e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(r.close(),t(o.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(Ah.URL_SCHEME)?t.slice(Ah.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(Sh,1);r.onupgradeneeded=()=>Th(r),r.onsuccess=()=>{const a=r.result,o=a.transaction(Ih,"readwrite"),i=o.objectStore(Ih),s=i.get(e);let u;s.onsuccess=()=>{if(null==s.result)return a.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const r=i.delete(e),o=()=>{u=a.transaction(Eh,"readwrite");const r=u.objectStore(Eh).delete(e);r.onsuccess=()=>t(s.result.modelArtifactsInfo),r.onerror=e=>n(s.error)};r.onsuccess=o,r.onerror=e=>(o(),a.close(),n(s.error))}},s.onerror=e=>(a.close(),n(s.error)),o.oncomplete=()=>{null==u?a.close():u.oncomplete=()=>a.close()}},r.onerror=e=>n(r.error)}))}}const Rh="/",Mh="tensorflowjs_models",Oh="info",zh="model_topology",Lh="weight_specs",Bh="weight_data",Ph="model_metadata";function Wh(e){return{info:[Mh,e,Oh].join(Rh),topology:[Mh,e,zh].join(Rh),weightSpecs:[Mh,e,Lh].join(Rh),weightData:[Mh,e,Bh].join(Rh),modelMetadata:[Mh,e,Ph].join(Rh)}}function Uh(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Vh(e){const t=e.split(Rh);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(Rh)}class Gh{constructor(e){if(!xi().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Wh(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=kh(e),o=uh.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(bh)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(o));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw Uh(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(a.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(a.weightSpecsBytes,", ")+"weightDataBytes=".concat(a.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(null==o)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(bh){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(o),t}}Gh.URL_SCHEME="localstorage://";const jh=e=>{return xi().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Gh.URL_SCHEME)?(t=e.slice(Gh.URL_SCHEME.length),new Gh(t)):null;var t};Dh.registerSaveRouter(jh),Dh.registerLoadRouter(jh);class Hh{constructor(){Wo(xi().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Wo("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Mh+Rh,n=Rh+Oh;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){e[Vh(a)]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){var t;const n=Wh(e=(t=e).startsWith(Gh.URL_SCHEME)?t.slice(Gh.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const r=JSON.parse(this.LS.getItem(n.info));return Uh(n),r}}const qh="://";class Kh{constructor(){this.managers={}}static getInstance(){return null==Kh.instance&&(Kh.instance=new Kh),Kh.instance}static registerManager(e,t){Wo(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(qh)&&(e=e.slice(0,e.indexOf(qh))),Wo(e.length>0,(()=>"scheme must not be an empty string."));const n=Kh.getInstance();Wo(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=Kh.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(Kh.getInstance().managers)}}class Xh{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&xi().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return qc(e)}}if(xi().get("IS_BROWSER")){xi().setPlatform("browser",new Xh);try{Kh.registerManager(Gh.URL_SCHEME,new Hh)}catch($V){}try{Kh.registerManager(Ah.URL_SCHEME,new _h)}catch($V){}}const Yh=()=>__webpack_require__(817);let Qh;class Zh{constructor(){this.util=__webpack_require__(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=xi().global.fetch?xi().global.fetch(e,t):(null==Qh&&(Qh=Yh()),Qh(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function Jh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",pi(e),new kl(e,t,n)}xi().get("IS_NODE")&&!xi().get("IS_BROWSER")&&xi().setPlatform("node",new Zh);const $h=ah({cast_:function(e,t){const n=nh(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:t};return Kl.runKernel(Xi,r,a)}});const ed=ah({clone_:function(e){const t={x:nh(e,"x","clone","string_or_numeric")};return Kl.runKernel(Ws,t)}});ql();Dl={buffer:Jh,cast:$h,clone:ed,print:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}};const td=ah({add_:function(e,t){let n=nh(e,"a","add"),r=nh(t,"b","add");[n,r]=Pl(n,r);const a={a:n,b:r};return Kl.runKernel(Ni,a)}});const nd=ah({floorDiv_:function(e,t){let n=nh(e,"a","floorDiv"),r=nh(t,"b","floorDiv");[n,r]=Pl(n,r);const a={a:n,b:r};return Kl.runKernel(Ms,a)}});const rd=ah({div_:function(e,t){let n=nh(e,"a","div"),r=nh(t,"b","div");if([n,r]=Pl(n,r),"int32"===n.dtype&&"int32"===r.dtype)return nd(n,r);const a={a:n,b:r};return Kl.runKernel(ws,a,{})}});const ad=ah({mul_:function(e,t){let n=nh(e,"a","mul"),r=nh(t,"b","mul");[n,r]=Pl(n,r);const a={a:n,b:r};return Kl.runKernel(gu,a)}});const od=ah({sqrt_:function(e){const t={x:nh(e,"x","sqrt","float32")};return Kl.runKernel(nc,t)}});const id=ah({square_:function(e){const t=nh(e,"x","square");return Kl.runKernel("Square",{x:t},{})}});const sd=ah({zerosLike_:function(e){const t={x:nh(e,"x","zerosLike")};return Kl.runKernel(Tc,t)}});function ud(e){return Kl.customGrad(e)}function cd(e,t){if((dl(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&dl(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ih(e,[],[],t)}const ld=new Map,hd=new Map;class dd{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class pd{constructor(){this.classNameMap={}}static getMap(){return null==pd.instance&&(pd.instance=new pd),pd.instance}static register(e){pd.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function fd(e,t,n){Wo(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Wo("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Wo(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return pd.register(e),ld.set(r,e),hd.set(e,r),e}class md extends dd{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return dh(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Wo(oi(e),(()=>"The f passed in variableGrads(f) must be a function")),Wo(null==t||Array.isArray(t)&&t.every((e=>e instanceof Nl)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Kl.registeredVariables)t.push(Kl.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,a=t.length;t=t.filter((e=>e.trainable)),Wo(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(a," variables is ")+"trainable."));const{value:o,grads:i}=Kl.gradients(e,t,null,!0);Wo(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Wo(0===o.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(o.rank," tensor")));const s={};return t.forEach(((e,t)=>{null!=i[t]&&(s[e.name]=i[t])})),null!=r&&r.forEach((e=>s[e.name]=null)),{value:o,grads:s}}(e,t)}dispose(){null!=this.iterations_&&dh(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:cd(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(md,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class gd extends md{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Kl.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Kl.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:hh((()=>sd(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:hh((()=>sd(r).variable(a)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const i=this.accumulatedGrads[n].variable,s=this.accumulatedUpdates[n].variable;hh((()=>{const e=td(ad(i,this.rho),ad(id(o),1-this.rho)),t=ad(rd(od(td(s,this.epsilon)),od(td(i,this.epsilon))),o),n=td(ad(s,this.rho),ad(id(t),1-this.rho));i.assign(e),s.assign(n);const a=td(ad(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(dh(this.accumulatedGrads.map((e=>e.variable))),dh(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function yd(e,t,n){pi(e);const r={shape:e,value:t,dtype:n=n||ai(t)};return Kl.runKernel(Fs,{},r)}class bd extends md{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Kl.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:hh((()=>yd(r.shape,this.initialAccumulatorValue).variable(e)))}}const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const o=this.accumulatedGrads[n].variable;hh((()=>{const e=td(o,id(a));o.assign(e);const t=td(ad(rd(a,od(td(e,Kl.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&dh(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const vd=ah({pow_:function(e,t){let n=nh(e,"base","pow"),r=nh(t,"exp","pow");[n,r]=Pl(n,r);const a={a:n,b:r};return Kl.runKernel(Eu,a)}});const xd=ah({sub_:function(e,t){let n=nh(e,"a","sub"),r=nh(t,"b","sub");[n,r]=Pl(n,r);const a={a:n,b:r};return Kl.runKernel(vc,a)}});class wd extends md{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],hh((()=>{this.accBeta1=cd(t).variable(),this.accBeta2=cd(n).variable()})),null==r&&(this.epsilon=Kl.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);hh((()=>{const n=xd(1,this.accBeta1),r=xd(1,this.accBeta2);t.forEach(((t,a)=>{const o=Kl.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(t,"/m"),variable:hh((()=>sd(o).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:"".concat(t,"/v"),variable:hh((()=>sd(o).variable(i)))});const s=Array.isArray(e)?e[a].tensor:e[t];if(null==s)return;const u=this.accumulatedFirstMoment[a].variable,c=this.accumulatedSecondMoment[a].variable,l=td(ad(u,this.beta1),ad(s,1-this.beta1)),h=td(ad(c,this.beta2),ad(id(s),1-this.beta2)),d=rd(l,n),p=rd(h,r);u.assign(l),c.assign(h);const f=td(ad(rd(d,td(od(p),this.epsilon)),-this.learningRate),o);o.assign(f)})),this.accBeta1.assign(ad(this.accBeta1,this.beta1)),this.accBeta2.assign(ad(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&dh(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&dh(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),hh((()=>{this.accBeta1.assign(vd(this.beta1,this.iterations_+1)),this.accBeta2.assign(vd(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const kd=ah({abs_:function(e){const t=nh(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Kl.runKernel(Ji,e)}{const e={x:t};return Kl.runKernel(Si,e)}}});function Cd(e,t){const n=e.length,r=[];for(let a=0;a<n;a++){const o=n-1-a,i=e[o]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(o)}return r}function Dd(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1],o=t.length-r-1,i=t[o];(null==a||1===a&&i>1)&&n.unshift(o)}return n}function Sd(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let o=e[e.length-a-1];null==o&&(o=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===o)r[n-a-1]=i;else if(1===i)r[n-a-1]=o;else{if(o!==i){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}r[n-a-1]=o}}return r}const Ed=ah({maximum_:function(e,t){let n=nh(e,"a","maximum"),r=nh(t,"b","maximum");[n,r]=Pl(n,r),"bool"===n.dtype&&(n=$h(n,"int32"),r=$h(r,"int32")),Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(au,a)}});class Id extends md{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],hh((()=>{this.iteration=cd(0).variable(),this.accBeta1=cd(t).variable()})),null==r&&(this.epsilon=Kl.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);hh((()=>{const n=xd(1,this.accBeta1),r=rd(-this.learningRate,td(ad(this.iteration,this.decay),1));t.forEach(((t,a)=>{const o=Kl.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:"".concat(t,"/m"),variable:sd(o).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:"".concat(t,"/v"),variable:sd(o).variable(i)});const s=Array.isArray(e)?e[a].tensor:e[t];if(null==s)return;const u=this.accumulatedFirstMoment[a].variable,c=this.accumulatedWeightedInfNorm[a].variable,l=td(ad(u,this.beta1),ad(s,1-this.beta1)),h=ad(c,this.beta2),d=kd(s),p=Ed(h,d);u.assign(l),c.assign(p);const f=td(ad(rd(r,n),rd(l,td(p,this.epsilon))),o);o.assign(f)})),this.iteration.assign(td(this.iteration,1)),this.accBeta1.assign(ad(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&dh(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&dh(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Nd extends md{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=Kl.registeredVariables[t];hh((()=>{const e=td(ad(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ph(cd(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Td extends Nd{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=cd(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Kl.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:hh((()=>sd(r).variable(e)))}}const a=this.accumulations[n].variable,o=Array.isArray(e)?e[n].tensor:e[t];null!=o&&hh((()=>{let e;const t=td(ad(this.m,a),o);e=this.useNesterov?td(ad(this.c,td(o,ad(t,this.m))),r):td(ad(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&dh(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Ad extends md{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Kl.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Kl.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:hh((()=>sd(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:hh((()=>sd(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:hh((()=>sd(r).variable(a)))});const o=Array.isArray(e)?e[n].tensor:e[t];if(null==o)return;const i=this.accumulatedMeanSquares[n].variable,s=this.accumulatedMoments[n].variable;hh((()=>{const e=td(ad(i,this.decay),ad(id(o),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,a=td(ad(t,this.decay),ad(o,1-this.decay)),u=rd(ad(o,this.learningRate),od(xd(e,td(id(a),this.epsilon)))),c=td(ad(s,this.momentum),u);i.assign(e),t.assign(a),s.assign(c);const l=xd(r,c);r.assign(l)}else{const e=td(ad(i,this.decay),ad(id(o),1-this.decay)),t=td(ad(s,this.momentum),rd(ad(o,this.learningRate),od(td(e,this.epsilon))));i.assign(e),s.assign(t);const n=xd(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&dh(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&dh(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&dh(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Fd=[gd,bd,wd,Id,Td,Ad,Nd];function _d(e){return new Promise((e=>setTimeout(e))).then(e)}class Rd{constructor(e){if(!xi().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Rd.URL_SCHEME)&&(e=e.slice(Rd.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=uh.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=xh(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await _d((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await _d((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:kh(e)}}}}Rd.URL_SCHEME="downloads://";function Md(e,t,n,r){!function(e){Wo(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Wo(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),Wo(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),Wo(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(e.map((o=>(o.then((o=>{const i=n+ ++a/e.length*(r-n);return t(i),o})),o))))}async function Od(e,t){null==t&&(t={});const n=null==t.fetchFunc?xi().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await Md(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await Md(a,t.onProgress,.5,1)}Dh.registerSaveRouter((e=>xi().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Rd.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Rd(e)}(e.slice(Rd.URL_SCHEME.length)):null));class zd{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Wo("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=xi().platform.fetch,Wo(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Wo(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=xh(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=uh.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:kh(e),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(r.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(a){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return wh(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Ch(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?xi().platform.fetch:t.fetchFunc;let a,o=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;o<e.length;){if(!a){const n=(await r(e[o],t.requestInit,{isBinary:!0})).body;a=n.getReader()}const{done:s,value:u}=await a.read();if(!s)return void n.enqueue(u);o++,a=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,o/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,o=[],i=[];for(const s of e)for(const e of s.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):o.push(a+e+r);return this.weightUrlConverter&&o.push(...await Promise.all(i)),o}async loadWeights(e){const t=await this.getWeightUrls(e);return[Ch(e),await Od(t,this.loadOptions)]}}function Ld(e){return null!=e.match(zd.URL_SCHEME_REGEX)}zd.URL_SCHEME_REGEX=/^https?:\/\//;const Bd=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Ld(e))):Ld(e),n)return Pd(e,t)}return null};function Pd(e,t){return new zd(e,t)}Dh.registerSaveRouter(Bd),Dh.registerLoadRouter(Bd);const Wd=-2,Ud=-1;function Vd(e,t,n){const r=e.shape.length;Wo(r===t.length,(()=>"Error in slice".concat(r,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(r,")."))),Wo(r===n.length,(()=>"Error in slice".concat(r,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(r,").")));for(let a=0;a<r;++a)Wo(t[a]+n[a]<=e.shape[a],(()=>"Error in slice".concat(r,"D: begin[").concat(a,"] + size[").concat(a,"] ")+"(".concat(t[a]+n[a],") would overflow input.shape[").concat(a,"] (").concat(e.shape[a],")")))}function Gd(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function jd(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function Hd(e,t,n,r){const a=[...e];for(let o=a.length;o<r.length;o++)a.push(1);for(let o=0;o<n;o++)0===o?a[t]=1:(a.splice(t,0,1),a.pop());return a}function qd(e,t,n){return n<=e?n:n-(t-1)}function Kd(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Xd(e,t,n,r,a,o,i,s,u){const c=e.length;let l=new Array(c),h=new Array(c),d=new Array(c);if(t.length&&n>0){const u=t[0],c=n+1;l=Yd(i,u,c,r,e),h=Qd(s,u,c,a,e),d=Hd(o,u,c,e)}else for(let p=0;p<c;p++)l[p]=Jd(i,r,o,e,p,u),h[p]=$d(s,a,o,e,p,u),d[p]=Zd(o,p,u);return{begin:l,end:h,strides:d}}function Yd(e,t,n,r,a){const o=[...a],i=Kd(n,t);for(let s=0;s<o.length;s++)if(i.indexOf(s)>-1)o[s]=0;else{const a=qd(t,n,s);let i=r[a];e&1<<a&&(i=0),o[s]=i}return o}function Qd(e,t,n,r,a){const o=[...a],i=Kd(n,t);for(let s=0;s<o.length;s++)if(i.indexOf(s)>-1)o[s]=Number.MAX_SAFE_INTEGER;else{const a=qd(t,n,s);let i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),o[s]=i}for(let s=0;s<o.length;s++){const e=a[s];o[s]<0&&(o[s]+=e),o[s]=Lo(0,o[s],a[s])}return o}function Zd(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Jd(e,t,n,r,a,o){let i=t[a];const s=n[a]||1;(e&1<<a||o&1<<a||null==i)&&(i=s>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=r[a];return i<0&&(i+=u),i=Lo(0,i,u-1),i}function $d(e,t,n,r,a,o){let i=t[a];const s=n[a]||1;(e&1<<a||o&1<<a||null==i)&&(i=s>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[a];return i<0&&(i+=u),i=s>0?Lo(0,i,u):Lo(-1,i,u-1),i}function ep(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function tp(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function np(e,t,n){let r;const a=e.shape.length;let o;return r="number"===typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),r.forEach((e=>{Wo(-1!==e,(()=>"slice() does not support negative begin indexing."))})),o=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,o=o.map(((t,n)=>t>=0?t:(Wo(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-r[n]))),[r,o]}function rp(e,t,n,r,a,o,i,s,u){let c;if(null==r?(c=new Array(t.length),c.fill(1)):c=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let l=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:a,endMask:o,ellipsisMask:i,newAxisMask:s,shrinkAxisMask:u};for(let v=0;v<h.dims;v++)l&&0!==(1<<v&s)&&h.numAddAxisAfterEllipsis++,1<<v&i&&(l=!0);l||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Wd),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Ud),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let v=0;v<e.length;++v){if(0===d.strides[v])throw Error("strides[".concat(v,"] must be non-zero"));const t=!!(d.shrinkAxisMask&1<<v),n=e[v];if(-1===n){g.push(t?1:-1);continue}const r=[d.beginMask&1<<v,d.endMask&1<<v],a=[d.strides[v]>0?0:-1,d.strides[v]>0?n:n-1];if(t&&d.strides[v]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[v];const o=!!(d.beginMask&1<<v&&d.endMask&1<<v);if(d.beginValid&&d.endValid){if(t){const e=d.begin[v]<0?n+d.begin[v]:d.begin[v];if(d.begin[v]=e,d.end[v]=d.begin[v]+1,e<0||e>=n)throw Error("slice index ".concat(d.begin[v]," of dimension ").concat(v," out of bounds."))}else d.begin[v]=ap(d.begin[v],0,d.strides[v],n,r,a),d.end[v]=ap(d.end[v],1,d.strides[v],n,r,a);const e=1===d.strides[v]&&0===d.begin[v]&&d.end[v]===n;p=p&&e,f=f&&(0===v&&1===d.strides[v]||e)}else p=p&&1===d.strides[v]&&o,f=f&&(0===v&&1===d.strides[v]||o);let i,s=!1;if(d.beginValid&&d.endValid?(i=d.end[v]-d.begin[v],s=!0):t?(i=1,s=!0):o&&n>=0&&(i=d.strides[v]<0?-n:n,s=!0),s){let e;e=0===i||i<0!==d.strides[v]<0?0:Math.trunc(i/d.strides[v])+(i%d.strides[v]!==0?1:0),g.push(e)}else g.push(-1)}for(let v=0;v<d.finalShapeGatherIndices.length;++v){const e=d.finalShapeGatherIndices[v];e>=0?y.push(g[e]):e===Wd&&y.push(1)}const b=y.filter(((e,t)=>d.finalShapeGatherIndices[t]!==Wd));return{finalShapeSparse:b,finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function ap(e,t,n,r,a,o){if(a[t])return n>0?o[t]:o[t+1&1];{const t=e<0?r+e:e;return t<o[0]?o[0]:t>o[1]?o[1]:t}}const op=ah({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nh(e,"x","all","bool")},a={axis:t,keepDims:n};return Kl.runKernel(Ai,r,a)}});const ip=ah({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nh(e,"x","any","bool")},a={axis:t,keepDims:n};return Kl.runKernel(Fi,r,a)}});const sp=ah({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:nh(e,"x","argMax")},r={axis:t};return Kl.runKernel(_i,n,r)}});function up(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5?arguments[5]:void 0;return hp(e,[...t,e[3]],n,o,r,null,null,wp(a))}function cp(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[s,u]=fp(t);let c;if("channelsLast"===i)c=[s,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));c=[s,u,e[1],e[1]]}return hp(e,c,n,r,a,o,!1,i)}function lp(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[s,u,c]=mp(t);let l,h;if("NDHWC"===i)h="channelsLast",l=[s,u,c,e[4],e[4]];else{if("NCDHW"!==i)throw new Error("Unknown dataFormat ".concat(i));h="channelsFirst",l=[s,u,c,e[1],e[1]]}return dp(e,l,n,r,a,!1,h,o)}function hp(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[u,c,l,h]=[-1,-1,-1,-1];if("channelsLast"===s)[u,c,l,h]=e;else{if("channelsFirst"!==s)throw new Error("Unknown dataFormat ".concat(s));[u,h,c,l]=e}const[d,p,,f]=t,[m,g]=fp(n),[y,b]=fp(r),v=gp(d,y),x=gp(p,b),{padInfo:w,outHeight:k,outWidth:C}=function(e,t,n,r,a,o,i,s,u){let c,l,h;if("number"===typeof e){c={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,a){null==r&&(r=pp(e,t,n));const o=e[0],i=e[1],s=yp((o-t+2*r)/n+1,a),u=yp((i-t+2*r)/n+1,a);return[s,u]}([t,n],o,r,e,s);l=a[0],h=a[1]}else if("same"===e){l=Math.ceil(t/r),h=Math.ceil(n/a);const e=Math.max(0,(l-1)*r+o-t),s=Math.max(0,(h-1)*a+i-n),u=Math.floor(e/2),d=e-u,p=Math.floor(s/2);c={top:u,bottom:d,left:p,right:s-p,type:"SAME"}}else if("valid"===e)c={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((t-o+1)/r),h=Math.ceil((n-i+1)/a);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const d="channelsLast"===u?e[1][0]:e[2][0],p="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];c={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},l=yp((t-o+d+p)/r+1,s),h=yp((n-i+f+m)/a+1,s)}}return{padInfo:c,outHeight:l,outWidth:h}}(a,c,l,m,g,v,x,o,s),D=i?f*h:f;let S;return"channelsFirst"===s?S=[u,D,k,C]:"channelsLast"===s&&(S=[u,k,C,D]),{batchSize:u,dataFormat:s,inHeight:c,inWidth:l,inChannels:h,outHeight:k,outWidth:C,outChannels:D,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:S,filterShape:t}}function dp(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",s=arguments.length>7?arguments[7]:void 0,[u,c,l,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,c,l,h,d]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[u,d,c,l,h]=e}const[p,f,m,,g]=t,[y,b,v]=mp(n),[x,w,k]=mp(r),C=gp(p,x),D=gp(f,w),S=gp(m,k),{padInfo:E,outDepth:I,outHeight:N,outWidth:T}=function(e,t,n,r,a,o,i,s,u,c,l){let h,d,p,f;"valid"===e&&(e=0);if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,a,o){null==a&&(a=pp(e,t[0],r[0]));const i=[0,0,0,n];for(let s=0;s<3;s++)e[s]+2*a>=t[s]&&(i[s]=yp((e[s]-t[s]+2*a)/r[s]+1,o));return i}([t,n,r,1],[s,u,c],1,[a,o,i],e,l);d=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{d=Math.ceil(t/a),p=Math.ceil(n/o),f=Math.ceil(r/i);const e=(d-1)*a+s-t,l=(p-1)*o+u-n,m=(f-1)*i+c-r,g=Math.floor(e/2),y=e-g,b=Math.floor(l/2),v=l-b,x=Math.floor(m/2);h={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(a,c,l,h,y,b,v,C,D,S,s),A=o?g*d:g;let F;return"channelsFirst"===i?F=[u,A,I,N,T]:"channelsLast"===i&&(F=[u,I,N,T,A]),{batchSize:u,dataFormat:i,inDepth:c,inHeight:l,inWidth:h,inChannels:d,outDepth:I,outHeight:N,outWidth:T,outChannels:A,padInfo:E,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:C,effectiveFilterHeight:D,effectiveFilterWidth:S,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:F,filterShape:t}}function pp(e,t,n){const r=gp(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function fp(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function mp(e){return"number"===typeof e?[e,e,e]:e}function gp(e,t){return t<=1?e:e+(e-1)*(t-1)}function yp(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function bp(e){const[t,n,r]=fp(e);return 1===t&&1===n&&1===r}function vp(e,t){return bp(e)||bp(t)}function xp(e){return fp(e).every((e=>e>0))}function wp(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function kp(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)Wo(Ho(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{Wo(Ho(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const Cp=ah({reshape_:function(e,t){const n={x:nh(e,"x","reshape","string_or_numeric")},r={shape:t};return Kl.runKernel(zu,n,r)}});const Dp=ah({avgPool_:function(e,t,n,r,a){const o=nh(e,"x","avgPool","float32");Wo(vp(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let i=o,s=!1;3===o.rank&&(s=!0,i=Cp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Wo(4===i.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(i.rank,"."))),kp("avgPool",r,a);const u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a};let l=Kl.runKernel(Pi,u,c);return l=$h(l,o.dtype),s?Cp(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const Sp=ah({avgPool3d_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=nh(e,"x","avgPool3d","float32");let s=i,u=!1;4===i.rank&&(u=!0,s=Cp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Wo(5===s.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(s.rank,"."))),Wo("NDHWC"===o,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),Wo("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),kp("avgPool3d",r,a);const c={x:s},l={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:o};let h=Kl.runKernel(Ui,c,l);return h=$h(h,s.dtype),u?Cp(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Ep=ah({batchNorm_:function(e,t,n,r,a,o){null==o&&(o=.001);const i=nh(e,"x","batchNorm"),s=nh(t,"mean","batchNorm"),u=nh(n,"variance","batchNorm");let c,l;null!=a&&(c=nh(a,"scale","batchNorm")),null!=r&&(l=nh(r,"offset","batchNorm")),Wo(s.rank===u.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Wo(null==l||s.rank===l.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Wo(null==c||s.rank===c.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(e){let t;return t=0===e.rank||1===e.rank?Cp(e,[1,1,1,e.size]):2===e.rank?Cp(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Cp(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:c,offset:l,mean:s,variance:u},d={varianceEpsilon:o},p=Kl.runKernel(Os,h,d);return Cp(p,i.shape)}});const Ip=ah({batchNorm2d_:function(e,t,n,r,a,o){const i=nh(e,"x","batchNorm"),s=nh(t,"mean","batchNorm"),u=nh(n,"variance","batchNorm");let c,l;return null!=a&&(c=nh(a,"scale","batchNorm")),null!=r&&(l=nh(r,"offset","batchNorm")),Wo(2===i.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(i.rank,"."))),Wo(2===s.rank||1===s.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(s.rank,"."))),Wo(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),null!=c&&Wo(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Wo(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),Ep(i,s,u,l,c,o)}});const Np=ah({batchNorm3d_:function(e,t,n,r,a,o){const i=nh(e,"x","batchNorm"),s=nh(t,"mean","batchNorm"),u=nh(n,"variance","batchNorm");let c,l;return null!=a&&(c=nh(a,"scale","batchNorm")),null!=r&&(l=nh(r,"offset","batchNorm")),Wo(3===i.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(i.rank,"."))),Wo(3===s.rank||1===s.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(s.rank,"."))),Wo(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),null!=c&&Wo(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Wo(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),Ep(i,s,u,l,c,o)}});const Tp=ah({batchNorm4d_:function(e,t,n,r,a,o){const i=nh(e,"x","batchNorm"),s=nh(t,"mean","batchNorm"),u=nh(n,"variance","batchNorm");let c,l;return null!=a&&(c=nh(a,"scale","batchNorm")),null!=r&&(l=nh(r,"offset","batchNorm")),Wo(4===i.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(i.rank,"."))),Wo(4===s.rank||1===s.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(s.rank,"."))),Wo(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),null!=c&&Wo(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Wo(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),Ep(i,s,u,l,c,o)}});const Ap=ah({broadcastTo_:function(e,t){let n=nh(e,"broadcastTo","x");const r=n.shape;if(pi(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Cp(n,e)}const a=n.shape,o=Array.from(t);for(let c=t.length-1;c>=0;c--)if(a[c]===t[c])o[c]=1;else if(1!==n.shape[c])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(t,"]."));const i=o.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===i.length)return ed(n);const s={x:n},u={reps:o};return Kl.runKernel(kc,s,u)}});const Fp=ah({clipByValue_:function(e,t,n){const r=nh(e,"x","clipByValue");if(Wo(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return yd(r.shape,t,r.dtype);const a={x:r},o={clipValueMin:t,clipValueMax:n};return Kl.runKernel(Qi,a,o)}});const _p=ah({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Wo(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=rh(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return ed(n[0]);const r=n,a={axis:t};return Kl.runKernel($i,r,a)}});const Rp=ah({concat1d_:function(e){return _p(e,0)}});const Mp=ah({concat2d_:function(e,t){return _p(e,t)}});const Op=ah({concat3d_:function(e,t){return _p(e,t)}});const zp=ah({concat4d_:function(e,t){return _p(e,t)}});const Lp=ah({conv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const s=nh(e,"x","conv2d","float32"),u=nh(t,"filter","conv2d","float32");let c=s,l=!1;3===s.rank&&(l=!0,c=Cp(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Wo(4===c.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(c.rank,"."))),Wo(4===u.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(u.rank,"."))),kp("conv2d",r,i);const h="NHWC"===a?c.shape[3]:c.shape[1];Wo(h===u.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(u.shape[2],"."))),Wo(vp(n,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),Wo(xp(o),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Wo(xp(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:c,filter:u},p={strides:n,pad:r,dataFormat:a,dilations:o,dimRoundingMode:i},f=Kl.runKernel(es,d,p);return l?Cp(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Bp=ah({conv1d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const s=nh(e,"x","conv1d"),u=nh(t,"filter","conv1d");let c=s,l=!1;2===s.rank&&(l=!0,c=Cp(s,[1,s.shape[0],s.shape[1]])),Wo(3===c.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(c.rank,"."))),Wo(3===u.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(u.rank,"."))),kp("conv1d",r,i),Wo(c.shape[2]===u.shape[1],(()=>"Error in conv1d: depth of input (".concat(c.shape[2],") must match ")+"input depth for filter ".concat(u.shape[1],"."))),Wo(vp(n,o),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(o,"'"))),Wo(xp(o),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Wo(xp(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Wo("NWC"===a,(()=>"Error in conv1d: got dataFormat of ".concat(a," but only NWC is currently supported.")));const h=Cp(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=Cp(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=Lp(d,h,[1,n],r,"NHWC",[1,o],i);return Cp(p,l?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Pp=ah({conv2DBackpropInput_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;Wo(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let s=e,u=t,c=!1;3===t.rank&&(c=!0,u=Cp(t,[1,t.shape[0],t.shape[1],t.shape[2]]),s=[1,e[0],e[1],e[2]]),Wo(4===s.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(s.length,"."))),Wo(4===u.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(u.rank))),Wo(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const l="NHWC"===o?s[3]:s[1],h="NHWC"===o?u.shape[3]:u.shape[1];Wo(l===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(l,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),Wo(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),kp("conv2dDerInput",a,i);const d={dy:u,filter:n},p={strides:r,pad:a,dataFormat:o,dimRoundingMode:i,inputShape:s},f=Kl.runKernel(ns,d,p);return c?Cp(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Wp=ah({conv2dTranspose_:function(e,t,n,r,a,o){const i=nh(e,"x","conv2dTranspose"),s=nh(t,"filter","conv2dTranspose");return Pp(n,i,s,r,a,"NHWC",o)}});const Up=ah({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=nh(e,"x","conv3d"),s=nh(t,"filter","conv3d");let u=i,c=!1;4===i.rank&&(c=!0,u=Cp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Wo(5===u.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(u.rank,"."))),Wo(5===s.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(s.rank,"."))),Wo(u.shape[4]===s.shape[3],(()=>"Error in conv3d: depth of input (".concat(u.shape[4],") must match ")+"input depth for filter ".concat(s.shape[3],"."))),Wo(vp(n,o),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(o,"'"))),Wo("NDHWC"===a,(()=>"Error in conv3d: got dataFormat of ".concat(a," but only NDHWC is currently supported."))),Wo(xp(o),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Wo(xp(n),(()=>"Error in conv3D: Strides should be larger than 0."));const l={x:u,filter:s},h={strides:n,pad:r,dataFormat:a,dilations:o},d=Kl.runKernel(rs,l,h);return c?Cp(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Vp=ah({conv3DBackpropInput_:function(e,t,n,r,a){Wo(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let o=e,i=t,s=!1;4===t.rank&&(s=!0,i=Cp(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);const u=o[4],c=i.shape[4];Wo(5===o.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(o.length,"."))),Wo(5===i.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(i.rank))),Wo(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),Wo(u===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),Wo(c===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(c,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const l={dy:i,filter:n},h={pad:a,strides:r,inputShape:o},d=Kl.runKernel(os,l,h);return s?Cp(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Gp=ah({conv3dTranspose_:function(e,t,n,r,a){const o=nh(e,"x","conv3dTranspose"),i=nh(t,"filter","conv3dTranspose");return Vp(n,o,i,r,a)}});const jp=ah({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=nh(e,"x","denseBincount"),o=nh(t,"weights","denseBincount");Wo("int32"===a.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(a.dtype))),Wo(a.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(a.rank,"."))),Wo(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Wo(o.size===a.size||0===o.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(a.shape,", weights shape: ")+"".concat(o.shape,".")));const i={x:a,weights:o},s={size:n,binaryOutput:r};return Kl.runKernel(hs,i,s)}});const Hp=ah({depthwiseConv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const s=nh(e,"x","depthwiseConv2d","float32"),u=nh(t,"filter","depthwiseConv2d","float32");let c=s,l=!1;3===s.rank&&(l=!0,c=Cp(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Wo(4===c.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(c.rank,"."))),Wo(4===u.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(u.rank,".")));const h="NHWC"===a?c.shape[3]:c.shape[1];Wo(h===u.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(u.shape[2],"."))),kp("depthwiseConv2d",r,i);const d={x:c,filter:u},p={strides:n,pad:r,dataFormat:a,dilations:o,dimRoundingMode:i},f=Kl.runKernel(ps,d,p);return l?Cp(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const qp=ah({elu_:function(e){const t={x:nh(e,"x","elu","float32")};return Kl.runKernel(Cs,t)}});const Kp=ah({equal_:function(e,t){let n=nh(e,"a","equal","string_or_numeric"),r=nh(t,"b","equal","string_or_numeric");[n,r]=Pl(n,r),Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(Es,a)}});const Xp=ah({erf_:function(e){let t=nh(e,"x","erf");Wo("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=$h(t,"float32"));const n={x:t};return Kl.runKernel(Ss,n)}});const Yp=ah({exp_:function(e){const t={x:nh(e,"x","exp")};return Kl.runKernel(Is,t)}});const Qp=ah({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=nh(e,"x","expandDims","string_or_numeric");Wo(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:t};return Kl.runKernel(Ns,r,a)}});const Zp=ah({tile_:function(e,t){const n=nh(e,"x","tile","string_or_numeric");Wo(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const r={x:n},a={reps:t};return Kl.runKernel(kc,r,a)}});const Jp=ah({eye_:function(e,t,n){null==t&&(t=e);const r=Jh([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);const o=Cp(r.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return Zp(Qp(o,0),[n[0],1,1]);if(2===n.length)return Zp(Qp(Qp(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return Zp(Qp(Qp(Qp(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const $p=ah({floor_:function(e){const t={x:nh(e,"x","floor","float32")};return Kl.runKernel(Rs,t)}});const ef=ah({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:nh(e,"x","gather"),indices:nh(t,"indices","gather","int32")},o={axis:n,batchDims:r};return Kl.runKernel(zs,a,o)}});const tf=ah({greater_:function(e,t){let n=nh(e,"a","greater","string_or_numeric"),r=nh(t,"b","greater","string_or_numeric");[n,r]=Pl(n,r),Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(Bs,a)}});const nf=ah({greaterEqual_:function(e,t){let n=nh(e,"a","greaterEqual","string_or_numeric"),r=nh(t,"b","greaterEqual","string_or_numeric");[n,r]=Pl(n,r),Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(Ps,a)}});const rf=ah({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:nh(e,"x","leakyRelu")},r={alpha:t};return Kl.runKernel(qs,n,r)}});const af=ah({log_:function(e){const t={x:nh(e,"x","log","float32")};return Kl.runKernel(Qs,t)}});const of=ah({log1p_:function(e){const t={x:nh(e,"x","log1p")};return Kl.runKernel(Zs,t)}});const sf=ah({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nh(e,"x","max")},a={reductionIndices:t,keepDims:n};return Kl.runKernel(ru,r,a)}});const uf=ah({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=nh(e,"x","sum");"bool"===r.dtype&&(r=$h(r,"int32"));const a={x:r},o={axis:t,keepDims:n};return Kl.runKernel(rc,a,o)}});const cf=ah({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=nh(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const r=ud(((e,n)=>{const r=sf(e,t,!0),a=xd(e,r),o=xd($h(a,"float32"),af(uf(Yp(a),t,!0)));n([o]);return{value:o,gradFunc:(e,n)=>{const[r]=n,a=Yp(r);return xd(e,ad(uf(e,t,!0),a))}}}));return r(n)}});function lf(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function hf(e,t,n){const r=e.length+t.length,a=[];let o=0,i=0;for(let s=0;s<r;s++)-1===n.indexOf(s)?a.push(e[o++]):a.push(t[i++]);return a}function df(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function pf(e,t){return hf(e,t.map((e=>1)),t)}function ff(e,t,n){Wo(lf(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function mf(e,t){if(lf(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function gf(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function yf(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const bf=ah({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=nh(e,"x","logSumExp"),a=Qo(t,r.shape),o=sf(r,a,!0),i=xd(r,o),s=Yp(i),u=uf(s,a),c=af(u),l=td(Cp(o,c.shape),c);if(n){const e=pf(l.shape,a);return Cp(l,e)}return l}});const vf=ah({logicalAnd_:function(e,t){const n=nh(e,"a","logicalAnd","bool"),r=nh(t,"b","logicalAnd","bool");Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(Js,a)}});const xf=ah({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=nh(e,"a","matMul"),o=nh(t,"b","matMul");[a,o]=Pl(a,o);const i={a:a,b:o},s={transposeA:n,transposeB:r};return Kl.runKernel(Gi,i,s)}});const wf=ah({maxPool_:function(e,t,n,r,a){const o=nh(e,"x","maxPool");let i=o,s=!1;3===o.rank&&(s=!0,i=Cp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Wo(4===i.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(i.rank,"."))),Wo(vp(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),kp("maxPool",r,a);const u={x:i},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a},l=Kl.runKernel(ou,u,c);return s?Cp(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const kf=ah({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=nh(e,"x","maxPool3d");let s=i,u=!1;4===i.rank&&(u=!0,s=Cp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Wo(5===s.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(s.rank,"."))),Wo("NDHWC"===o,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(o))),kp("maxPool3d",r,a);const c={x:s},l={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:o},h=Kl.runKernel(su,c,l);return u?Cp(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Cf=ah({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nh(e,"x","mean")},a={axis:t,keepDims:n};return Kl.runKernel(lu,r,a)}});const Df=ah({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:nh(e,"x","min")},a={axis:t,keepDims:n};return Kl.runKernel(hu,r,a)}});const Sf=ah({minimum_:function(e,t){let n=nh(e,"a","minimum"),r=nh(t,"b","minimum");[n,r]=Pl(n,r),"bool"===n.dtype&&(n=$h(n,"int32"),r=$h(r,"int32")),Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(du,a)}});const Ef=ah({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Qo(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=nh(e,"x","moments")).shape),r=Cf(e,n,t);let a=r.shape;t||(a=pf(r.shape,n));const o=id(xd($h(e,"float32"),Cp(r,a)));return{mean:r,variance:Cf(o,n,t)}}});const If=ah({neg_:function(e){const t={x:nh(e,"x","neg")};return Kl.runKernel(yu,t)}});const Nf=ah({notEqual_:function(e,t){let n=nh(e,"a","notEqual","string_or_numeric"),r=nh(t,"b","notEqual","string_or_numeric");[n,r]=Pl(n,r),Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(bu,a)}});const Tf=ah({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const o={indices:nh(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return Kl.runKernel(Cu,o,i)}});function Af(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(pi(e),"complex64"===t){const t=Af(e,"float32"),n=Af(e,"float32");return oh(t,n)}const n=hi(Go(e),t);return Kl.makeTensor(n,e,t)}function Ff(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(pi(e),"complex64"===t){const t=Ff(e,"float32"),n=Af(e,"float32");return oh(t,n)}const n=li(Go(e),t);return Kl.makeTensor(n,e,t)}const _f=ah({onesLike_:function(e){const t={x:nh(e,"x","onesLike")};return Kl.runKernel(ku,t)}});const Rf=ah({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=nh(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:t,constantValue:n},o={x:r};return Kl.runKernel(Su,o,a)}});const Mf=ah({prelu_:function(e,t){const n={x:nh(e,"x","prelu"),alpha:nh(t,"alpha","prelu")};return Kl.runKernel(Iu,n)}});class Of{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=a||Math.random();this.random=$a.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,o;do{r=2*this.random()-1,a=2*this.random()-1,o=r*r+a*a}while(o>=1||0===o);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class zf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=$a.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Lf=ah({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(pi(e),null!=r&&"bool"===r)throw new Error("Unsupported data type ".concat(r));const o=new Of(t,n,r,!1,a),i=Jh(e,r);for(let s=0;s<i.values.length;s++)i.values[s]=o.nextValue();return i.toTensor()}});const Bf=ah({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;pi(e);const o=Jh(e,r),i=new zf(t,n,null,a);for(let s=0;s<o.values.length;s++)o.values[s]=i.nextValue();return o.toTensor()}});function Pf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:e,stop:t,step:n,dtype:r};return Kl.runKernel(_u,{},a)}const Wf=ah({relu_:function(e){const t={x:nh(e,"x","relu")};return Kl.runKernel(Ou,t)}});const Uf=ah({reverse_:function(e,t){const n={x:nh(e,"x","reverse")},r={dims:t};return Kl.runKernel(Vu,n,r)}});const Vf=ah({selu_:function(e){const t={x:nh(e,"x","selu")};return Kl.runKernel(Yu,t)}});const Gf=ah({separableConv2d_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const s=nh(e,"x","separableConv2d"),u=nh(t,"depthwiseFilter","separableConv2d"),c=nh(n,"pointwiseFilter","separableConv2d");let l=s,h=!1;if(3===s.rank&&(h=!0,l=Cp(s,[1,s.shape[0],s.shape[1],s.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Wo(4===l.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,"."))),Wo(4===u.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(u.rank,"."))),Wo(4===c.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(u.rank,"."))),Wo(1===c.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(c.shape[0],"."))),Wo(1===c.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(c.shape[1],".")));const d=u.shape[2],p=u.shape[3];Wo(c.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(c.shape[2],".")));const f=Hp(l,u,r,a,i,o),m=Lp(f,c,1,"valid",i);return h?Cp(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const jf=ah({sigmoid_:function(e){const t={x:nh(e,"x","sigmoid","float32")};return Kl.runKernel(ec,t)}});const Hf=ah({slice_:function(e,t,n){const r=nh(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},o={begin:t,size:n};return Kl.runKernel(Qu,a,o)}});const qf=ah({slice1d_:function(e,t,n){const r=nh(e,"x","slice1d");return Wo(1===r.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(r.rank," tensor"))),Hf(r,[t],[n])}});const Kf=ah({slice2d_:function(e,t,n){const r=nh(e,"x","slice2d");return Wo(2===r.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(r.rank," tensor"))),Hf(r,t,n)}});const Xf=ah({slice3d_:function(e,t,n){const r=nh(e,"x","slice3d");return Wo(3===r.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(r.rank," tensor"))),Hf(r,t,n)}});const Yf=ah({slice4d_:function(e,t,n){const r=nh(e,"x","slice4d");return Wo(4===r.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(r.rank," tensor"))),Hf(r,t,n)}});const Qf=ah({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=nh(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const r={logits:n},a={dim:t};return Kl.runKernel(ic,r,a)}});const Zf=ah({softplus_:function(e){const t={x:nh(e,"x","softplus")};return Kl.runKernel(tc,t)}});const Jf=ah({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:nh(e,"x","split")},a={numOrSizeSplits:t,axis:n};return Kl.runKernel(oc,r,a)}});const $f=ah({squeeze_:function(e,t){const n=nh(e,"x","squeeze","string_or_numeric");return Cp(n,Zo(n.shape,t).newShape)}});const em=ah({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=rh(e,"tensors","stack","string_or_numeric");Wo(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Wo(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:t};return Kl.runKernel(Du,r,a)}});const tm=ah({tanh_:function(e){const t={x:nh(e,"x","tanh","float32")};return Kl.runKernel(wc,t)}});function nm(e,t){Vo(e);const n=$l(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ih(e,null,n,t)}function rm(e,t,n){if(Vo(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=$l(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ih(e,t,r,n)}const am=ah({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(pi(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new Of(t,n,r,!0,a),i=Jh(e,r);for(let s=0;s<i.values.length;s++)i.values[s]=o.nextValue();return i.toTensor()}});const om=ah({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=nh(e,"x","unstack","string_or_numeric");Wo(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const r={value:n},a={axis:t};return Kl.runKernel(Ic,r,a)}});const im=ah({where_:function(e,t,n){const r=nh(t,"a","where"),a=nh(n,"b","where"),o=nh(e,"condition","where","bool"),i=Sd(Sd(o.shape,r.shape),a.shape),s={condition:Ap(o,i),t:Ap(r,i),e:Ap(a,i)};return Kl.runKernel(Xu,s)}});const sm=ah({imag_:function(e){const t={input:nh(e,"input","imag")};return Kl.runKernel(Vs,t)}});const um=ah({real_:function(e){const t={input:nh(e,"input","real")};return Kl.runKernel(Ru,t)}});const cm=ah({transpose_:function(e,t,n){const r=nh(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Wo(r.rank===t.length,(()=>"Error in transpose: rank of input ".concat(r.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{Wo(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(r.rank-1)+" but got ".concat(t)))})),r.rank<=1)return r.clone();const a={x:r},o={perm:t};return"complex64"===r.dtype?hh((()=>{let e=um(r),t=sm(r);return e=Kl.runKernel(Sc,{x:e},o),t=Kl.runKernel(Sc,{x:t},o),n&&(t=If(t)),oh(e,t)})):Kl.runKernel(Sc,a,o)}});const lm=ah({dropout_:function(e,t,n,r){const a=nh(e,"x","dropout");if(Wo("float32"===a.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(a.dtype," tensor instead."))),Wo(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof El?a.clone():a;const o=function(e,t){if(null==t)return e.shape.slice();if(jo(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,s=rd($p(td(Bf(o,0,1,"float32",r),i)),i);return ad(a,s)}});const hm=ah({fft_:function(e){Wo("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Kl.runKernel(As,t)}});const dm=ah({rfft_:function(e,t){Wo("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const r=e.size/n;let a;if(null!=t&&t<n){const r=e.shape.map((e=>0)),o=e.shape.map((e=>e));o[e.shape.length-1]=t,a=Hf(e,r,o),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,a=_p([e,Af(r)],e.shape.length-1),n=t}else a=e;const o=sd(a),i=Cp(oh(a,o),[r,n]),s=hm(i),u=Math.floor(n/2)+1,c=um(s),l=sm(s),h=Jf(c,[u,n-u],c.shape.length-1),d=Jf(l,[u,n-u],l.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=u,Cp(oh(h[0],d[0]),p)}});const pm=ah({ifft_:function(e){Wo("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return Kl.runKernel(Us,t)}});const fm=ah({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const a=Cp(e,[n,t]);r=pm(a)}else{const a=[n,2*(t-1)],o=Cp(um(e),[n,t]),i=Cp(sm(e),[n,t]),s=Uf(Hf(o,[0,1],[n,t-2]),1),u=ad(Uf(Hf(i,[0,1],[n,t-2]),1),cd(-1)),c=_p([o,s],1),l=_p([i,u],1),h=Cp(oh(c,l),[a[0],a[1]]);r=pm(h)}if(r=um(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Cp(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const mm=ah({conv2DBackpropFilter_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,s=e;3===e.rank&&(s=Cp(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Cp(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Wo(4===s.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(s.shape,"."))),Wo(4===u.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(u.shape,"."))),Wo(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const c="NHWC"===o?s.shape[3]:s.shape[1],l="NHWC"===o?u.shape[3]:u.shape[1];Wo(c===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(c,") must ")+"match input depth in filter (".concat(n[2],"."))),Wo(l===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(l,") must ")+"match output depth for filter (".concat(n[3],")."))),kp("conv2dDerFilter",a,i);const h={x:s,dy:u},d={strides:r,pad:a,dataFormat:o,dimRoundingMode:i,filterShape:n};return Kl.runKernel(ts,h,d)}});const gm=ah({relu6_:function(e){const t={x:nh(e,"x","relu6")};return Kl.runKernel(Uu,t)}});const ym=ah({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:nh(e,"x","step")},r={alpha:t};return Kl.runKernel(Ac,n,r)}});function bm(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return ad(e,ym(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function vm(e,t){let n=t;const r=Dd(e.shape,t.shape);return r.length>0&&(n=uf(n,r)),Cp(n,e.shape)}function xm(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Wf(e);if("elu"===t)return qp(e);if("relu6"===t)return gm(e);if("prelu"===t)return Mf(e,n);if("leakyrelu"===t)return rf(e,r);if("sigmoid"===t)return jf(e);throw new Error("Unknown fused activation ".concat(t,"."))}const wm=(e,t)=>!(e>0)||"linear"===t;const km=ah({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:o="NHWC",dilations:i=[1,1],dimRoundingMode:s,bias:u,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:h}=e;if(c=c||"linear",!1===wm(Kl.state.gradientDepth,c)){Wo("NHWC"===o,(()=>"Error in fused conv2d: got dataFormat of ".concat(o," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=Lp(t,n,r,a,o,i,s);return null!=u&&(e=td(e,u)),xm(e,c,l,h)}const d=nh(t,"x","conv2d","float32"),p=nh(n,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=Cp(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Wo(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),Wo(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),kp("fused conv2d",a,s);const g="NHWC"===o?f.shape[3]:f.shape[1];Wo(p.shape[2]===g,(()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),Wo(vp(r,i),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(r," and dilations '").concat(i,"'")));const y=hp(f.shape,p.shape,r,i,a,s);let b,v;if(null!=u&&(b=nh(u,"bias","fused conv2d"),[b]=Pl(b,d),"NHWC"===o?Sd(y.outShape,b.shape):(Wo(b.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(b.shape.length,"."))),Wo(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(b.shape,") is not ")+"compatible with the number of output channels "+"(".concat(y.outChannels,")"))))),null!=l){const e=l.shape;if(Wo(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)Wo(1===e[0]||e[0]===y.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(y.outChannels,").")));else if(3===e.length)try{Sd(e,y.outShape)}catch(C){const t="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(y.outShape,").");throw Error(t)}v=nh(l,"prelu weights","fused conv2d")}const x=(e,t)=>{Wo("NHWC"===o,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(o," but only NHWC is currently supported.")));const[n,s,u,l]=t,h=bm(e,u,c);Wo(bp(i),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(i,"'")));const d=[Pp(s.shape,h,n,r,a),mm(s,h,n.shape,r,a)];if(null!=l){const e=vm(l,h);d.push(e)}return d},w={x:f,filter:p,bias:b,preluActivationWeights:v},k={strides:r,pad:a,dataFormat:o,dilations:i,dimRoundingMode:s,activation:c,leakyreluAlpha:h};if(null==u){const e=ud(((e,t,n)=>{let r=Kl.runKernel(Mc,w,k);return n([t,e,r]),m&&(r=Cp(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p)}{const e=ud(((e,t,n,r)=>{let a=Kl.runKernel(Mc,w,k);return r([t,e,a,n]),m&&(a=Cp(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p,b)}}});const Cm=ah({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,s=e;3===e.rank&&(s=Cp(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Cp(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:s,dy:u},l={strides:r,pad:a,dimRoundingMode:i,dilations:o,filterShape:n};return Kl.runKernel(fs,c,l)}});const Dm=ah({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,s=t,u=!1;3===t.rank&&(u=!0,s=Cp(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:s,filter:n},l={strides:r,pad:a,dimRoundingMode:i,dilations:o,inputShape:e},h=Kl.runKernel(ms,c,l);return u?Cp(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const Sm=ah({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:o,activation:i="linear",preluActivationWeights:s,leakyreluAlpha:u=.2}=e;if(!1===wm(Kl.state.gradientDepth,i)){let e=xf(t,n,r,a);return null!=o&&(e=td(e,o)),xm(e,i,s,u)}let c=nh(t,"a","fused matMul"),l=nh(n,"b","fused matMul");[c,l]=Pl(c,l);const h=r?c.shape[c.rank-2]:c.shape[c.rank-1],d=a?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=a?l.shape[l.rank-2]:l.shape[l.rank-1],m=c.shape.slice(0,-2),g=l.shape.slice(0,-2),y=Go(m),b=Go(g);Wo(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(c.shape," and ")+"".concat(l.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const v=Sd(c.shape.slice(0,-2),l.shape.slice(0,-2)).concat([p,f]),x=Cp(c,r?[y,h,p]:[y,p,h]),w=Cp(l,a?[b,f,d]:[b,d,f]);let k,C;null!=o&&(k=nh(o,"bias","fused matMul"),[k]=Pl(k,c),Sd(v,k.shape)),null!=s&&(C=nh(s,"prelu weights","fused matMul"));const D=(e,t)=>{const[n,s,u,c]=t,l=bm(Cp(e,u.shape),u,i);let h,d;if(r||a?!r&&a?(h=xf(l,s,!1,!1),d=xf(l,n,!0,!1)):r&&!a?(h=xf(s,l,!1,!0),d=xf(n,l,!1,!1)):(h=xf(s,l,!0,!0),d=xf(l,n,!0,!0)):(h=xf(l,s,!1,!0),d=xf(n,l,!0,!1)),null!=o){return[h,d,vm(c,l)]}return[h,d]},S={a:x,b:w,bias:k,preluActivationWeights:C},E={transposeA:r,transposeB:a,activation:i,leakyreluAlpha:u};if(null==o){const e=ud(((e,t,n)=>{const r=Kl.runKernel(Rc,S,E);return n([e,t,r]),{value:Cp(r,v),gradFunc:D}}));return e(x,w)}{const e=ud(((e,t,n,r)=>{const a=Kl.runKernel(Rc,S,E);return r([e,t,a,n]),{value:Cp(a,v),gradFunc:D}}));return e(x,w,k)}}});const Em=ah({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=nh(e,"image","cropAndResize"),s=nh(t,"boxes","cropAndResize","float32"),u=nh(n,"boxInd","cropAndResize","int32"),c=s.shape[0];Wo(4===i.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(i.rank,"."))),Wo(2===s.rank&&4===s.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(c,",4] ")+"but had shape ".concat(s.shape,"."))),Wo(1===u.rank&&u.shape[0]===c,(()=>"Error in cropAndResize: boxInd must be have size [".concat(c,"] ")+"but had shape ".concat(s.shape,"."))),Wo(2===r.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(r.length,"."))),Wo(r[0]>=1&&r[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(r))),Wo("bilinear"===a||"nearest"===a,(()=>"method must be bilinear or nearest, but was ".concat(a)));const l={image:i,boxes:s,boxInd:u},h={method:a,extrapolationValue:o,cropSize:r};return Kl.runKernel(ls,l,h)}});const Im=ah({flipLeftRight_:function(e){const t=nh(e,"image","flipLeftRight","float32");Wo(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return Kl.runKernel(_s,n,{})}});const Nm=ah({grayscaleToRGB_:function(e){const t=nh(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Wo(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),Wo(1===r,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(r,".")));const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Zp(t,a)}});const Tm=ah({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(((e,t)=>nh(e,"tensors".concat(t),"einsum"))),o={equation:e};return Kl.runKernel(ks,a,o)}});const Am=ah({rgbToGrayscale_:function(e){const t=nh(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Wo(t.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),Wo(3===r,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(r,".")));const a=t.dtype,o=$h(t,"float32"),i=nm([.2989,.587,.114]);let s;switch(t.rank){case 2:s=Tm("ij,j->i",o,i);break;case 3:s=Tm("ijk,k->ij",o,i);break;case 4:s=Tm("ijkl,l->ijk",o,i);break;case 5:s=Tm("ijklm,m->ijkl",o,i);break;case 6:s=Tm("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return s=Qp(s,-1),$h(s,a)}});const Fm=ah({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=nh(e,"image","rotateWithOffset","float32");Wo(4===a.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(a.rank,".")));const o={image:a},i={radians:t,fillValue:n,center:r};return Kl.runKernel(_c,o,i)}});function _m(e,t,n,r,a,o){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=e.shape[0];return n=Math.min(n,i),Wo(0<=r&&r<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(r,"'"))),Wo(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),Wo(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),Wo(1===t.rank,(()=>"scores must be a 1D tensor")),Wo(t.shape[0]===i,(()=>"scores has incompatible shape with boxes. Expected ".concat(i,", ")+"but was ".concat(t.shape[0]))),Wo(0<=o&&o<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(o,"'"))),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:o}}const Rm=ah({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=nh(e,"boxes","nonMaxSuppression","float32"),i=nh(t,"scores","nonMaxSuppression","float32"),s=_m(o,i,n,r,a);n=s.maxOutputSize,r=s.iouThreshold,a=s.scoreThreshold;const u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Kl.runKernel(vu,{boxes:o,scores:i},u)}});function Mm(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,o=0,i=!1;for(;r<a;){o=r+(a-r>>>1);const s=n(t,e[o]);s>0?r=o+1:(a=o,i=!s)}return i?r:-r-1}(e,t,n||Om)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function Om(e,t){return e>t?1:e<t?-1:0}function zm(e,t,n,r,a){return Pm(e,t,n,r,a,0)}function Lm(e,t,n,r,a,o){return Pm(e,t,n,r,a,0,!1,o,!0)}function Bm(e,t,n,r,a,o){return Pm(e,t,n,r,a,o,!0)}function Pm(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]&&arguments[7],u=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const c=[];for(let g=0;g<t.length;g++)t[g]>a&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(Vm);const l=o>0?-.5/o:0,h=[],d=[];for(;h.length<n&&c.length>0;){const t=c.pop(),{score:n,boxIndex:o,suppressBeginIndex:i}=t;if(n<a)break;let s=!1;for(let u=h.length-1;u>=i;--u){const n=Wm(e,o,h[u]);if(n>=r){s=!0;break}if(t.score=t.score*Um(r,l,n),t.score<=a)break}t.suppressBeginIndex=h.length,s||(t.score===n?(h.push(o),d.push(t.score)):t.score>a&&Mm(c,t,Vm))}const p=h.length,f=n-p;s&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),u&&(m.validOutputs=p),m}function Wm(e,t,n){const r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),c=Math.min(a[0],a[2]),l=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),p=(s-o)*(u-i),f=(h-c)*(d-l);if(p<=0||f<=0)return 0;const m=Math.max(o,c),g=Math.max(i,l),y=Math.min(s,h),b=Math.min(u,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function Um(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function Vm(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const Gm=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const o=nh(e,"boxes","nonMaxSuppressionAsync"),i=nh(t,"scores","nonMaxSuppressionAsync"),s=_m(o,i,n,r,a);n=s.maxOutputSize,r=s.iouThreshold,a=s.scoreThreshold;const u=await Promise.all([o.data(),i.data()]),c=u[0],l=u[1],{selectedIndices:h}=zm(c,l,n,r,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),nm(h,"int32")};const jm=ah({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=nh(e,"boxes","nonMaxSuppression"),s=nh(t,"scores","nonMaxSuppression"),u=_m(i,s,n,r,a,o);n=u.maxOutputSize,r=u.iouThreshold,a=u.scoreThreshold,o=u.softNmsSigma;const c={boxes:i,scores:s},l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:o},h=Kl.runKernel(wu,c,l);return{selectedIndices:h[0],selectedScores:h[1]}}});const Hm=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=nh(e,"boxes","nonMaxSuppressionAsync"),s=nh(t,"scores","nonMaxSuppressionAsync"),u=_m(i,s,n,r,a,o);n=u.maxOutputSize,r=u.iouThreshold,a=u.scoreThreshold,o=u.softNmsSigma;const c=await Promise.all([i.data(),s.data()]),l=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=Bm(l,h,n,r,a,o);return i!==e&&i.dispose(),s!==t&&s.dispose(),{selectedIndices:nm(d,"int32"),selectedScores:nm(p)}};const qm=ah({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=nh(e,"boxes","nonMaxSuppression"),s=nh(t,"scores","nonMaxSuppression"),u=_m(i,s,n,r,a,null),c={boxes:i,scores:s},l={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:o},h=Kl.runKernel(xu,c,l);return{selectedIndices:h[0],validOutputs:h[1]}}});const Km=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=nh(e,"boxes","nonMaxSuppressionAsync"),s=nh(t,"scores","nonMaxSuppressionAsync"),u=_m(i,s,n,r,a,null),c=u.maxOutputSize,l=u.iouThreshold,h=u.scoreThreshold,[d,p]=await Promise.all([i.data(),s.data()]),{selectedIndices:f,validOutputs:m}=Lm(d,p,c,l,h,o);return i!==e&&i.dispose(),s!==t&&s.dispose(),{selectedIndices:nm(f,"int32"),validOutputs:cd(m,"int32")}};const Xm=ah({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=nh(e,"images","resizeBilinear");Wo(3===a.rank||4===a.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Wo(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),Wo(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let o=a,i=!1;3===a.rank&&(i=!0,o=Cp(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,s={images:o},u={alignCorners:n,halfPixelCenters:r,size:t},c=Kl.runKernel(Pu,s,u);return i?Cp(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Ym=ah({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=nh(e,"images","resizeNearestNeighbor");Wo(3===a.rank||4===a.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(a.rank,"."))),Wo(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),Wo("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Wo(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let o=a,i=!1;3===a.rank&&(i=!0,o=Cp(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,s={images:o},u={alignCorners:n,halfPixelCenters:r,size:t},c=Kl.runKernel(Lu,s,u);return i?Cp(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Qm=ah({bincount_:function(e,t,n){const r=nh(e,"x","bincount"),a=nh(t,"weights","bincount");Wo("int32"===r.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(r.dtype))),Wo(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Wo(a.size===r.size||0===a.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(r.shape,", weights shape: ")+"".concat(a.shape,".")));const o={x:r,weights:a},i={size:n};return Kl.runKernel(Hi,o,i)}});const Zm=ah({lessEqual_:function(e,t){let n=nh(e,"a","lessEqual","string_or_numeric"),r=nh(t,"b","lessEqual","string_or_numeric");[n,r]=Pl(n,r),Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(Xs,a)}});const Jm=ah({round_:function(e){const t={x:nh(e,"x","round")};return Kl.runKernel(Gu,t)}});const $m=ah({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=nh(e,"image","threshold"),o=a.shape[0]*a.shape[1];let i,s,u,c,l=ad(nm([r]),255);if(Wo(3===a.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(a.rank,"."))),Wo(3===a.shape[2]||1===a.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(a.shape[2],"."))),Wo("int32"===a.dtype||"float32"===a.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(a.dtype,"."))),Wo("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===a.shape[2]){[i,s,u]=Jf(a,[1,1,1],-1);const e=ad(i,.2989),t=ad(s,.587),n=ad(u,.114);c=td(td(e,t),n)}else c=e;if("otsu"===t){l=function(e,t){let n,r,a,o,i,s,u=nm([-1]),c=nm([0]),l=nm([0]);for(let h=0;h<e.size-1;h++){n=Hf(e,0,h+1),r=Hf(e,h+1),i=rd(uf(n),t),s=rd(uf(r),t);const d=uf(ad(n,Pf(0,n.size)));a=rd(d,uf(n));const p=yd(r.shape,n.size),f=td(Pf(0,r.size),p),m=ad(r,f);o=rd(uf(m),uf(r));const g=xd(a,o),y=xd(a,o),b=ad(i,s);l=ad(ad(b,g),y);const v=tf(l,c);c=im(v,l,c),u=im(v,nm([h]),u)}return u}(Qm($h(Jm(c),"int32"),sh([]),256),o)}const h=n?Zm(c,l):tf(c,l);return $h(ad(h,255),"int32")}});const eg=ah({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5?arguments[5]:void 0;const i=nh(e,"image","transform","float32"),s=nh(t,"transforms","transform","float32");Wo(4===i.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(i.rank,"."))),Wo(2===s.rank&&(s.shape[0]===i.shape[0]||1===s.shape[0])&&8===s.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Wo(null==o||2===o.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(o,".")));const u={image:i,transforms:s},c={interpolation:n,fillMode:r,fillValue:a,outputShape:o};return Kl.runKernel(Dc,u,c)}});const tg=ah({less_:function(e,t){let n=nh(e,"a","less","string_or_numeric"),r=nh(t,"b","less","string_or_numeric");[n,r]=Pl(n,r),Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(Ks,a)}});const ng=ah({bandPart_:function(e,t,n){const r=nh(e,"a","bandPart");Wo(r.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(r.rank,".")));const a=r.shape,[o,i]=r.shape.slice(-2);let s,u;"number"===typeof t?(Wo(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),Wo(t<=o,(()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(o,")."))),s=nh(t<0?o:t,"numLower","bandPart")):(Wo("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),s=im(tg(t,0),o,Sf(t,o))),"number"===typeof n?(Wo(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),Wo(n<=i,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(i,")."))),u=nh(n<0?i:n,"numUpper","bandPart")):(Wo("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),u=im(tg(n,0),i,Sf(n,i)));const c=Cp(Pf(0,o,1,"int32"),[-1,1]),l=Pf(0,i,1,"int32"),h=xd(c,l),d=vf(Zm(h,s),nf(h,If(u))),p=Af([o,i],r.dtype);return Cp(em(om(Cp(r,[-1,o,i])).map((e=>im(d,e,p)))),a)}});function rg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return kd(e);if(1!==e.rank&&null===n)return rg(Cp(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return uf(kd(e),n);if(t===1/0)return sf(kd(e),n);if(t===-1/0)return Df(kd(e),n);if("euclidean"===t||2===t)return od(uf(vd(kd(e),cd(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return sf(uf(kd(e),n[0]),n[1]-1);if(t===1/0)return sf(uf(kd(e),n[1]),n[0]);if(t===-1/0)return Df(uf(kd(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return od(uf(id(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const ag=ah({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=rg(e=nh(e,"x","norm"),t,n);let o=a.shape;if(r){const t=Qo(n,e.shape);o=pf(a.shape,t)}return Cp(a,o)}});const og=ah({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Wo(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Wo(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=Jf(e,e.shape[0],0).map((e=>$f(e,[0])));Wo(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],r=e;for(let a=0;a<e.length;++a)n.push(Kl.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){const r=ad(uf(ad(n[t],e)),n[t]);e=xd(e,r)}return rd(e,ag(e,"euclidean"))})));return t?em(n,0):n}});function ig(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Kl.tidy((()=>{Wo(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],r=e.shape[1];let a=Jp(n),o=ed(e);const i=rm([[1]],[1,1]);let s=ed(i);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=o,u=s,c=a;[s,o,a]=Kl.tidy((()=>{const t=Hf(o,[e,e],[n-e,1]),u=ag(t),c=Hf(o,[e,e],[1,1]),l=im(tf(c,0),rm([[-1]]),rm([[1]])),h=xd(c,ad(l,u)),d=rd(t,h);s=1===d.shape[0]?ed(i):_p([i,Hf(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=If(rd(xf(l,h),u)),f=Hf(o,[e,0],[n-e,r]),m=ad(p,s),g=cm(s);if(0===e)o=xd(f,xf(m,xf(g,f)));else{const t=xd(f,xf(m,xf(g,f)));o=_p([Hf(o,[0,0],[e,r]),t],0)}const y=cm(m),b=Hf(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=xd(b,xf(xf(b,s),y));else{const t=xd(b,xf(xf(b,s),y));a=_p([Hf(a,[0,0],[n,e]),t],1)}return[s,o,a]})),dh([t,u,c])}return!t&&n>r&&(a=Hf(a,[0,0],[n,r]),o=Hf(o,[0,0],[r,r])),[a,o]}))}const sg=ah({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Wo(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return ig(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=om(Cp(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],o=[];r.forEach((e=>{const[n,r]=ig(e,t);a.push(n),o.push(r)}));return[Cp(em(a,0),e.shape),Cp(em(o,0),e.shape)]}}});var ug;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ug||(ug={}));const cg=ah({squaredDifference_:function(e,t){let n=nh(e,"a","squaredDifference"),r=nh(t,"b","squaredDifference");[n,r]=Pl(n,r),Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(dc,a,{})}});const lg={flipLeftRight:Im,grayscaleToRGB:Nm,resizeNearestNeighbor:Ym,resizeBilinear:Xm,rgbToGrayscale:Am,rotateWithOffset:Fm,cropAndResize:Em,nonMaxSuppression:Rm,nonMaxSuppressionAsync:Gm,nonMaxSuppressionWithScore:jm,nonMaxSuppressionWithScoreAsync:Hm,nonMaxSuppressionPadded:qm,nonMaxSuppressionPaddedAsync:Km,threshold:$m,transform:eg},hg={bandPart:ng,gramSchmidt:og,qr:sg};const dg=class{static sgd(e){return new Nd(e)}static momentum(e,t){return new Td(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Ad(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new wd(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new gd(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Id(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new bd(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},pg="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function fg(){return new Promise((e=>pg((()=>e()))))}function mg(e,t){const n=e[0].length;e.forEach(((e,t)=>{Wo(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),Wo(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const r=e[0];e.forEach(((e,a)=>{for(let o=0;o<n;o++)Wo(o===t||e[o]===r[o],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(a,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(r,") ")+"along the non-concatenated axis ".concat(a,".")))}))}function gg(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var yg;function bg(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(r.length));for(let a=1;a<n.length;++a){const o=n[a],i=r[r.length-n.length+a],s=r[i];if(o>=0)if(s>=0){if(s!==o)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(a+e,"] = ").concat(o," but shape[").concat(a+e,"] = ").concat(s))}else r[i]=o}return r}function vg(e){const t={FIRST_DIM_SIZE:yg.FIRST_DIM_SIZE,VALUE_ROWIDS:yg.VALUE_ROWIDS,ROW_LENGTHS:yg.ROW_LENGTHS,ROW_SPLITS:yg.ROW_SPLITS,ROW_LIMITS:yg.ROW_LIMITS,ROW_STARTS:yg.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function xg(e){return 0===e.length?0:e[0]===yg.FIRST_DIM_SIZE?e.length-1:e.length}function wg(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(r,")"));for(let a=0;a<Math.min(n,r-1);++a){const n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(a-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(a-e.length,"] = ").concat(r))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(yg||(yg={}));const kg=30;function Cg(e){return e<=kg?e:ii(e,Math.floor(Math.sqrt(e)))}function Dg(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function Sg(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function Eg(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function Ig(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let o=1;o<e.length;++o)o<=t.length?r?a.push(t[o-1]*e[o]):a.push(e[o]/t[o-1]):a.push(e[o]);return a}function Ng(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Tg(e,t,n){const r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}function Ag(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(r<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(r,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[r-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[r-1]," vs. ").concat(n));if(0===Go(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const a=t.shape,o=a[a.length-1];let i=1;for(let h=0;h<a.length-1;++h)i*=a[h];const s=e.shape,u=a.slice();u.pop();let c=1;for(let h=o;h<n;++h)c*=s[h],u.push(s[h]);const l=[...si(e.shape).map((e=>e/c)),1].slice(0,o);return[u,i,c,l]}function Fg(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,o="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(r,", and batchDim: ").concat(a,".");if(n.rank<a)throw new Error(o+" update.rank < ".concat(a,". "));if(e.length<r+(n.rank-a))throw new Error(o+" Output shape length < ".concat(r+(n.rank-a)));if(n.rank!==a+e.length-r)throw new Error(o+" update.rank != ".concat(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(o+" updates.shape[".concat(i,"] (").concat(n.shape[i],") != indices.shape[").concat(i,"] (").concat(t.shape[i],")."));for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(o+" updates.shape[".concat(i+a,"] (").concat(n.shape[i+a],") != shape[").concat(i+a,"] (").concat(e[i+a],")"))}function _g(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}Fg(n,t,e)}function Rg(e,t,n){const r=t.shape.length,a=r>1?t.shape[r-1]:1,o=n.length;let i=1;for(let u=a;u<o;++u)i*=n[u];const s=a<1?1:a;return{sliceRank:a,numUpdates:Go(t.shape)/s,sliceSize:i,strides:[...si(n.slice(0,a)),1],outputSize:Go(n)}}const Mg=1.7580993408473768,Og=1.0507009873554805,zg=.3275911,Lg=.254829592,Bg=-.284496736,Pg=1.421413741,Wg=-1.453152027,Ug=1.061405429;function Vg(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Gg(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function jg(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Hg(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function qg(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Kg(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Xg(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){const o=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(o),r[a]=Math.sin(o)}return{real:n,imag:r}}function Yg(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Qg="->",Zg=/->/g,Jg=",",$g="...";function ey(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Zg,"").length)/Qg.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(Qg,'").'));const[r,a]=e.split(Qg);Wo(-1===r.indexOf($g),(()=>'The ellipsis notation ("'.concat($g,'") is not supported yet.')));const o=r.split(Jg),i=o.length;if(t!==i)throw new Error("Expected ".concat(i," input tensors, received ").concat(t));if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const s=[];for(let h=0;h<a.length;++h){const e=a[h];if(!o.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===s.indexOf(e)&&s.push(e)}for(let h=0;h<r.length;++h){const e=r[h];-1===s.indexOf(e)&&e!==Jg&&s.push(e)}const u=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error("Found duplicate axes in input component ".concat(o[h],". ")+"Support for duplicate axes in input is not implemented yet.");u[h]=[];for(let e=0;e<o[h].length;++e)u[h].push(s.indexOf(o[h][e]))}const c=s.length,l=[];for(let h=a.length;h<c;++h)l.push(h);return{allDims:s,summedDims:l,idDims:u}}function ty(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;const r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function ny(e,t,n){const r=new Array(e);for(let a=0;a<n.length;++a){const e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:Wo(r[t[a][n]]===e[n],(()=>"Expected dimension ".concat(r[t[a][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function ry(e,t){const n=e,r=[];let a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);const o=[];for(let i=0;i<n.length;++i){const e=oy(t,n[i]);for(const t of e)-1===o.indexOf(t)&&(r[i].push(t),o.push(t))}return{path:n,steps:r}}function ay(e){return e.every(((e,t)=>e===t))}function oy(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function iy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)Wo(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Wo(a<=1,(()=>"There should be only one negative value in split array."));const o=t.indexOf(-1);if(-1!==o){const r=t.reduce(((e,t)=>t>0?e+t:e));t[o]=e.shape[n]-r}Wo(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function sy(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function uy(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function cy(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function ly(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function hy(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function dy(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function py(e,t){const n=Go(e),r=Go(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(r,". inputShape=").concat(e," outputShape= ").concat(t)}function fy(e,t){const n=Go(e),r=Go(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(r,". inputShape=").concat(e," outputShape=").concat(t)}function my(){return"segment ids must be >= 0"}function gy(){return"segment ids are not increasing"}function yy(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function by(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function vy(e,t){let n,r=!1;for(e<=kg?(n=e,r=!0):n=ii(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=ii(e,n+1);return n}function xy(e,t,n){const r=[],a=e.length;for(let o=0;o<a;o++)o!==t?r.push(e[o]):r.push(n);return r}function wy(e,t,n,r){const a=t.shape.length,o=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error("Expect batchDims in the range of [-".concat(a,", ").concat(a,"], but got ").concat(r));if(r<0&&(r+=a),r>o)throw new Error("batchDims (".concat(r,") must be less than rank(x) (\n    ").concat(o,")."));if(n<r)throw new Error("batchDims (".concat(r,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(e.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(t.shape[h],"."));const i=e.shape[n],s=[];let u=1,c=1,l=1;for(let h=0;h<r;++h)s.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<n;h++)s.push(e.shape[h]),c*=e.shape[h];for(let h=r;h<a;h++)s.push(t.shape[h]);for(let h=n+1;h<o;h++)s.push(e.shape[h]),l*=e.shape[h];return{batchSize:u,sliceSize:l,outerSize:c,dimSize:i,outputShape:s}}function ky(e){try{return e.map((e=>hl(e)))}catch($V){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat($V))}}function Cy(e){return e.map((e=>ll(e)))}function Dy(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const r=Jh(e,"int32"),a=Jh([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const t=r.indexToLoc(n[o]),i=o*e.length;a.values.set(t,i)}return a.toTensor()}!function(){for(const e of Fd)fd(e)}();const Sy={kernelName:Si,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(e,ym($h(n,"float32"),-1))}}},Ey={kernelName:Ei,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=id($h(n,"float32")),r=od(xd(cd(1),t));return If(rd(e,r))}}}},Iy={kernelName:Ii,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=od(xd(id($h(n,"float32")),1));return rd(e,t)}}}},Ny={kernelName:Ni,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Sd(n.shape,r.shape);return{a:()=>{let t=e;const r=Dd(n.shape,a);return r.length>0&&(t=uf(t,r)),Cp(t,n.shape)},b:()=>{let t=e;const n=Dd(r.shape,a);return n.length>0&&(t=uf(t,n)),Cp(t,r.shape)}}}},Ty={kernelName:Ti,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},Ay={kernelName:_i,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sd(n)}}},Fy={kernelName:Ri,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>sd(n)}}},_y={kernelName:Mi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rd(e,od(xd(cd(1),id($h(n,"float32")))))}}},Ry={kernelName:Oi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=od(td(cd(1),id($h(n,"float32"))));return rd(e,t)}}}},My={kernelName:Bi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Sd(n.shape,r.shape);return{a:()=>{const t=td(id(n),id(r));let o=ad(e,rd(r,t));const i=Dd(n.shape,a);return i.length>0&&(o=uf(o,i)),Cp(o,n.shape)},b:()=>{const t=td(id(n),id(r));let o=If(ad(e,rd(n,t)));const i=Dd(r.shape,a);return i.length>0&&(o=uf(o,i)),Cp(o,r.shape)}}}},Oy={kernelName:zi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rd(e,td(id($h(n,"float32")),1))}}},zy={kernelName:Li,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rd(e,xd(cd(1),id($h(n,"float32"))))}}};const Ly=ah({avgPool3dGrad_:function(e,t,n,r,a,o){const i=nh(e,"dy","avgPool3dGrad"),s=nh(t,"input","avgPool3dGrad");let u=i,c=s,l=!1;4===s.rank&&(l=!0,u=Cp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),c=Cp(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),Wo(5===u.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),Wo(5===c.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(c.rank,"."))),kp("avgPool3dGrad",a,o);const h={dy:u,input:c},d={filterSize:n,strides:r,pad:a,dimRoundingMode:o},p=Kl.runKernel(Vi,h,d);return l?Cp(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),By={kernelName:Ui,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:s}=n;return{x:()=>Ly(e,r,a,o,i,s)}}};const Py=ah({avgPoolGrad_:function(e,t,n,r,a){const o=nh(e,"dy","avgPoolGrad"),i=nh(t,"input","avgPoolGrad");Wo(i.rank===o.rank,(()=>"Rank of input (".concat(i.rank,") does not match rank of dy (").concat(o.rank,")")));let s=i,u=o,c=!1;3===i.rank&&(c=!0,s=Cp(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=Cp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Wo(4===u.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(u.rank,"."))),Wo(4===s.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(s.rank,".")));const l={dy:u,input:s},h={filterSize:n,strides:r,pad:a},d=Kl.runKernel(Wi,l,h);return c?Cp(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Wy={kernelName:Pi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:o,pad:i}=n;return{x:()=>Py(e,r,a,o,i)}}},Uy={kernelName:Gi,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,a]=t,{transposeA:o,transposeB:i}=n;return o||i?!o&&i?{a:()=>xf(e,a,!1,!1),b:()=>xf(e,r,!0,!1)}:o&&!i?{a:()=>xf(a,e,!1,!0),b:()=>xf(r,e,!1,!1)}:{a:()=>xf(a,e,!0,!0),b:()=>xf(e,r,!0,!0)}:{a:()=>xf(e,a,!1,!0),b:()=>xf(r,e,!0,!1)}}};const Vy=ah({spaceToBatchND_:function(e,t,n){const r=nh(e,"x","spaceToBatchND");Wo(r.rank>=1+t.length,(()=>"input rank ".concat(r.rank," should be > than [blockShape] ").concat(t.length))),Wo(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),Wo(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>"input spatial dimensions ".concat(r.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const a={x:r},o={blockShape:t,paddings:n};return Kl.runKernel(ac,a,o)}}),Gy={kernelName:ji,gradFunc:(e,t,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>Vy(e,r,a)}}},jy={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,a=r.inputShape,o=r.shape,i=Array.from(o);for(let u=a.length-1;u>=0;u--)if(a[u]===o[u])i[u]=1;else if(1!==a[u])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(o,"]."));const s=[];for(let u=0;u<i.length;u++)i[u]>1&&s.push(u);return{x:()=>uf(e,s,!0)}}},Hy={kernelName:Xi,gradFunc:e=>({x:()=>e.clone()})},qy={kernelName:Yi,gradFunc:e=>({x:()=>sd(e)})},Ky={kernelName:Qi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:a,clipValueMax:o}=n;return{x:()=>im(vf(nf(r,a),Zm(r,o)),e,sd(e))}}},Xy={kernelName:Ji,inputsToSave:["x"],gradFunc:Sy.gradFunc},Yy={kernelName:$i,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:a}=n,o=Qo(a,t[0].shape)[0],i=r.map((e=>e[o]));return Jf(e,i,o).map((e=>()=>e))}},Qy={kernelName:es,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{dilations:o,strides:i,pad:s,dataFormat:u}=n;return Wo(bp(o),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'"))),{x:()=>Pp(r.shape,e,a,i,s,u),filter:()=>mm(r,e,a.shape,i,s,u)}}},Zy={kernelName:ns,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{strides:o,pad:i,dataFormat:s,dimRoundingMode:u}=n;return{dy:()=>Lp(e,a,o,i,s,1,u),filter:()=>mm(e,r,a.shape,o,i,s,u)}}};const Jy=ah({conv3DBackpropFilter_:function(e,t,n,r,a){let o=e;4===e.rank&&(o=Cp(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Cp(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Wo(5===o.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(o.shape,"."))),Wo(5===i.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(i.shape,"."))),Wo(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),Wo(o.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(o.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),Wo(i.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(i.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const s={x:o,dy:i},u={strides:r,pad:a,filterShape:n};return Kl.runKernel(as,s,u)}}),$y={kernelName:rs,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:o}=n;Wo(bp(r),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(r,"'")));const[i,s]=t;return{x:()=>Vp(i.shape,e,s,a,o),filter:()=>Jy(i,e,s.shape,a,o)}}};const eb=ah({sin_:function(e){const t={x:nh(e,"x","sin","float32")};return Kl.runKernel(Zu,t)}}),tb={kernelName:is,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(If(eb($h(n,"float32"))),e)}}};const nb=ah({sinh_:function(e){const t={x:nh(e,"x","sinh")};return Kl.runKernel(Ju,t)}}),rb={kernelName:ss,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(nb($h(n,"float32")),e)}}};const ab=ah({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:nh(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:r};return Kl.runKernel(cs,a,o)}}),ob={kernelName:cs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a,exclusive:o,reverse:i}=n;return{x:()=>{const t=mf([a],r.rank);let n=ab(e,a,o,!i);return null!=t&&(n=cm(n,t)),n}}}},ib={kernelName:ps,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:o,dimRoundingMode:i}=n,s=null==r?[1,1]:r;Wo(bp(s),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(s,"'")));const[u,c]=t;return Wo(4===u.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(u.rank,"."))),Wo(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(c.rank,"."))),Wo(u.shape[3]===c.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(u.shape[3],") must match the inChannels dimension ")+"in filter ".concat(c.shape[2],"."))),Wo(vp(a,s),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(a," and dilations ")+"'".concat(s,"'."))),kp("depthwiseConv2d",o,i),{x:()=>Dm(u.shape,e,c,a,o,s,i),filter:()=>Cm(u,e,c.shape,a,o,s,i)}}},sb={kernelName:ys,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,o={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>Kl.runKernel(bs,o,n),filter:()=>Kl.runKernel(vs,i,n)}}},ub={kernelName:Cs,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Kl.runKernel(Ds,r)}}},cb={kernelName:Ss,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=ad(Yp(If(id(n))),2/Math.sqrt(Math.PI));return{x:()=>ad(e,r)}}},lb={kernelName:Is,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(e,n)}}},hb={kernelName:Ns,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Cp(e,n.shape)}}},db={kernelName:Ts,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(e,Yp(n))}}},pb={kernelName:Rs,gradFunc:e=>({x:()=>sd(e)})},fb={kernelName:Ms,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Sd(n.shape,r.shape);return{a:()=>{const t=rd(e,$h(r,"float32")),o=Dd(n.shape,a);return o.length>0?Cp(uf(t,o),n.shape):t},b:()=>{let t=ad(e,$h(n,"float32"));const o=Dd(r.shape,a);o.length>0&&(t=Cp(uf(t,o),r.shape));const i=id(r);return If(rd(t,$h(i,"float32")))}}}};const mb=ah({rsqrt_:function(e){const t={x:nh(e,"x","rsqrt","float32")};return Kl.runKernel(ju,t)}}),gb={kernelName:Os,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[a,o,i,s]=t,u=null==s?cd(1):s,c=Dd(o.shape,a.shape),l=[];if(1===o.rank){for(let e=0;e<a.shape.length-1;++e)l.push(a.shape[e]);l.push(1)}const h=xd(a,o),d=ad(e,u),p=mb(td(i,cd(r))),f=ad(ad(ad(p,p),p),cd(-.5));return{x:()=>1===o.rank?Cp(ad(ad(e,Zp(Cp(p,[1,1,1,o.shape[0]]),l)),u),a.shape):Cp(ad(ad(e,p),u),a.shape),mean:()=>{let e=ad(ad(p,cd(-1)),d);return 1===o.rank&&(e=uf(e,c)),Cp(e,o.shape)},variance:()=>{let e=ad(ad(f,h),d);return 1===o.rank&&(e=uf(e,c)),Cp(e,o.shape)},scale:()=>{const t=ad(h,p);let n=ad(e,t);return 1===o.rank&&(n=uf(n,c)),Cp(n,o.shape)},offset:()=>{let t=e;return 1===o.rank&&(t=uf(t,c)),Cp(t,o.shape)}}}};const yb=ah({unsortedSegmentSum_:function(e,t,n){const r=nh(e,"x","unsortedSegmentSum"),a=nh(t,"segmentIds","unsortedSegmentSum","int32");Wo(Ho(n),(()=>"numSegments must be of dtype int"));const o={x:r,segmentIds:a},i={numSegments:n};return Kl.runKernel(Nc,o,i)}}),bb={kernelName:zs,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,a]=t,{axis:o,batchDims:i}=n,s=Qo(o,r.shape)[0],u=(e,t,n)=>()=>{const r=e.shape,a=t.size,i=r.slice(0,s),u=i.length,c=r.slice(o,r.length).slice(1),l=c.length,h=vb(0,u),d=vb(u+1,u+1+l),p=xb([i,[a],c]),f=Cp(n,p),m=Cp(t,[a]),g=xb([[u],h,d]),y=cm(f,g);let b=yb(y,m,e.shape[s]);const v=gf(g);return b=cm(b,v),b};if(1===i){const t=r.shape[0],n=r.split(t,0),o=()=>{const t=em(n.map(((t,n)=>u(t,a.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)};return{x:o,indices:()=>a}}return{x:u(r,a,e),indices:()=>a}}};function vb(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function xb(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const wb={kernelName:Ps,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>sd(n),b:()=>sd(r)}}},kb={kernelName:Ws,gradFunc:e=>({x:()=>$h(e,"float32")})},Cb={kernelName:Gs,gradFunc:e=>({x:()=>sd(e)})},Db={kernelName:js,gradFunc:e=>({x:()=>sd(e)})},Sb={kernelName:Hs,gradFunc:e=>({x:()=>sd(e)})},Eb={kernelName:qs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:a}=n,o=tf(r,0);return{x:()=>im(o,e,ad(e,a))}}},Ib={kernelName:Zs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rd(e,td(n,1))}}},Nb={kernelName:Qs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rd(e,$h(n,"float32"))}}},Tb={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;return{logits:()=>{const t=Yp(r);return xd(e,ad(uf(e,a,!0),t))}}}};const Ab=ah({localResponseNormalizationBackprop_:function(e,t,n){const r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Kl.runKernel(nu,r,a)}}),Fb={kernelName:tu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{depthRadius:o,bias:i,alpha:s,beta:u}=n;return{x:()=>Ab(r,a,e,o,i,s,u)}}};function _b(e,t,n,r){return t.rank<n.rank&&(t=Cp(t,pf(t.shape,r))),e.rank<n.rank&&(e=Cp(e,pf(e.shape,r))),{x:()=>ad(e,$h(Kp(n,t),e.dtype))}}const Rb={kernelName:ru,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:a}=r,o=t[0],i=_b(e,t[1],o,Qo(a,o.shape));return{x:()=>i.x()}}},Mb={kernelName:au,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ad(e,$h(nf(n,r),"float32")),b:()=>ad(e,$h(tg(n,r),"float32"))}}};const Ob=ah({maxPool3dGrad_:function(e,t,n,r,a,o,i){const s=nh(e,"dy","maxPool3dGrad"),u=nh(t,"input","maxPool3dGrad"),c=nh(n,"output","maxPool3dGrad");let l=s,h=u,d=c,p=!1;4===u.rank&&(p=!0,l=Cp(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),h=Cp(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=Cp(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),Wo(5===l.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(l.rank,"."))),Wo(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),Wo(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),kp("maxPool3dGrad",o,i);const f={dy:l,input:h,output:d},m={filterSize:r,strides:a,pad:o,dimRoundingMode:i},g=Kl.runKernel(uu,f,m);return p?Cp(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),zb={kernelName:su,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:o,strides:i,pad:s,dimRoundingMode:u}=n;return{x:()=>Ob(e,r,a,o,i,s,u)}}};const Lb=ah({maxPoolGrad_:function(e,t,n,r,a,o,i){const s=nh(e,"dy","maxPoolGrad"),u=nh(t,"input","maxPoolGrad"),c=nh(n,"output","maxPoolGrad");Wo(u.rank===s.rank,(()=>"Rank of input (".concat(u.rank,") does not match rank of dy ")+"(".concat(s.rank,")"))),Wo(4===s.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(s.rank,"."))),Wo(4===u.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(u.rank,"."))),kp("maxPoolGrad",o,i);const l={dy:s,input:u,output:c},h={filterSize:r,strides:a,pad:o,dimRoundingMode:i};return Kl.runKernel(iu,l,h)}}),Bb={kernelName:ou,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:o,strides:i,pad:s}=n;return{x:()=>Lb(e,r,a,o,i,s)}}},Pb={kernelName:lu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n,o=Qo(a,r.shape),i=Go(df(r.shape,o)[1]);return{x:()=>{const t=r.shape.slice();o.forEach((e=>{t[e]=1}));const n=Cp(e,t);return rd(ad(n,Ff(r.shape,"float32")),i)}}}},Wb={kernelName:hu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:a}=r,[o,i]=t,s=_b(e,i,o,Qo(a,o.shape));return{x:()=>s.x()}}},Ub={kernelName:du,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ad(e,$h(Zm(n,r),"float32")),b:()=>ad(e,$h(tf(n,r),"float32"))}}},Vb={kernelName:pu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,o=a.map((e=>e[0]));return{x:()=>Hf(e,o,r.shape)}}},Gb={kernelName:fu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Sd(n.shape,r.shape);return{a:()=>{const t=Dd(n.shape,a);return t.length>0?Cp(uf(e,t),n.shape):e},b:()=>{const t=ad(e,If($p(rd(n,r)))),o=Dd(r.shape,a);return o.length>0?Cp(uf(t,o),r.shape):t}}}},jb={kernelName:gu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Sd(n.shape,r.shape);return{a:()=>{const t=ad(e,$h(r,"float32")),o=Dd(n.shape,a);return o.length>0?Cp(uf(t,o),n.shape):t},b:()=>{const t=ad(e,$h(n,"float32")),o=Dd(r.shape,a);return o.length>0?Cp(uf(t,o),r.shape):t}}}},Hb={kernelName:yu,gradFunc:e=>({x:()=>If(e)})},qb={kernelName:Cu,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Af(n.shape,"float32")}}},Kb={kernelName:ku,gradFunc:e=>({x:()=>sd(e)})},Xb={kernelName:Du,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return om(e,r).map((e=>()=>e))}},Yb={kernelName:Su,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,o=a.map((e=>e[0]));return{x:()=>Hf(e,o,r.shape)}}},Qb={kernelName:Eu,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,a]=t,o=n,i=r,s=Sd(o.shape,i.shape);return{a:()=>{const t=$h(i,"float32");let n=ad(e,ad(t,vd(o,xd(t,cd(1)))));const r=Dd(o.shape,s);return r.length>0&&(n=uf(n,r)),Cp(n,o.shape)},b:()=>{const t=tf(o,0),n=im(t,af(o),sd(o));let r=ad(e,ad(a,n));const u=Dd(i.shape,s);return u.length>0&&(r=uf(r,u)),Cp(r,i.shape)}}}},Zb={kernelName:Iu,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,a=tf(n,0);return{x:()=>im(a,e,ad(e,r)),alpha:()=>{let t=im(a,sd(e),ad(e,n));const o=Dd(r.shape,e.shape);return o.length>0&&(t=uf(t,o)),Cp(t,r.shape)}}}};const Jb=ah({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:nh(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:r};return Kl.runKernel(us,a,o)}});function $b(e,t,n){const r=e.shape.length,a=r-n.length,o=mf(n,r);let i=e;null!=o&&(i=cm(e,o));const s=i.shape.slice(),u=s.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);s.push(u);let c=function(e,t,n){const r=e.shape.slice();r[n]=1;const a=Cp(t,r),o=Jb(e,n,!0,!1),i=Jb(e,n,!0,!0),s=ad(o,i);return ad(a,s)}(i.reshape(s),t,a);if(c=c.reshape(i.shape),null!=o){const e=gf(o);c=cm(c,e)}return c}const ev={kernelName:Nu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;let o=[];return o=void 0===a||null===a?r.shape.map(((e,t)=>t)):"number"===typeof a?[a]:a,{x:()=>$b(r,e,o)}}},tv={kernelName:ws,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Sd(n.shape,r.shape);return{a:()=>{const t=rd(e,$h(r,"float32")),o=Dd(n.shape,a);return o.length>0?Cp(uf(t,o),n.shape):t},b:()=>{let t=ad(e,$h(n,"float32"));const o=Dd(r.shape,a);o.length>0&&(t=Cp(uf(t,o),r.shape));const i=id(r);return If(rd(t,$h(i,"float32")))}}}},nv={kernelName:Mu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rd(e,If(id(n)))}}},rv={kernelName:Uu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=ad(Zm(n,6),ym(n));return{x:()=>ad(e,$h(r,"float32"))}}},av={kernelName:Ou,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(e,$h(ym(n),"float32"))}}},ov={kernelName:zu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cp(e,n.shape)}}},iv={kernelName:Pu,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Kl.runKernel(Wu,a,n)}}},sv={kernelName:Lu,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Kl.runKernel(Bu,a,n)}}},uv={kernelName:Vu,gradFunc:(e,t,n)=>{const{dims:r}=n,a=Qo(r,e.shape);return{x:()=>Uf(e,a)}}},cv={kernelName:Gu,gradFunc:e=>({x:()=>sd(e)})},lv={kernelName:ju,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>If(rd(e,ad(vd(n,1.5),2)))}}};const hv=ah({logicalNot_:function(e){const t={x:nh(e,"x","logicalNot","bool")};return Kl.runKernel($s,t)}}),dv={kernelName:Xu,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>$h(sd(n),"float32"),t:()=>ad(e,$h(n,e.dtype)),e:()=>ad(e,$h(hv(n),e.dtype))}}},pv={kernelName:Yu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=tf(n,cd(0)),r=cd(Mg),a=cd(Og),o=ad(e,a),i=ad(ad(e,r),Yp($h(n,"float32")));return im(t,o,i)}}}},fv={kernelName:ec,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(e,ad(n,xd(cd(1),n)))}}},mv={kernelName:$u,gradFunc:e=>({x:()=>sd(e)})};const gv=ah({cos_:function(e){const t={x:nh(e,"x","cos","float32")};return Kl.runKernel(is,t)}}),yv={kernelName:Zu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(gv($h(n,"float32")),e)}}};const bv=ah({cosh_:function(e){const t={x:nh(e,"x","cosh","float32")};return Kl.runKernel(ss,t)}}),vv={kernelName:Ju,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(bv($h(n,"float32")),e)}}},xv={kernelName:Qu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:a,size:o}=n,i=r.shape,[s,u]=np(r,a,o),c=[];for(let l=0;l<e.rank;l++)c.push([s[l],i[l]-s[l]-u[l]]);return{x:()=>Rf(e,c)}}},wv={kernelName:ic,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:a}=n,o=ad(e,r);return{logits:()=>xd(o,ad(uf(o,[a],true),r))}}},kv={kernelName:tc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(e,jf(n))}}};const Cv=ah({batchToSpaceND_:function(e,t,n){const r=nh(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));Wo(r.rank>=1+t.length,(()=>"input rank is ".concat(r.rank," but should be > than blockShape.length ").concat(t.length))),Wo(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),Wo(r.shape[0]%a===0,(()=>"input tensor batch is ".concat(r.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(a)));const o={x:r},i={blockShape:t,crops:n};return Kl.runKernel(ji,o,i)}}),Dv={kernelName:ac,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>Cv(e,r,a)}}},Sv={kernelName:oc,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>_p(e,r)}}},Ev={kernelName:kc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:a}=n;return{x:()=>{let t=sd(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=td(t,Hf(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let o=0;o<a[1];++o)t=td(t,Hf(e,[n*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let o=0;o<a[1];++o)for(let i=0;i<a[2];++i)t=td(t,Hf(e,[n*r.shape[0],o*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(r.rank," tensors yet."));for(let n=0;n<a[0];++n)for(let o=0;o<a[1];++o)for(let i=0;i<a[2];++i)for(let s=0;s<a[3];++s)t=td(t,Hf(e,[n*r.shape[0],o*r.shape[1],i*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},Iv={kernelName:Nc,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Ed(t,sd(t)),r=ef(e,n);let a=nf(t,cd(0,"int32"));const o=r.rank-a.rank;for(let s=0;s<o;++s)a=Qp(a,s+1);a=vf(a,Ff(r.shape,"bool"));const i=sd(r);return im(a,r,i)}(e,n)}}};const Nv=[Sy,Ey,Iy,Ny,Ty,Ay,Fy,_y,Ry,My,Oy,zy,By,Wy,Uy,Gy,jy,Hy,qy,Ky,Xy,Yy,Zy,Qy,$y,tb,rb,ob,ib,sb,tv,ub,cb,lb,hb,db,fb,pb,gb,bb,wb,kb,Cb,Db,Sb,Eb,Ib,Nb,Tb,Fb,Rb,Rb,Mb,zb,Bb,Pb,Wb,Ub,Vb,Gb,jb,Hb,qb,Kb,Xb,Yb,Yb,Qb,Zb,ev,nv,rv,av,ov,iv,sv,uv,cv,lv,dv,pv,fv,mv,yv,vv,xv,wv,kv,Dv,Dv,Sv,Sv,{kernelName:nc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rd(e,ad(od($h(n,"float32")),2))}}},{kernelName:dc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=cd(2);return{a:()=>ad(e,ad(a,xd(n,r))),b:()=>ad(e,ad(a,xd(r,n)))}}},{kernelName:pc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(e,ad($h(n,"float32"),2))}}},{kernelName:Ac,gradFunc:e=>({x:()=>sd(e)})},{kernelName:vc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Sd(n.shape,r.shape);return{a:()=>{let t=e;const r=Dd(n.shape,a);return r.length>0&&(t=uf(t,r)),Cp(t,n.shape)},b:()=>{let t=e;const n=Dd(r.shape,a);return n.length>0&&(t=uf(t,n)),Cp(If(t),r.shape)}}}},{kernelName:rc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,a=r.shape.slice(),{axis:o}=n;Qo(o,r.shape).forEach((e=>{a[e]=1}));const i=Cp(e,a),s=ad(i,Ff(r.shape,"float32"));return{x:()=>s}}},{kernelName:xc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rd(e,id(gv(n)))}}},{kernelName:wc,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ad(xd(cd(1),id(n)),e)}}},Ev,{kernelName:Sc,gradFunc:(e,t,n)=>{const r=n,{perm:a}=r,o=gf(a);return{x:()=>cm(e,o)}}},{kernelName:Ic,gradFunc:(e,t,n)=>{const r=n,{axis:a}=r;return{value:()=>em(e,a)}}},Iv,{kernelName:Tc,gradFunc:e=>({x:()=>sd(e)})}];for(const eG of Nv)jc(eG);Il().prototype.abs=function(){return this.throwIfDisposed(),kd(this)};const Tv=ah({acos_:function(e){const t={x:nh(e,"x","acos")};return Kl.runKernel(Ei,t)}});Il().prototype.acos=function(){return this.throwIfDisposed(),Tv(this)};const Av=ah({acosh_:function(e){const t={x:nh(e,"x","acosh")};return Kl.runKernel(Ii,t)}});Il().prototype.acosh=function(){return this.throwIfDisposed(),Av(this)},Il().prototype.add=function(e){return this.throwIfDisposed(),td(this,e)},Il().prototype.all=function(e,t){return this.throwIfDisposed(),op(this,e,t)},Il().prototype.any=function(e,t){return this.throwIfDisposed(),ip(this,e,t)},Il().prototype.argMax=function(e){return this.throwIfDisposed(),sp(this,e)};const Fv=ah({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:nh(e,"x","argMin")},r={axis:t};return Kl.runKernel(Ri,n,r)}});Il().prototype.argMin=function(e){return this.throwIfDisposed(),Fv(this,e)},Il().prototype.asScalar=function(){return this.throwIfDisposed(),Wo(1===this.size,(()=>"The array must have only 1 element.")),Cp(this,[])},Il().prototype.asType=function(e){return this.throwIfDisposed(),$h(this,e)},Il().prototype.as1D=function(){return this.throwIfDisposed(),Cp(this,[this.size])},Il().prototype.as2D=function(e,t){return this.throwIfDisposed(),Cp(this,[e,t])},Il().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Cp(this,[e,t,n])},Il().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Cp(this,[e,t,n,r])},Il().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),Cp(this,[e,t,n,r,a])};const _v=ah({asin_:function(e){const t={x:nh(e,"x","asin")};return Kl.runKernel(Mi,t)}});Il().prototype.asin=function(){return this.throwIfDisposed(),_v(this)};const Rv=ah({asinh_:function(e){const t={x:nh(e,"x","asinh")};return Kl.runKernel(Oi,t)}});Il().prototype.asinh=function(){return this.throwIfDisposed(),Rv(this)};const Mv=ah({atan_:function(e){const t={x:nh(e,"x","atan")};return Kl.runKernel(zi,t)}});Il().prototype.atan=function(){return this.throwIfDisposed(),Mv(this)};const Ov=ah({atan2_:function(e,t){let n=nh(e,"a","atan2"),r=nh(t,"b","atan2");[n,r]=Pl(n,r);const a={a:n,b:r};return Kl.runKernel(Bi,a)}});Il().prototype.atan2=function(e){return this.throwIfDisposed(),Ov(this,e)};const zv=ah({atanh_:function(e){const t={x:nh(e,"x","atanh")};return Kl.runKernel(Li,t)}});Il().prototype.atanh=function(){return this.throwIfDisposed(),zv(this)},Il().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Dp(this,e,t,n,r)},Il().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Cv(this,e,t)},Il().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),Ep(this,e,t,n,r,a)},Il().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Ap(this,e)},Il().prototype.cast=function(e){return this.throwIfDisposed(),$h(this,e)};const Lv=ah({ceil_:function(e){const t={x:nh(e,"x","ceil","float32")};return Kl.runKernel(Yi,t)}});Il().prototype.ceil=function(){return this.throwIfDisposed(),Lv(this)},Il().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Fp(this,e,t)},Il().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof El&&(e=[e]),_p([this,...e],t)},Il().prototype.conv1d=function(e,t,n,r,a,o){return this.throwIfDisposed(),Bp(this,e,t,n,r,a,o)},Il().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),Wp(this,e,t,n,r,a)},Il().prototype.conv2d=function(e,t,n,r,a,o){return this.throwIfDisposed(),Lp(this,e,t,n,r,a,o)},Il().prototype.cos=function(){return this.throwIfDisposed(),gv(this)},Il().prototype.cosh=function(){return this.throwIfDisposed(),bv(this)},Il().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Jb(this,e,t,n)},Il().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),ab(this,e,t,n)};const Bv=ah({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=nh(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],o="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Wo(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),Wo(a*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(a," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(r.shape))),Wo(o*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(o," and ").concat(t," for depthToSpace with input shape\n        ").concat(r.shape))),Wo(i%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(i," for depthToSpace with input shape ").concat(r.shape)));const s={x:r},u={blockSize:t,dataFormat:n};return Kl.runKernel(ds,s,u)}});Il().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Bv(this,e,t)},Il().prototype.depthwiseConv2d=function(e,t,n,r,a,o){return this.throwIfDisposed(),Hp(this,e,t,n,r,a,o)};const Pv=ah({dilation2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=nh(e,"x","dilation2d"),s=nh(t,"filter","dilation2d");Wo(3===i.rank||4===i.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(i.rank,"."))),Wo(3===s.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(s.rank,"."))),Wo("NHWC"===o,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(o)));let u=i,c=!1;3===i.rank&&(u=Cp(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),Wo(u.shape[3]===s.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(u.shape[3]," vs ").concat(s.shape[2])));const l={x:u,filter:s},h={strides:n,pad:r,dilations:a},d=Kl.runKernel(ys,l,h);return c?Cp(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});Il().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),Pv(this,e,t,n,r,a)};const Wv=ah({divNoNan_:function(e,t){let n=nh(e,"a","div"),r=nh(t,"b","div");[n,r]=Pl(n,r);const a=rd(n,r),o=sd(a),i=Kp(r,o);return im(i,o,a)}});Il().prototype.divNoNan=function(e){return this.throwIfDisposed(),Wv(this,e)},Il().prototype.div=function(e){return this.throwIfDisposed(),rd(this,e)};const Uv=ah({dot_:function(e,t){const n=nh(e,"t1","dot"),r=nh(t,"t2","dot");Wo((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(r.rank,".")));const a=1===n.rank?n.size:n.shape[1],o=1===r.rank?r.size:r.shape[0];if(Wo(a===o,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(a," and ").concat(o,"."))),1===n.rank&&1===r.rank){const e=Cp(n,[1,-1]),t=Cp(r,[-1,1]),a=xf(e,t);return Cp(a,[])}if(1===n.rank&&2===r.rank){const e=Cp(n,[1,-1]),t=Cp(r,[r.shape[0],r.shape[1]]),a=xf(e,t);return Cp(a,[a.size])}if(2===n.rank&&1===r.rank){const e=Cp(r,[-1,1]),t=xf(n,e);return Cp(t,[t.size])}{const e=Cp(r,[r.shape[0],r.shape[1]]);return xf(n,e)}}});Il().prototype.dot=function(e){return this.throwIfDisposed(),Uv(this,e)},Il().prototype.elu=function(){return this.throwIfDisposed(),qp(this)},Il().prototype.equal=function(e){return this.throwIfDisposed(),Kp(this,e)},Il().prototype.erf=function(){return this.throwIfDisposed(),Xp(this)};const Vv=ah({euclideanNorm_:function(e){return ag(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});Il().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Vv(this,e,t)},Il().prototype.exp=function(){return this.throwIfDisposed(),Yp(this)},Il().prototype.expandDims=function(e){return this.throwIfDisposed(),Qp(this,e)};const Gv=ah({expm1_:function(e){const t={x:nh(e,"x","expm1")};return Kl.runKernel(Ts,t)}});Il().prototype.expm1=function(){return this.throwIfDisposed(),Gv(this)},Il().prototype.fft=function(){return this.throwIfDisposed(),hm(this)},Il().prototype.flatten=function(){return this.throwIfDisposed(),Cp(this,[this.size])},Il().prototype.floor=function(){return this.throwIfDisposed(),$p(this)},Il().prototype.floorDiv=function(e){return this.throwIfDisposed(),nd(this,e)},Il().prototype.gather=function(e,t,n){return this.throwIfDisposed(),ef(this,e,t,n)},Il().prototype.greaterEqual=function(e){return this.throwIfDisposed(),nf(this,e)},Il().prototype.greater=function(e){return this.throwIfDisposed(),tf(this,e)},Il().prototype.ifft=function(){return this.throwIfDisposed(),pm(this)},Il().prototype.irfft=function(){return this.throwIfDisposed(),fm(this)};const jv=ah({isFinite_:function(e){const t={x:nh(e,"x","isFinite")};return Kl.runKernel(Gs,t)}});Il().prototype.isFinite=function(){return this.throwIfDisposed(),jv(this)};const Hv=ah({isInf_:function(e){const t={x:nh(e,"x","isInf")};return Kl.runKernel(js,t)}});Il().prototype.isInf=function(){return this.throwIfDisposed(),Hv(this)};const qv=ah({isNaN_:function(e){const t={x:nh(e,"x","isNaN")};return Kl.runKernel(Hs,t)}});Il().prototype.isNaN=function(){return this.throwIfDisposed(),qv(this)},Il().prototype.leakyRelu=function(e){return this.throwIfDisposed(),rf(this,e)},Il().prototype.lessEqual=function(e){return this.throwIfDisposed(),Zm(this,e)},Il().prototype.less=function(e){return this.throwIfDisposed(),tg(this,e)};const Kv=ah({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const o=nh(e,"x","localResponseNormalization");Wo(4===o.rank||3===o.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(o.rank,"."))),Wo(Ho(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let i=o,s=!1;3===o.rank&&(s=!0,i=Cp(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={x:i},c={depthRadius:t,bias:n,alpha:r,beta:a},l=Kl.runKernel(tu,u,c);return s?Cp(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});Il().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Kv(this,e,t,n,r)};const Xv=ah({logSigmoid_:function(e){const t=nh(e,"x","logSigmoid");return ud((e=>({value:If(Zf(If(e))),gradFunc:t=>ad(t,jf(If(e)))})))(t)}});Il().prototype.logSigmoid=function(){return this.throwIfDisposed(),Xv(this)},Il().prototype.logSoftmax=function(e){return this.throwIfDisposed(),cf(this,e)},Il().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),bf(this,e,t)},Il().prototype.log=function(){return this.throwIfDisposed(),af(this)},Il().prototype.log1p=function(){return this.throwIfDisposed(),of(this)},Il().prototype.logicalAnd=function(e){return this.throwIfDisposed(),vf(this,e)},Il().prototype.logicalNot=function(){return this.throwIfDisposed(),hv(this)};const Yv=ah({logicalOr_:function(e,t){const n=nh(e,"a","logicalOr","bool"),r=nh(t,"b","logicalOr","bool");Sd(n.shape,r.shape);const a={a:n,b:r};return Kl.runKernel(eu,a)}});Il().prototype.logicalOr=function(e){return this.throwIfDisposed(),Yv(this,e)};const Qv=ah({logicalXor_:function(e,t){const n=nh(e,"a","logicalXor","bool"),r=nh(t,"b","logicalXor","bool");return Sd(n.shape,r.shape),vf(Yv(e,t),hv(vf(e,t)))}});Il().prototype.logicalXor=function(e){return this.throwIfDisposed(),Qv(this,e)},Il().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),xf(this,e,t,n)},Il().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),wf(this,e,t,n,r)},Il().prototype.max=function(e,t){return this.throwIfDisposed(),sf(this,e,t)},Il().prototype.maximum=function(e){return this.throwIfDisposed(),Ed(this,e)},Il().prototype.mean=function(e,t){return this.throwIfDisposed(),Cf(this,e,t)},Il().prototype.min=function(e,t){return this.throwIfDisposed(),Df(this,e,t)},Il().prototype.minimum=function(e){return this.throwIfDisposed(),Sf(this,e)};const Zv=ah({mirrorPad_:function(e,t,n){Wo("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const r=nh(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Wo(t.length===r.rank,(()=>"Padding doesn't match input. Must be ".concat(r.rank,". ")+"Got ".concat(t.length,".")));const a="reflect"===n?1:0;for(let s=0;s<r.rank;s++)Wo(2===t[s].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Wo(t[s][0]>=0&&t[s][0]<=r.shape[s]-a&&t[s][1]>=0&&t[s][1]<=r.shape[s]-a,(()=>"Padding in dimension ".concat(s," cannot be greater than or equal ")+"to ".concat(r.shape[s]-a," or less than 0 for input of ")+"shape ".concat(r.shape)));const o={paddings:t,mode:n},i={x:r};return Kl.runKernel(pu,i,o)}});Il().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Zv(this,e,t)};const Jv=ah({mod_:function(e,t){let n=nh(e,"a","mod"),r=nh(t,"b","mod");[n,r]=Pl(n,r);const a={a:n,b:r};return Kl.runKernel(fu,a)}});Il().prototype.mod=function(e){return this.throwIfDisposed(),Jv(this,e)},Il().prototype.mul=function(e){return this.throwIfDisposed(),ad(this,e)},Il().prototype.neg=function(){return this.throwIfDisposed(),If(this)},Il().prototype.norm=function(e,t,n){return this.throwIfDisposed(),ag(this,e,t,n)},Il().prototype.notEqual=function(e){return this.throwIfDisposed(),Nf(this,e)},Il().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),Tf(this,e,t,n)},Il().prototype.onesLike=function(){return this.throwIfDisposed(),_f(this)},Il().prototype.pad=function(e,t){return this.throwIfDisposed(),Rf(this,e,t)};const $v=ah({pool_:function(e,t,n,r,a,o,i){null==a&&(a=[1,1]),null==o&&(o=1),0===r&&(r="valid");const s=nh(e,"x","maxPool");let u=s,c=!1;3===s.rank&&(c=!0,u=Cp(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Wo(vp(o,a),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(a,"'")));const l=cp(u.shape,t,o,a,r),h=[l.dilationHeight,l.dilationWidth];let d;d="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),a=r.map((e=>Math.floor(e/2))),o=r.map(((e,t)=>e-a[t]));return r.map(((e,t)=>[a[t],o[t]]))}([l.filterHeight,l.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),a=n.map((e=>e[1])),o=e.concat(r,a),i=t.map(((e,t)=>(e-o[t]%e)%e)),s=a.map(((e,t)=>e+i[t])),u=t.map(((e,t)=>[r[t],s[t]])),c=t.map(((e,t)=>[0,i[t]]));return[u,c]}([l.inHeight,l.inWidth],h,d),g=p?r:"valid",y=p?u:Vy(u,h,f),b=("avg"===n?()=>Dp(y,t,o,g,i):()=>wf(y,t,o,g,i))(),v=p?b:Cv(b,h,m);return c?Cp(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});Il().prototype.pool=function(e,t,n,r,a,o){return this.throwIfDisposed(),$v(this,e,t,n,r,a,o)},Il().prototype.pow=function(e){return this.throwIfDisposed(),vd(this,e)},Il().prototype.prelu=function(e){return this.throwIfDisposed(),Mf(this,e)};const ex=ah({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=nh(e,"x","prod");"bool"===r.dtype&&(r=$h(r,"int32"));const a={x:r},o={axis:t,keepDims:n};return Kl.runKernel(Nu,a,o)}});Il().prototype.prod=function(e,t){return this.throwIfDisposed(),ex(this,e,t)};const tx=ah({reciprocal_:function(e){const t={x:nh(e,"x","reciprocal")};return Kl.runKernel(Mu,t)}});Il().prototype.reciprocal=function(){return this.throwIfDisposed(),tx(this)},Il().prototype.relu=function(){return this.throwIfDisposed(),Wf(this)},Il().prototype.relu6=function(){return this.throwIfDisposed(),gm(this)},Il().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Cp(this,e.shape)},Il().prototype.reshape=function(e){return this.throwIfDisposed(),Cp(this,e)},Il().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Xm(this,e,t,n)},Il().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Ym(this,e,t,n)},Il().prototype.reverse=function(e){return this.throwIfDisposed(),Uf(this,e)},Il().prototype.rfft=function(){return this.throwIfDisposed(),dm(this)},Il().prototype.round=function(){return this.throwIfDisposed(),Jm(this)},Il().prototype.rsqrt=function(){return this.throwIfDisposed(),mb(this)},Il().prototype.selu=function(){return this.throwIfDisposed(),Vf(this)},Il().prototype.separableConv2d=function(e,t,n,r,a,o){return this.throwIfDisposed(),Gf(this,e,t,n,r,a,o)},Il().prototype.sigmoid=function(){return this.throwIfDisposed(),jf(this)};const nx=ah({sign_:function(e){const t={x:nh(e,"x","sign")};return Kl.runKernel($u,t)}});Il().prototype.sign=function(){return this.throwIfDisposed(),nx(this)},Il().prototype.sin=function(){return this.throwIfDisposed(),eb(this)},Il().prototype.sinh=function(){return this.throwIfDisposed(),nb(this)},Il().prototype.slice=function(e,t){return this.throwIfDisposed(),Hf(this,e,t)},Il().prototype.softmax=function(e){return this.throwIfDisposed(),Qf(this,e)},Il().prototype.softplus=function(){return this.throwIfDisposed(),Zf(this)},Il().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Vy(this,e,t)},Il().prototype.split=function(e,t){return this.throwIfDisposed(),Jf(this,e,t)},Il().prototype.sqrt=function(){return this.throwIfDisposed(),od(this)},Il().prototype.square=function(){return this.throwIfDisposed(),id(this)},Il().prototype.squaredDifference=function(e){return this.throwIfDisposed(),cg(this,e)},Il().prototype.squeeze=function(e){return this.throwIfDisposed(),$f(this,e)},Il().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof El?[this,e]:[this,...e];return em(n,t)},Il().prototype.step=function(e){return this.throwIfDisposed(),ym(this,e)};const rx=ah({stridedSlice_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const c={x:nh(e,"x","stridedSlice","string_or_numeric")},l={begin:t,end:n,strides:r,beginMask:a,endMask:o,ellipsisMask:i,newAxisMask:s,shrinkAxisMask:u};return Kl.runKernel(mc,c,l)}});Il().prototype.stridedSlice=function(e,t,n,r,a,o,i,s){return this.throwIfDisposed(),rx(this,e,t,n,r,a,o,i,s)},Il().prototype.sub=function(e){return this.throwIfDisposed(),xd(this,e)},Il().prototype.sum=function(e,t){return this.throwIfDisposed(),uf(this,e,t)};const ax=ah({tan_:function(e){const t={x:nh(e,"x","tan","float32")};return Kl.runKernel(xc,t)}});Il().prototype.tan=function(){return this.throwIfDisposed(),ax(this)},Il().prototype.tanh=function(){return this.throwIfDisposed(),tm(this)},Il().prototype.tile=function(e){return this.throwIfDisposed(),Zp(this,e)},Il().prototype.toBool=function(){return this.throwIfDisposed(),$h(this,"bool")},Il().prototype.toFloat=function(){return this.throwIfDisposed(),$h(this,"float32")},Il().prototype.toInt=function(){return this.throwIfDisposed(),$h(this,"int32")};const ox=ah({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=nh(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>a)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(a,") ")+"but got ".concat(t));const o={x:r},i={k:t,sorted:n},[s,u]=Kl.runKernel(Cc,o,i);return{values:s,indices:u}}});Il().prototype.topk=function(e,t){return this.throwIfDisposed(),ox(this,e,t)},Il().prototype.transpose=function(e){return this.throwIfDisposed(),cm(this,e)};const ix=ah({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=nh(e,"x","unique","string_or_numeric");Wo(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:t},[o,i]=Kl.runKernel(Ec,r,a);return{values:o,indices:i}}});Il().prototype.unique=function(e){return this.throwIfDisposed(),ix(this,e)},Il().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),yb(this,e,t)},Il().prototype.unstack=function(e){return this.throwIfDisposed(),om(this,e)},Il().prototype.where=function(e,t){return this.throwIfDisposed(),im(e,this,t)},Il().prototype.zerosLike=function(){return this.throwIfDisposed(),sd(this)};class sx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,sx.prototype)}}class ux extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ux.prototype)}}class cx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,cx.prototype)}}class lx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,lx.prototype)}}class hx extends Error{constructor(e){super(e),Object.setPrototypeOf(this,hx.prototype)}}Error;class dx{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function px(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function fx(e,t){if(!e)throw new hx(t)}function mx(e,t){let n=0;for(const r of e)r===t&&n++;return n}function gx(e){return 1===e.length?e[0]:e}function yx(e){return Array.isArray(e)?e:[e]}function bx(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function vx(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let xx={};function wx(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function kx(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>kx(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?kx(t):e[n]=t.value)}}}function Cx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const a=e;let o;if(a in n)o=n[a];else if(a in xx)o=xx[a];else if(o=t[a],null==o)throw new cx("Unknown ".concat(r,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return o}{const o=e;if(null==o.className||null==o.config)throw new cx("".concat(r,": Improper config format: ")+"".concat(JSON.stringify(o),".\n")+"'className' and 'config' must set.");const i=o.className;let s,u;if(i in n?[s,u]=n[i]:i in xx?[s,u]=xx.className:i in t&&([s,u]=t[i]),null==s)throw new cx("Unknown ".concat(r,": ").concat(i,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(r," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(r," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=u){const e={};for(const n of Object.keys(xx))e[n]=xx[n];for(const a of Object.keys(n))e[a]=n[a];o.config.customObjects=e;const t=Object.assign({},xx);for(const a of Object.keys(n))xx[a]=n[a];kx(o.config);const r=u(s,o.config,n,a);return xx=Object.assign({},t),r}{const e=Object.assign({},xx);for(const r of Object.keys(n))xx[r]=n[r];const t=new s(o.config);return xx=Object.assign({},e),t}}}function Dx(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Sx(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function Ex(e){if(null==e)throw new cx("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Ix(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new cx("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function Nx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return fx(n>=0),fx(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function Tx(e,t){Array.isArray(e)?(Wo(e.length>0,(()=>"".concat(t," is unexpectedly an empty array."))),e.forEach(((e,n)=>Tx(e,"element ".concat(n+1," of ").concat(t))))):Wo(Number.isInteger(e)&&e>0,(()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(Ax(e),".")))}function Ax(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>Ax(e))).join(",")+"]":"string"===typeof e?'"'.concat(e,'"'):"".concat(e)}function Fx(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let _x=0;function Rx(){return _x++}const Mx={};function Ox(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in Mx||(Mx[e]=0),Mx[e]+=1,e+Mx[e].toString()}const zx=["channelsFirst","channelsLast"],Lx=["nearest","bilinear"],Bx=["valid","same","causal"],Px=["max","avg"],Wx=["sum","mul","concat","ave"],Ux=new Map;function Vx(e){Ix(zx,"DataFormat",e)}function Gx(e){Ix(Bx,"PaddingMode",e)}function jx(e){Ix(Px,"PoolMode",e)}const Hx=[];function qx(e,t){Hx.push(e);try{const e=t();return Hx.pop(),e}catch(n){throw Hx.pop(),n}}function Kx(e){if(!Qx(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===Hx.length?"":Hx.join("/")+"/")+e}function Xx(e){if(!Qx(e))throw new Error("Not a valid tensor name: '"+e+"'");Ux.has(e)||Ux.set(e,0);const t=Ux.get(e);if(Ux.set(e,Ux.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return Ux.set(n,1),n}return e}const Yx=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Qx(e){return!!e.match(Yx)}function Zx(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function Jx(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function $x(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function ew(e,t){if(t<e)throw new cx("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let r=e;r<t;++r)n.push(r);return n}let tw;function nw(){return null==tw&&(tw=mh().epsilon()),tw}function rw(e,t){return $h(e,t)}function aw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Cp(e,n)}function ow(e,t,n){return hh((()=>{switch(e.rank){case 1:return qf(e,t,n);case 2:return Kf(e,[t,0],[n,e.shape[1]]);case 3:return Xf(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Yf(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Hf(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Hf(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new cx("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function iw(e,t,n){return hh((()=>{switch(e.rank){case 1:return qf(e,t,n);case 2:return Kf(e,[0,t],[e.shape[0],n]);case 3:return Xf(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Yf(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new cx("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function sw(e,t,n,r){return hh((()=>{switch(e.rank){case 1:return qf(e,t,n);case 2:switch(r){case 1:return ow(e,t,n);case 2:return iw(e,t,n);default:throw new cx("The axis is not within the rank of the tensor "+"".concat(r))}case 3:switch(r){case 1:return ow(e,t,n);case 2:return Xf(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return iw(e,t,n);default:throw new cx("The axis is not within the rank of the tensor "+"".concat(r))}case 4:switch(r){case 1:return ow(e,t,n);case 2:return Yf(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Yf(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return iw(e,t,n);default:throw new cx("The axis is not within the rank of the tensor "+"".concat(r))}default:throw new cx("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function uw(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),_p(e,n)}function cw(e,t){switch(e.rank){case 1:return Rp([e,t]);case 2:return Mp([e,t],0);case 3:return Op([e,t],0);case 4:return zp([e,t],0);default:throw new cx("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function lw(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new cx("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return Zp(e,t)}function hw(e){return Lf(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function dw(e,t,n,r){if(e.rank<2||t.rank<2)throw new lx("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new lx("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){return Sm({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?mw(e.rank,r,"channelsLast"):null,activation:n})}{const a=e.shape.slice(),o=a.pop();e=Cp(e,[-1,o]);const i=t.shape.slice(),s=i.pop(),u=i.pop(),c=[...i,s],l=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Cp(cm(t,l),[u,-1]);const h=[...a,...c];return Cp(Sm({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?mw(e.rank,r,"channelsLast"):null,activation:n}),h)}}function pw(e,t,n){return hh((()=>(t=Array.isArray(t)?nm(t,"int32"):$h(t,"int32"),ef(e,t,n))))}function fw(e){return ad(e,e)}function mw(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new cx("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===r.length?Cp(t,[1,r[0],1,1,1]):Cp(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Cp(t,[1,1,1,1,r[0]]):Cp(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Cp(t,[1,r[0],1,1]):Cp(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Cp(t,[1,1,1,r[0]]):Cp(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Cp(t,[1,r[0],1]):Cp(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Cp(t,[1,1,r[0]]):Cp(t,[1].concat(r))}else if(e<3)return t;throw new cx("Unsupported input rank by biasAdd: ".concat(t.rank))}function gw(e,t,n){return hh((()=>(null==n&&(n="channelsLast"),Vx(n),td(e,mw(e.rank,t,n)))))}function yw(e,t,n,r){return hh((()=>lm(e,t,n,r)))}function bw(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const vw=["fanIn","fanOut","fanAvg"],xw=["normal","uniform","truncatedNormal"];class ww extends dd{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class kw extends ww{apply(e,t){return Af(e,t)}}kw.className="Zeros",fd(kw);class Cw extends ww{apply(e,t){return Ff(e,t)}}Cw.className="Ones",fd(Cw);class Dw extends ww{constructor(e){if(super(),"object"!==typeof e)throw new cx("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new cx("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return hh((()=>ad(cd(this.value),Ff(e,t))))}getConfig(){return{value:this.value}}}Dw.className="Constant",fd(Dw);class Sw extends ww{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Bf(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Sw.className="RandomUniform",fd(Sw);class Ew extends ww{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new lx("randomNormal does not support dType ".concat(t,"."));return hw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Ew.className="RandomNormal",fd(Ew);class Iw extends ww{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new lx("truncatedNormal does not support dType ".concat(t,"."));return am(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Iw.className="TruncatedNormal",fd(Iw);class Nw extends ww{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return hh((()=>{if(2!==e.length||e[0]!==e[1])throw new cx("Identity matrix initializer can only be used for 2D square matrices.");return ad(this.gain,Jp(e[0]))}))}getConfig(){return{gain:this.gain}}}Nw.className="Identity",fd(Nw);class Tw extends ww{constructor(e){if(super(),e.scale<0)throw new cx("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,Ix(vw,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){Ix(xw,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(Vx(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){const r=Zx(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){const r=Zx(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{const r=Zx(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1];let o=this.scale;if("fanIn"===this.mode?o/=Math.max(1,r):"fanOut"===this.mode?o/=Math.max(1,a):o/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(o);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new lx("".concat(this.getClassName()," does not support dType ").concat(t,"."));return am(e,0,n,t,this.seed)}{const n=Math.sqrt(3*o);return Bf(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Tw.className="VarianceScaling",fd(Tw);class Aw extends Tw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Tw.className}}Aw.className="GlorotUniform",fd(Aw);class Fw extends Tw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Tw.className}}Fw.className="GlorotNormal",fd(Fw);class _w extends Tw{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Tw.className}}_w.className="HeNormal",fd(_w);class Rw extends Tw{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Tw.className}}Rw.className="HeUniform",fd(Rw);class Mw extends Tw{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Tw.className}}Mw.className="LeCunNormal",fd(Mw);class Ow extends Tw{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Tw.className}}Ow.className="LeCunUniform",fd(Ow);class zw extends ww{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return hh((()=>{if(e.length<2)throw new lx("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError("Unsupported data type ".concat(t,"."));const n=Go(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(a,") elements: ")+"Slowness may result.");const o=hw([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=hg.qr(o,!1);let s=i[0];const u=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return s=ad(s,u.sign()),n<r&&(s=s.transpose()),ad(cd(this.gain),s.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}zw.className="Orthogonal",fd(zw);const Lw={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Bw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Cx(e,pd.getMap().classNameMap,t,"initializer")}function Pw(e){return wx(e)}function Ww(e){if("string"===typeof e){const t=e in Lw?Lw[e]:e;if("GlorotNormal"===t)return new Fw;if("GlorotUniform"===t)return new Aw;if("HeNormal"===t)return new _w;if("HeUniform"===t)return new Rw;if("LeCunNormal"===t)return new Mw;if("LeCunUniform"===t)return new Ow;{const e={};return e.className=t,e.config={},Bw(e)}}return e instanceof ww?e:Bw(e)}function Uw(e){return Array.isArray(e)&&Array.isArray(e[0])}function Vw(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Gw(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new cx("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function jw(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new cx("Expected exactly 1 Shape; got ".concat(e.length))}return e}function Hw(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const qw="Variable";class Kw{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:qw,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Rx(),n=null==n?qw:n,this.originalName=Kx(n),this.name=Xx(this.originalName),this.trainable_=r,this.constraint=a,this.val=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Kl.makeVariable(e,t,n,r)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Xw(e){return e.map((e=>e.read()))}function Yw(e){e.forEach((e=>{e[0].write(e[1])}))}class Qw{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Zw{constructor(e,t,n,r,a,o,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=Rx(),null!=o&&(this.originalName=Kx(o),this.name=Xx(this.originalName)),this.rank=t.length}}let Jw=0;class $w{constructor(e,t){this.callArgs=t,this.id=Jw++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ek=0;class tk extends dd{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ek++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=bx(e)+"_"+Ox(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new ux("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new cx("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return gx(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return gx(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new sx("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new sx("Layer ".concat(this.name)+" is not connected, no input to return.");return gx(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new sx("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new sx("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return gx(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=yx(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=yx(this.inputSpec);if(t.length!==n.length)throw new cx("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(e));for(let r=0;r<t.length;r++){const e=t[r],a=n[r];if(null==a)continue;const o=e.rank;if(null!=a.ndim&&o!==a.ndim)throw new cx("Input ".concat(r," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(a.ndim,", found ndim=").concat(o));if(null!=a.maxNDim&&o>a.maxNDim)throw new cx("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(a.maxNDim,", found ndim=").concat(o));if(null!=a.minNDim&&o<a.minNDim)throw new cx("Input ".concat(r," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(a.minNDim,", found ndim=").concat(o,"."));if(null!=a.dtype&&e.dtype!==a.dtype)throw new cx("Input ".concat(r," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(a.dtype,", found dtype=").concat(e.dtype,"."));if(a.axes){const t=e.shape;for(const e in a.axes){const n=Number(e),o=a.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=o&&-1===[o,null].indexOf(i))throw new cx("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(o," but got shape ").concat(t,"."))}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){const n=a.shape[t],o=e.shape[t];if(null!=n&&null!=o&&n!==o)throw new cx("Input ".concat(r," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(a.shape,", ")+"found shape=".concat(e.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=yx(e),r=function(e){let t=!0;for(const n of yx(e))if(!(n instanceof Zw)){t=!1;break}return t}(e),a=function(e){let t=!0;for(const n of yx(e))if(n instanceof Zw){t=!1;break}return t}(e);if(r===a)throw new cx("Arguments to apply() must be all SymbolicTensors or all Tensors");return qx(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of yx(e))t.push(n.shape);this.build(gx(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const a=yx(r),o=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),o.push(e);if(r=gx(o),null!=this.activityRegularizer)throw new lx("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=yx(e);const t=[];for(const n of e)t.push(n.shape);return gx(t)}(e),r=this.computeOutputShape(n);let a;const o="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new Zw(o,n,this,yx(e),t,this.name,r))):new Zw(o,r,this,yx(e),t,this.name),this.addInboundNode(e,a,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new lx("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new sx("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new sx("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new ux("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return Hw(this.weights)}build(e){this.built=!0}getWeights(){return Xw(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){hh((()=>{const t=this.weights;if(t.length!==e.length)throw new cx('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],r=Xw(t);for(let a=0;a<r.length;++a){const o=r[a],i=t[a],s=e[a];if(!jo(o.shape,s.shape))throw new cx("Layer weight shape ".concat(o.shape," ")+"not compatible with provided weight shape ".concat(s.shape));n.push([i,s])}Yw(n)}))}addWeight(e,t,n,r,a,o,i,s){if(-1!==this._addedWeightNames.indexOf(e))throw new cx("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=s?s():Ww("zeros"));const u=r.apply(t,n),c=new Kw(u,n,e,o,i);return u.dispose(),null!=a&&this.addLoss((()=>a.apply(c.read()))),null==o&&(o=!0),o?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=yx(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach((e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),a=yx(t),o=yx(r);if(a.length!==o.length)throw new Error("".concat(this.name," outputs ").concat(a.length," tensors ")+"but ".concat(a.length," masks for those tensors"));for(let i=0;i<a.length;i++)a[i].kerasMask=o[i]}addInboundNode(e,t,n,r,a,o){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const s=yx(e);t=yx(t),n=yx(n),r=yx(r),a=Vw(a),o=Vw(o);const u=[],c=[],l=[];for(const h of s)u.push(h.sourceLayer),c.push(h.nodeIndex),l.push(h.tensorIndex);new $w({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:l,inputTensors:s,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:o},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function nk(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=nk(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class rk extends tk{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Ox("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new cx("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new cx("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new cx("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new Zw(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new $w({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new cx("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}rk.className="InputLayer",fd(rk);class ak{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof ak)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new cx("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return $h(t,e.dtype)}catch($V){throw new cx("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Zw){if(null==this.id2Value[e.id])throw new cx("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new cx("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof Zw){if(null==this.id2Value[e.id])throw new cx("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new cx("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&dh(this.id2Mask)}}const ok=new dx,ik=new dx;function sk(e,t,n,r){const a=null!=n&&n.training,o=Array.isArray(e),i=o?e:[e],s=i.map((e=>e.name)),u=[],c=t.names();for(const f of s)-1!==c.indexOf(f)?u.push(t.getValue(f)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const l=s.join(",")+"|"+t.names().sort().join(",");let h,d=ok.get(l);if(null==d){const e=function(e,t){Wo(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const a=ck(e[0],t);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const o of e){const{sorted:e,recipientMap:i}=ck(o,t);for(const t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:uk(r)}}(i,t);d=e.sorted,h=e.recipientCounts,ok.put(l,d),ik.put(l,h)}h={},a||Object.assign(h,ik.get(l));const p=new ak(t);for(let f=0;f<d.length;++f){if(null!=r){const e=lh().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=d[f],o=e.sourceLayer;if(o instanceof rk)continue;const i=[],c=[],l=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),c.push(r),null!=r&&(m=!0),a||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==s.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||l.push(e))}m&&((n=n||{}).mask=c[0]);const g=yx(o.apply(i,n));let y=null;o.supportsMasking&&(y=o.computeMask(i,c));const b=lk(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=s.indexOf(v[t].name);-1!==e&&(u[e]=g[t])}a||dh(l)}return p.disposeMasks(),o?u:u[0]}function uk(e){const t={};for(const n in e)t[n]=e[n].size;return t}function ck(e,t){const n=new Set,r=[],a={};for(const s of t.names())n.add(s);const o=[],i=[];for(o.push(e);o.length>0;){const e=o[o.length-1];if(n.has(e.name)){o.pop();continue}const t=i[i.length-1]===o.length-1;if(0===e.inputs.length||t)o.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(o.length-1);for(const t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),n.has(t.name)||o.push(t)}}return{sorted:r,recipientMap:a}}function lk(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function hk(e,t){return hh((()=>od(uf(ad(e,e),t,!0))))}xi().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=ok&&ok.setMaxEntries(e),null!=ik&&ik.setMaxEntries(e)}));class dk extends dd{getConfig(){return{}}}class pk extends dk{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return hh((()=>{const t=hk(e,this.axis),n=Fp(t,0,this.maxValue);return ad(e,rd(n,td(nw(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}pk.className="MaxNorm",fd(pk);class fk extends dk{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return hh((()=>rd(e,td(nw(),hk(e,this.axis)))))}getConfig(){return{axis:this.axis}}}fk.className="UnitNorm",fd(fk);class mk extends dk{apply(e){return Wf(e)}}mk.className="NonNeg",fd(mk);class gk extends dk{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return hh((()=>{const t=hk(e,this.axis),n=td(ad(this.rate,Fp(t,this.minValue,this.maxValue)),ad(1-this.rate,t));return ad(e,rd(n,td(nw(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}gk.className="MinMaxNorm",fd(gk);const yk={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function bk(e){return wx(e)}function vk(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Cx(e,pd.getMap().classNameMap,t,"constraint")}function xk(e){if(null==e)return null;if("string"===typeof e){return vk({className:e in yk?yk[e]:e,config:{}})}return e instanceof dk?e:vk(e)}async function wk(e){if(null==e)return;const t=[],n=[],r=[];for(const a in e){const o=e[a];if("number"!==typeof o){const e=o;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){const a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];dh(r)}}function kk(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var Ck;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Ck||(Ck={}));class Dk{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Sk{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Ek extends Dk{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const a=hh((()=>td(this.totals[r],ad(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:hh((()=>{const e=ad(rd(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),ph(t[n])})))}}class Ik extends Dk{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const a in this.history){const r=this.history[a];for(let o=0;o<r.length;++o)if("number"!==typeof r[o]){const i=r[o];e.push(i.data()),t.push(a),n.push(o)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a){this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}}}class Nk extends Dk{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||fg,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");ri(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():cl();return function(){const o=null!=n?n():cl();return o-a<t||(a=o,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await wk(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await wk(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await wk(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await wk(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await wk(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):ri(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await wk(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await wk(e),await this.trainEnd(e))}}function Tk(e,t){if(null==e&&(e={}),e instanceof Dk)return[e];if(Array.isArray(e)&&e[0]instanceof Dk)return e;return yx(e).map((e=>new Nk(e,t)))}class Ak{constructor(){}static registerCallbackConstructor(e,t){Wo(e>=0&&Number.isInteger(e),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e))),Ak.checkForDuplicate(t),null==Ak.constructors[e]&&(Ak.constructors[e]=[]),Ak.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Ak.constructors){Ak.constructors[+t].forEach((t=>{if(t===e)throw new cx("Duplicate callback constructor.")}))}}static clear(){Ak.constructors={}}static createCallbacks(e){const t=[];for(const n in Ak.constructors){const r=+n;e>=r&&t.push(...Ak.constructors[r])}return t.map((e=>new e))}}function Fk(e,t,n,r,a,o,i,s,u){const c=new Ik,l=[new Ek,...Ak.createCallbacks(t)];null!=e&&l.push(...e),l.push(c);const h=new Sk(l);return h.setParams({epochs:n,initialEpoch:r,samples:a,steps:o,batchSize:i,verbose:t,doValidation:s,metrics:u}),{callbackList:h,history:c}}function _k(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Cx(e,pd.getMap().classNameMap,t,"layer",n)}function Rk(e,t){return hh((()=>{"float32"!==e.dtype&&(e=$h(e,"float32"));const n=uf(fw(e),t,!0),r=yd(n.shape,nw()),a=od(Ed(n,r));return rd(e,a)}))}function Mk(e,t){return hh((()=>Cf(fw(xd(t,e)),-1)))}function Ok(e,t){return hh((()=>Cf(kd(xd(t,e)),-1)))}function zk(e,t){return hh((()=>{const n=xd(e,t),r=Fp(kd(e),nw(),Number.MAX_VALUE),a=kd(rd(n,r));return ad(100,Cf(a,-1))}))}function Lk(e,t){return hh((()=>{const n=Fp(t,nw(),Number.MAX_VALUE),r=af(td(1,n)),a=Fp(e,nw(),Number.MAX_VALUE),o=af(td(1,a));return Cf(fw(xd(r,o)),-1)}))}function Bk(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return hh((()=>{if(n)t=Qf(t);else{const e=uf(t,t.shape.length-1,!0);t=rd(t,e)}return t=Fp(t,nw(),1-nw()),If(uf(ad($h(e,"float32"),af(t)),t.shape.length-1))}))}function Pk(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return hh((()=>{const r=$h($p(function(e){const t=[Zx(e.shape)];return Cp(e,t)}(e)),"int32"),a=(t=Fp(t,nw(),1-nw())).shape;return Bk(Cp(Tf(r,a[a.length-1]),a),t,n)}))}function Wk(e,t){return hh((()=>{let n;return n=Fp(t,nw(),1-nw()),n=af(rd(n,xd(1,n))),Cf(function(e,t){if(!jo(e.shape,t.shape))throw new cx("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return hh((()=>{const n=Wf(t),r=If(kd(t));return td(xd(n,ad(t,e)),of(Yp(r)))}))}(e,n),-1)}))}function Uk(e,t){return hh((()=>{const n=Fp(e,nw(),1),r=Fp(t,nw(),1);return uf(ad(e,af(rd(n,r))),-1)}))}function Vk(e,t){return hh((()=>{const n=Rk(e,-1),r=Rk(t,-1),a=ad(n,r);return If(uf(a,-1))}))}Ak.constructors={};const Gk={meanSquaredError:Mk,meanAbsoluteError:Ok,meanAbsolutePercentageError:zk,meanSquaredLogarithmicError:Lk,squaredHinge:function(e,t){return hh((()=>{const n=Ed(0,xd(1,ad(e,t)));return Cf(fw(n),-1)}))},hinge:function(e,t){return hh((()=>{const n=Ed(0,xd(1,ad(e,t)));return Cf(n,-1)}))},categoricalHinge:function(e,t){return hh((()=>{const n=uf(ad(e,t),-1),r=sf(ad(xd(1,e),t),-1);return Ed(0,td(1,xd(r,n)))}))},logcosh:function(e,t){return hh((()=>{const n=Math.log(2),r=xd(t,e),a=xd(td(r,Zf(ad(-2,r))),n);return Cf(a,-1)}))},categoricalCrossentropy:Bk,sparseCategoricalCrossentropy:Pk,binaryCrossentropy:Wk,kullbackLeiblerDivergence:Uk,poisson:function(e,t){return hh((()=>{const n=af(td(nw(),t));return Cf(xd(t,ad(e,n)),-1)}))},cosineProximity:Vk};function jk(e){if("string"===typeof e){if(e in Gk)return Gk[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new cx(t)}return e}function Hk(e,t){return hh((()=>{const n=ad(.5,_f(t)),r=rw(tf(t,n),e.dtype);return Cf(Kp(e,r),-1)}))}function qk(e,t){return hh((()=>rw(Kp(sp(e,-1),sp(t,-1)),"float32")))}function Kk(e,t){return hh((()=>$h(uf(vf(Kp(e,1),Kp(t,1))),"float32")))}function Xk(e,t){return Wk(e,t)}function Yk(e,t){return e.rank===t.rank&&(e=$f(e,[e.rank-1])),(t=sp(t,-1)).dtype!==e.dtype&&(t=$h(t,e.dtype)),$h(Kp(e,t),"float32")}const Qk=Bk,Zk=Pk,Jk={binaryAccuracy:Hk,categoricalAccuracy:qk,precision:function(e,t){return hh((()=>{const n=Kk(e,t),r=function(e,t){return hh((()=>$h(uf(vf(Kp(e,0),Kp(t,1))),"float32")))}(e,t),a=td(n,r);return $h(im(tf(a,0),rd(n,a),0),"float32")}))},categoricalCrossentropy:Qk,sparseCategoricalCrossentropy:Zk,mse:Mk,MSE:Mk,mae:Ok,MAE:Ok,mape:zk,MAPE:zk,cosine:Vk};function $k(e){if("string"===typeof e&&e in Jk)return Jk[e];if("string"!==typeof e&&null!=e)return e;throw new cx("Unknown metric ".concat(e))}function eC(e){if(fx(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(Gk))if(Gk[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(Jk))if(Jk[n]===e){t=n;break}return void 0!==t?t:e.name}}const tC=1048576;function nC(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!rC(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>tC&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(tC,"."))}}function rC(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!rC(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!rC(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function aC(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(e){let t=!0;const n=[],r=[];for(const a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(const a of e.layers){let e=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),o=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!a){o.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),oC(o,n,r),r("=".repeat(t));const s=e.layers;for(let l=0;l<s.length;++l)a?iC(s[l],n,r):sC(s[l],n,i,r),r((l===s.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const u=function(e){let t;t=null!=e.collectedTrainableWeights?Hw(e.collectedTrainableWeights):Hw(e.trainableWeights);return t}(e),c=Hw(e.nonTrainableWeights);r("Total params: ".concat(u+c)),r("Trainable params: ".concat(u)),r("Non-trainable params: ".concat(c)),r("_".repeat(t))}function oC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function iC(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch($V){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch($V){r="multiple"}const o=e.name,i=e.getClassName();oC(["".concat(o," (").concat(i,")"),a,r,e.countParams().toString()],t,n)}function sC(e,t,n,r){let a,o;try{o=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch($V){o="multiple"}try{a=JSON.stringify(e.outputShape)}catch($V){a="multiple"}const i=[];for(const l of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(l)))for(let e=0;e<l.inboundLayers.length;++e){const t=l.inboundLayers[e].name,n=l.nodeIndices[e],r=l.tensorIndices[e];i.push("".concat(t,"[").concat(n,"][").concat(r,"]"))}const s=e.name,u=e.getClassName(),c=0===i.length?"":i[0];oC(["".concat(s," (").concat(u,")"),o,a,e.countParams().toString(),c],t,r);for(let l=1;l<i.length;++l)oC(["","","","",i[l]],t,r)}function uC(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function cC(e,t){if(null===e)return null;if("string"===typeof e)return vx(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];uC(t,a,r)?n.push(r):n.push(cC(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=vx(n);t[e]=cC(r,e)}}return t}}function lC(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return bx(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];uC(t,a,r)?n.push(r):n.push(lC(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],a=bx(n);t[a]="name"!==n&&"className"!==n||"string"!==typeof r?lC(r,n):r}return t}}const hC="4.22.0";class dC extends tk{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=Ox(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Sx(this.inputs).length!==this.inputs.length)throw new cx("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((e=>e.name))));Sx(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((e=>e.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;fx(0===t,"input layer has >1 nodes"),fx(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof rk))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(y," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},a={},o={},i=[],s=(e,t,n,r,a,u)=>{null!=r&&null!=a&&null!=u||(r=e.sourceLayer,a=e.nodeIndex,u=e.tensorIndex);const c=r.inboundNodes[a];if(-1!==n.indexOf(c))throw new ux("The tensor ".concat(e.name,' at layer "').concat(r.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(c))return;this.containerNodes.add(dC.nodeKey(r,a)),r.id in o||(o[r.id]=Object.keys(o).length),-1===n.indexOf(c)&&n.push(c);const l=c.inboundLayers.length;for(let o=0;o<l;o++){const e=c.inputTensors[o],r=c.inboundLayers[o],a=c.nodeIndices[o],i=c.tensorIndices[o];s(e,t,n,r,a,i)}for(t.push(c);n.indexOf(c)>=0;)n.splice(n.indexOf(c),1);i.push(c)},u=[],c=[];for(const y of this.outputs)s(y,u,c);const l=i.slice().reverse();for(const y of l){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const o=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,o),r[y.outboundLayer.id]=e,a[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){const a=y.inboundLayers[r],o=y.nodeIndices[r],i=a.inboundNodes[o],s=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,s),n[i.id]=i}}const h={};for(const y in t){const e=t[y];e in h||(h[e]=[]),h[e].push(n[y])}const d={};for(const y in r){const e=r[y];e in d||(d[e]=[]),d[e].push(a[y])}let p=Object.keys(d).map((e=>parseInt(e,10))).sort(Dx);this.layers=[];for(const y of p){const e=d[y];e.sort(((e,t)=>{const n=o[e.id],r=o[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof dC&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((e=>parseInt(e,10))).sort(Dx);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of h[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new ux("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(m));for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new ux('The name "'.concat(y,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new $w({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new cx("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const a=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const o=a?"".concat(t.name.split("/").slice(0,-1).join("/")+"/").concat(e):t.originalName;if(null!=n[o])throw new cx("Duplicate weight name: ".concat(o));n[o]=t,r++}const o=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])o.push([n[r],e[i]]);else if(t)throw new cx("Provided weight data has no target variable: ".concat(i));delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new cx("".concat(e.length," of ").concat(r," weights are not set: ")+"".concat(e))}Yw(o)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(hC),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=lC(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return hh((()=>{e=yx(e);const n=new ak;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return sk(this.outputs,n,t)}))}computeMask(e,t){return hh((()=>{let n;return e=yx(e),n=null==t?px(null,e.length):yx(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=Vw(e);if(t.length!==this.inputLayers.length)throw new cx("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Dx);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],a=t.nodeIndices[i],o=t.tensorIndices[i],s=n["".concat(e.name,"_").concat(a,"_").concat(o)];r.push(s)}const a=Vw(e.computeOutputShape(gx(r))),o=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n["".concat(e.name,"_").concat(o,"_").concat(t)]=a[t]}}}const a=[],o=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r="".concat(e.name,"_").concat(t,"_").concat(n);o.push(r)}for(let i=0;i<o.length;i++){const e=o[i];fx(e in n),a.push(n[e])}return gx(a)}runInternalGraph(e,t){null==t&&(t=px(null,e.length));const n={};for(let s=0;s<this.inputs.length;++s){const r=this.inputs[s],a=e[s],o=t[s];n[r.id]=[a,o]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Dx);for(const s of r){const e=this.nodesByDepth[s];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,o=new Array;for(const t of r)t.id in n&&o.push(n[t.id]);if(o.length===r.length){let r,i,s,u,c={};if(null!=t.callArgs&&(c=t.callArgs),1===o.length){const[t,n]=o[0];null==c.mask&&(c.mask=n),s=yx(e.call(t,c)),u=yx(e.computeMask(t,n)),r=[t],i=[n]}else r=o.map((e=>e[0])),i=o.map((e=>e[1])),null==c.mask&&(c.mask=i),s=yx(e.call(r,c)),u=yx(e.computeMask(r,i));if(e.activityRegularizer)throw new lx("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){const t=a[e],r=s[e],o=u[e];n[t.id]=[r,o]}}}}const a=[],o=[],i=[];for(const s of this.outputs){fx(s.id in n,"Could not compute output ".concat(s.name," : ").concat(s.id));const[e,t]=n[s.id];i.push(e.shape),a.push(e),o.push(t)}return[a,o,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof dC?1:0;for(let e=0;e<r.inboundNodes.length;e++){const a=dC.nodeKey(r,e);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new cx("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new cx("No such layer: ".concat(e))}findLayer(e){if(this.layers.length<=e)throw new cx("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}calculateLosses(){return hh((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=dC.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const o of this.layers){const e=o.getClassName(),r=o.getConfig(),a=[];for(let n=0;n<o.inboundNodes.length;n++){const e=o.inboundNodes[n],r=dC.nodeKey(o,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch($V){console.warn("Layer ".concat(o.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const a=e.inboundLayers[r],o=e.nodeIndices[r],s=e.tensorIndices[r];let u=t[dC.nodeKey(a,o)];null==u&&(u=0),n.push([a.name,u,s,i])}a.push(n)}}}const i={};i.name=o.name,i.className=e,i.config=r,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let o=0;o<this.inputLayers.length;o++){const e=this.inputLayers[o],n=this.inputLayersNodeIndices[o],a=dC.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let i=t[a];null!==i&&void 0!==i||(i=0);const s=this.inputLayersTensorIndices[o];r.push([e.name,i,s])}e.inputLayers=r;const a=[];for(let o=0;o<this.outputLayers.length;o++){const e=this.outputLayers[o],n=this.outputLayersNodeIndices[o],r=dC.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null!==i&&void 0!==i||(i=0);const s=this.outputLayersTensorIndices[o];a.push([e.name,i,s])}return e.outputLayers=a,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function o(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){const n=[];let a;for(const i of t){const s=i[0],u=i[1],c=i[2];if(a=null==i[3]?{}:i[3],!(s in r))return void o(e,t);const l=r[s];if(l.inboundNodes.length<=u)return void o(e,t);const h=l.inboundNodes[u];n.push(h.outputTensors[c])}n.length>0&&e.apply(gx(n),a)}function s(e){const a=e.name,i=_k(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[a]=i;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new cx("Corrupted configuration, expected array for nodeData: ".concat(e));o(i,e)}))}const u=t.name,c=t.layers;for(const f of c)s(f);for(;!Ex(a);)for(const e of c){const t=r[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)i(t,n)}}const l=[],h=[],d=t.inputLayers;for(const f of d){const e=f[0],t=f[1],n=f[2];fx(e in r);const a=r[e].inboundNodes[t].outputTensors;l.push(a[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];fx(e in r);const a=r[e].inboundNodes[t].outputTensors;h.push(a[n])}return new e({inputs:l,outputs:h,name:u})}get stateful(){if(this._stateful)throw new cx("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){hh((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function pC(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(r," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error("The model has multiple (".concat(r,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(r," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function fC(e,t){return pC(e,t,"classWeight")}async function mC(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=hh((()=>{if(1===e.shape.length)return ed(e);if(2===e.shape.length){if(e.shape[1]>1){return sp(e,1)}if(1===e.shape[1])return Cp(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),r=Array.from(await t.data());dh(t);const a=[];return r.forEach((e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");a.push(n[e])})),nm(a,"float32")}return null}function gC(e,t){return ad(e,t)}function yC(e,t){let n,r;const a=t;n=a.xs,r=a.ys,Wo(null!=n&&null!=r,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t)));const o=bC("input",e.inputNames,n),i=bC("output",e.outputNames,r),s=o[0].shape[0];Wo(o.length===e.inputs.length,(()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(o.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")"))),Wo(i.length===e.outputs.length,(()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(i.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")")));for(let u=0;u<o.length;u++)Wo(o[u].shape[0]===s,(()=>"Batch size mismatch: input "+"".concat(e.inputNames[u]," has ").concat(o[u].shape[0],"; ")+"expected  ".concat(s," based on input ").concat(e.inputNames[0],".")));for(let u=0;u<i.length;u++)Wo(i[u].shape[0]===s,(()=>"Batch size mismatch: output "+"".concat(e.outputNames[u]," has ").concat(i[u].shape[0],"; ")+"expected  ".concat(s," based on input ").concat(e.inputNames[0],".")));return{xs:o,ys:i}}function bC(e,t,n){if(n instanceof El)return[n];if(Array.isArray(n))return Wo(n.length===t.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,"."))),n;{const r=[];for(const a of t){if(null==n[a])throw new cx("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(a,"'."));r.push(n[a])}return r}}async function vC(e,t,n){const r=null!=n.batchesPerEpoch;if(Wo(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Wo(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Wo(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),Wo(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),Wo(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const a=null!=n.validationData;let o,i;if(a)if(xC(n.validationData))Wo(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const e=function(e){if(3===e.length)throw new lx("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);o=e.xs,i=e.ys}const s=e.makeTrainFunction(),u=e.getDedupedMetricsNames();let c;c=a?u.slice().concat(u.map((e=>"val_"+e))):u.slice();const l=Tk(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Fk(l,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,a,c);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const c={};await d.onEpochBegin(f);let l=0,h=0;for(r||(m=await t.iterator());!r||l<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(l," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:a}=yC(e,t.value),o={};o.batch=h,o.size=r[0].shape[0],await d.onBatchBegin(h,o);const i=[];if(null!=n.classWeight){const t=fC(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await mC(a[e],null,t[e]))}const c=r.concat(a).concat(i),p=s(c);dh(c);for(let e=0;e<u.length;++e){const t=u[e],n=p[e];o[t]=n,ph(n)}await d.onBatchEnd(h,o),kk(o),h++,l++}if(r?l>=n.batchesPerEpoch:t.done){if(a){let t;t=xC(n.validationData)?yx(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):yx(e.evaluate(o,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)c["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,c),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function xC(e){return"function"===typeof e.iterator}function wC(e){Wo(e>0&&Number.isInteger(e),(()=>"batchSize is required to be a positive integer, but got ".concat(e)))}function kC(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>ow(e,t,n-t))):ow(e,t,n-t)}function CC(e,t){return hh((()=>null==e?null:Array.isArray(e)?e.map((e=>CC(e,t))):pw(e,"int32"===t.dtype?t:$h(t,"int32"))))}function DC(e,t){const n=[];let r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function SC(e){const t=[];e instanceof El&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(aw(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function EC(e,t){if(null==e)return;const n=[];if(t instanceof El)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const a in t){const e=t[a];n.push(e.id)}const r=[];if(e instanceof El)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const a in e){const t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function IC(e){return Array.isArray(e)}function NC(e){return!function(e){return e instanceof El}(e)&&!IC(e)}function TC(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(IC(e)&&e.length>0)t=!0;else if(NC(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new cx("Error when checking model ".concat(o," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map((e=>null));if(NC(e)){r=[];for(const n of t){if(null==e[n])throw new cx('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));r.push(e[n])}}else if(IC(e)){if(e.length!==t.length)throw new cx("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));r=e}else{if(t.length>1)throw new cx("The model ".concat(o," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));r=[e]}if(r=SC(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new cx("Error when checking ".concat(o,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[i].length;++t){if(0===t&&!a)continue;const r=e.shape[t],s=n[i][t];if(null!=s&&s>=0&&r!==s)throw new cx("".concat(o," expected a batch of elements where each ")+"example has shape [".concat(n[i].slice(1,n[i].length),"] ")+"(i.e.,tensor shape [*,".concat(n[i].slice(1,n[i].length),"])")+" but the ".concat(o," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return r}function AC(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new cx("Error when checking model ".concat(o,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));r=e}else{if(t.length>1)throw new cx("The model expects ".concat(t.length," ").concat(o," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new cx("Error when checking ".concat(o,": expected ").concat(t[i]," ")+"to have ".concat(n[i].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let r=0;r<n[i].length;++r){if(0===r&&!a)continue;const s=e.shape[r],u=n[i][r];if(null!=u&&u!==s)throw new cx("Error when checking ".concat(o,": expected ")+"".concat(t[i]," to have shape ").concat(JSON.stringify(n[i])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class FC extends dC{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new cx("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");aC(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>dg.adagrad(.01),Adadelta:()=>dg.adadelta(1,.95,nw()),Adam:()=>dg.adam(.001,.9,.999,nw()),Adamax:()=>dg.adamax(.002,.9,.999,nw(),0),RMSProp:()=>dg.rmsprop(.001,.9,0,nw()),SGD:()=>dg.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new cx("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof md))throw new cx("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new cx("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map((e=>jk(e)))}else{const n=jk(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new cx('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(jk(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const e=this.internalOutputShapes[o],t=this.outputNames[o];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[o])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],qx("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};qx("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,o;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let a;1===t[t.length-1]||this.lossFunctions[e]===Wk?-1!==["accuracy","acc"].indexOf(i)?r=Hk:-1!==["crossentropy","ce"].indexOf(i)&&(r=Xk):this.lossFunctions[e]===Pk?-1!==["accuracy","acc"].indexOf(i)?r=Yk:-1!==["crossentropy","ce"].indexOf(i)&&(r=Zk):-1!==["accuracy","acc"].indexOf(i)?r=qk:-1!==["crossentropy","ce"].indexOf(i)&&(r=Qk),-1!==["accuracy","acc"].indexOf(i)?a="acc":-1!==["crossentropy","ce"].indexOf(i)&&(a="ce"),o=r,n=""+a}else{const e=$k(i);o=e,n=""+eC(i)}let t;qx(n,(()=>{t=o})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;wC(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const e=a[0].concat(a[1]);this.makeTestFunction();const t=this.testFunction;return gx(this.testLoop(t,e,r,n.verbose,n.steps))}finally{EC(a[0],e),EC(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,a=e.testFunction;let o=[];if(n.verbose>0)throw new lx("Verbose mode is not implemented yet.");Wo(!r||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const i="function"===typeof t.next?t:await t.iterator();let s=0,u=0;for(;!r||u<n.batches;){const t=await i.next();if(o=hh((()=>{if(t.value){const{xs:n,ys:r}=yC(e,t.value),i=n.concat(r),c=hh((()=>a(i)));if(dh(i),0===u)for(let e=0;e<c.length;++e)o.push(cd(0));const l=i[0].shape[0];for(let e=0;e<c.length;++e){const t=c[e],n=o[e];o[e]=hh((()=>td(o[e],ad(l,t)))),u>0&&dh(n)}dh(c),s+=l,++u}return o})),t.done){r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let c=0;c<o.length;++c){const e=o[c];o[c]=rd(o[c],s),dh(e)}return gx(o)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new cx("If ".concat(a," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new cx("Either the input data should have a defined shape, or "+"".concat(a," shoud be specified."));r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new cx("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),o=new ak;if(e instanceof El&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new cx("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)o.add(this.inputs[t],e[t])}else for(const s of this.inputs){const t=e[s.name];if(null==t)throw new cx("No value is provided for the model's input ".concat(s.name));o.add(s,t)}const i=sk(a,o);return n?i:i[0]}retrieveSymbolicTensors(e){const t=px(null,e.length);let n=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],o=a.map((e=>e.name));for(let r=0;r<e.length;++r){const i=o.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new cx("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return hh((()=>{const r=this.checkNumSamples(e);if(n)throw new lx("Verbose predictLoop() is not implemented yet.");const a=DC(r,t),o=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t){const n=hh((()=>{const n=a[t][0],r=a[t][1],o=kC(e,n,r),i=[];if(Array.isArray(o))for(let e=0;e<o.length;++e)i.push({key:this.inputs[e],value:o[e]});else i.push({key:this.inputs[0],value:o});const s=new ak(i);return sk(this.outputs,s)}));n.forEach(((e,t)=>o[t].push(e)))}return gx(o.map((e=>_p(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=SC(e);AC(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return wC(e),this.predictLoop(n,e)}finally{EC(n,e)}}predictOnBatch(e){AC(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new ux("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];this.feedLossFns[a]===Pk?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){const n=Sx(e.map((e=>e.shape[0])));n.sort();const r=Sx(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new cx("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((e=>e.shape)))));if(r.length>1)throw new cx("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((e=>e.shape)))));if(n.length>0&&r.length>0&&!jo(n,r))throw new cx("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(n[0]," input sample(s) and ").concat(r[0]," target ")+"sample(s).")}(e=TC(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=TC(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const r=[Mk,Wk,Bk];for(let a=0;a<e.length;++a){const o=e[a],i=t[a],s=n[a];if(null!=i){if(i===Bk&&1===o.shape[o.shape.length-1])throw new cx("You are passing a target array of shape ".concat(o.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==r.indexOf(i)){const e=o.shape.slice(1),t=s.slice(1);for(let n=0;n<e.length;++n){const r=e[n],a=t[n];if(null!=a&&r!==a)throw new cx("A target Tensor with shape ".concat(o.shape," was passed for an ")+"output of shape ".concat(s,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new cx("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=arguments.length>5?arguments[5]:void 0;const[i,s]=this.standardizeUserDataXY(e,t,a,o);if(null!=n)throw new Error("sample weight is not supported yet.");let u=null;if(null!=r){const e=fC(r,this.outputNames);u=[];for(let t=0;t<e.length;++t)u.push(await mC(s[t],null,e[t]))}return[i,s,u]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return hh((()=>{const o=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new lx("Verbose mode is not implemented yet.");if(null!=a)throw new lx("steps mode in testLoop() is not implemented yet");{const r=DC(o,n),a=nm(ew(0,o));for(let n=0;n<r.length;++n){const o=r[n][0],s=r[n][1],u=ow(a,o,s-o),c=CC(t,u),l=e(c);if(0===n)for(let e=0;e<l.length;++e)i.push(cd(0));for(let e=0;e<l.length;++e){const t=l[e];i[e]=td(i[e],ad(s-o,t))}}for(let e=0;e<i.length;++e)i[e]=rd(i[e],o)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let a=r;if(mx(e,r)>1){const t=mx(e.slice(0,n),r);a+="_".concat(t)}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),o=[],i=this.collectedTrainableWeights.map((e=>e.read())),s=this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new ak(e),s=sk(this.outputs,i,{training:!0});let u;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],s[n]);null!=a[n]&&(e=gC(e,a[n]));const o=Cf(e);t.push(o),u=0===n?e:td(u,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=Cf(t(r[a],s[a]))}ph(e),o.push(e)}return u=Cf(u),this.calculateLosses().forEach((e=>{u=td(u,e)})),u}),!0,i);return[s].concat(o)}}makeTestFunction(){this.testFunction=e=>hh((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let e=0;e<this.inputs.length;++e)o.push({key:this.inputs[e],value:r[e]});const i=new ak(o),s=sk(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],o=Cf(r(a[e],s[e]));n=0===e?o:td(n,o),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],o=Cf(n(a[r],s[r]));t.push(o)}return t}))}async fit(e,t){let n,r,a,o,i,s,u,c,l,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;wC(d);const p=!1,f=await this.standardizeUserData(e,t,h.sampleWeight,h.classWeight,p,d);n=f[0],r=f[1],l=f[2];let m,g=!1;if(null!=h.validationData&&h.validationData.length>0){if(g=!0,2!==h.validationData.length)throw 3===h.validationData.length?new lx("validationData including sample weights is not supported yet."):new cx("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(h.validationData," is invalid."));i=h.validationData[0],s=h.validationData[1];const e=!0,t=await this.standardizeUserData(i,s,null,null,e,d);u=t[0],c=t[1],m=u.concat(c)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-h.validationSplit)),t=n[0].shape[0];u=kC(n,e,t),a=n,n=kC(n,0,e),c=kC(r,e,t),o=r,r=kC(r,0,e),m=u.concat(c)}else null!=h.validationSteps&&(g=!0);const y=n.concat(r).concat(l);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;g?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((e=>"val_"+e)))):(x=null,m=[],w=v.slice());const k=Tk(h.callbacks,h.yieldEvery);return await this.fitLoop(b,y,v,d,h.epochs,h.verbose,k,x,m,h.shuffle,w,h.initialEpoch,null,null)}finally{this.isTraining=!1,EC(n,e),EC(r,t),EC(a,e),EC(o,t),EC(u,i),EC(c,s),null!=l&&dh(l)}}async fitLoop(e,t,n,r,a,o,i,s,u,c,l,h,d,p){null==r&&(r=32),null==a&&(a=1),null==c&&(c=!0),null==h&&(h=0);let f=!1;if(null!=s&&null!=u&&(f=!0),null!=p&&(f=!0,null==d))throw new cx("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,d,"steps_per_epoch");let g;null!=m&&(g=ew(0,m)),null==o&&(o=1);const{callbackList:y,history:b}=Fk(i,o,a,h,m,d,r,f,l);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=h;v<a;++v){await y.onEpochBegin(v);const a={};if(null!=d)throw new lx("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new lx("batch shuffling is not implemneted yet");c&&zo(g);const o=nm(g),i=DC(m,r);for(let c=0;c<i.length;++c){const l={};if(await y.onBatchBegin(c,l),hh((()=>{const h=i[c][0],d=i[c][1],p=ow(o,h,d-h);l.batch=c,l.size=d-h;const m=CC(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];l[t]=r,ph(r)}if(c===i.length-1&&f){const e=this.testLoop(s,u,r);for(let t=0;t<n.length;++t){const r=n[t],o=e[t];ph(o),a["val_"+r]=o}}})),await y.onBatchEnd(c,l),kk(l),this.stopTraining_)break}o.dispose()}if(await y.onEpochEnd(v,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return vC(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],a=n[1],o=this.makeTrainFunction()(r.concat(a)),i=[];for(const s of o){const e=await s.data();i.push(e[0])}return dh(o),EC(n[0],e),EC(n[1],t),gx(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let o=0;o<r.length;++o)n&&!r[o].trainable||t.push({name:r[o].originalName,tensor:a[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=lh().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-lh().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=bx(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>bx(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=bx(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[bx(eC(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>bx(eC(e))));{const e={};for(const t in this.metrics)e[t]=bx(eC(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=_k(cC(e.optimizer_config));let n,r;if("string"===typeof e.loss)n=vx(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>vx(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=vx(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>vx(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=vx(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"===typeof e){const t=(n=e,Dh.getSaveHandlers(n));if(0===t.length)throw new cx("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new cx("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}var n;if(null==e.save)throw new cx("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await gh(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(hC),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await gh(await this.optimizer.getWeights(),e);r.specs.push(...n),r.data=(o=[r.data,t],uh.join(o))}var o;if(null!=this.userDefinedMetadata){const e=!0;nC(this.userDefinedMetadata,this.name,e),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)}setUserDefinedMetadata(e){nC(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}FC.className="Model",fd(FC);class _C extends FC{}_C.className="Functional",fd(_C);class RC extends FC{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Ox("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new cx("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof RC||e instanceof FC;let n;if(t){if(n=e,1!==n.outputs.length)throw new cx("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new cx("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new cx("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new cx("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new rk({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new cx("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new cx("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=nk(this.outputs[0])}this.inboundNodes=[],new $w({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:px(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(jw(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new FC({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new ux("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new ux("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new ux("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new ux("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new cx("Legacy serialization format not supported yet.");n=t}else Wo(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof RC))throw new lx("Sequential.fromConfig called on non-Sequential input: ".concat(o));for(const i of n){const e=_k(i,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),o.add(e)}return o}set stopTraining(e){if(null==this.model)throw new cx("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new cx("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}RC.className="Sequential",fd(RC);class MC extends dd{getConfig(){return{}}}class OC extends MC{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new lx("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return qp(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}OC.className="elu",fd(OC);class zC extends MC{apply(e){return Vf(e)}}zC.className="selu",fd(zC);class LC extends MC{apply(e){return Wf(e)}}LC.className="relu",fd(LC);class BC extends MC{apply(e){return hh((()=>Sf(6,Wf(e))))}}BC.className="relu6",fd(BC);class PC extends MC{apply(e){return e}}PC.className="linear",fd(PC);class WC extends MC{apply(e){return jf(e)}}WC.className="sigmoid",fd(WC);class UC extends MC{apply(e){return function(e){return hh((()=>{const t=td(.5,ad(.2,e));return Fp(t,0,1)}))}(e)}}UC.className="hardSigmoid",fd(UC);class VC extends MC{apply(e){return Zf(e)}}VC.className="softplus",fd(VC);class GC extends MC{apply(e){return function(e){return hh((()=>rd(e,td(kd(e),1))))}(e)}}GC.className="softsign",fd(GC);class jC extends MC{apply(e){return tm(e)}}jC.className="tanh",fd(jC);class HC extends MC{apply(e){return Qf(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}HC.className="softmax",fd(HC);class qC extends MC{apply(e){return cf(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}qC.className="logSoftmax",fd(qC);class KC extends MC{apply(e){return hh((()=>hh((()=>{const t=Math.sqrt(2),n=ad(.5,td(1,Xp(rd(e,t))));return ad(e,n)}))))}}KC.className="gelu",fd(KC);class XC extends MC{apply(e){return hh((()=>ad(.5,ad(e,td(1,tm(ad(od(rd(2,Math.PI)),td(e,ad(.044715,vd(e,3))))))))))}}XC.className="gelu_new",fd(XC);class YC extends MC{apply(e){return hh((()=>ad(e,tm(Zf(e)))))}}YC.className="mish",fd(YC);class QC extends MC{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return hh((()=>ad(jf(ad(e,t)),e)))}}function ZC(e){return e.getClassName()}function JC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Cx(e,pd.getMap().classNameMap,t,"activation")}function $C(e){if(null==e){const e={className:"linear",config:{}};return JC(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},JC(t)}return e instanceof MC?e:JC(e)}function eD(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}QC.className="swish",fd(QC);class tD extends dd{}class nD extends tD{constructor(e){super(),eD(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return hh((()=>{let t=Af([1]);return this.hasL1&&(t=td(t,uf(ad(this.l1,kd(e))))),this.hasL2&&(t=td(t,uf(ad(this.l2,fw(e))))),Cp(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}nD.className="L1L2",fd(nD);const rD={l1l2:"L1L2"};function aD(e){return wx(e)}function oD(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Cx(e,pd.getMap().classNameMap,t,"regularizer")}function iD(e){if(null==e)return null;if("string"===typeof e){return oD({className:e in rD?rD[e]:e,config:{}})}return e instanceof tD?e:oD(e)}class sD extends tk{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Gw(e);let n=Wf(e);return null!=this.maxValue&&(n=Fp(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}sD.className="ReLU",fd(sD);class uD extends tk{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Gw(e);return rf(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}uD.className="LeakyReLU",fd(uD);class cD extends tk{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Ww(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=iD(e.alphaRegularizer),this.alphaConstraint=xk(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new cx("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=jw(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Qw({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Gw(e),Mf(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Pw(this.alphaInitializer),alphaRegularizer:aD(this.alphaRegularizer),alphaConstraint:bk(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}cD.className="PReLU",fd(cD);class lD extends tk{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new lx("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Gw(e);return qp(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}lD.className="ELU",fd(lD);class hD extends tk{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=Gw(e);return ad(n,$h(tf(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}hD.className="ThresholdedReLU",fd(hD);class dD extends tk{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new HC).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return hh((()=>{let n=Gw(e);const r=t.mask;if(null!=r){const e=ad(xd(Ff(n.shape),$h(r,n.dtype)),cd(-1e9));n=td(n,e)}return this.axis instanceof Array?this.axis.length>1?Yp(xd(n,bf(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function pD(e,t,n){if("number"===typeof e)return px(e,t);if(e.length!==t)throw new cx("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let a=0;a<t;++a){const o=e[a];if((r=o)!==parseInt(r.toString(),10))throw new cx("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(o))}return e;var r}function fD(e,t,n,r){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function mD(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+$x([n-t,0]);else{if("same"!==r)throw new cx("Unsupport padding mode: ".concat(r,"."));e*=t}return e}function gD(e,t){return hh((()=>(Vx(t),"channelsFirst"===t?cm(e,[0,2,3,1]):e)))}function yD(e,t){return hh((()=>(Vx(t),"channelsFirst"===t?cm(e,[0,2,3,4,1]):e)))}function bD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return hh((()=>{if(null==o&&(o="channelsLast"),Vx(o),3!==e.shape.length)throw new cx("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new cx("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new cx("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(n.shape.length," instead"));if("channelsFirst"===o&&(e=cm(e,[0,2,1])),"causal"===a)throw new lx("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let s=Bp(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(s=gw(s,n)),s}))}function vD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return hh((()=>{if(null==o&&(o="channelsLast"),Vx(o),3!==e.rank&&4!==e.rank)throw new cx("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new cx("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let u=gD(e,o);if("causal"===a)throw new lx("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=km({x:u,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:s}),"channelsFirst"===o&&(u=cm(u,[0,3,1,2])),u}))}function xD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",o=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return hh((()=>{if(null==o&&(o="channelsLast"),Vx(o),4!==e.rank&&5!==e.rank)throw new cx("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new cx("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let s=yD(e,o);if("causal"===a)throw new lx("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return s=Up(s,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(s=gw(s,n)),"channelsFirst"===o&&(s=cm(s,[0,4,1,2,3])),s}))}dD.className="Softmax",fd(dD);class wD extends tk{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",wD.verifyArgs(t),this.rank=e,Tx(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new lx("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=pD(t.kernelSize,e,"kernelSize"),this.strides=pD(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,Gx(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Vx(this.dataFormat),this.activation=$C(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=Ww(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=xk(t.biasConstraint),this.biasRegularizer=iD(t.biasRegularizer),this.activityRegularizer=iD(t.activityRegularizer),this.dilationRate=pD(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new cx("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new cx("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new cx("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(fx("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!Nx(e.kernelSize,"number",1,3))throw new cx("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ZC(this.activation),useBias:this.useBias,biasInitializer:Pw(this.biasInitializer),biasRegularizer:aD(this.biasRegularizer),activityRegularizer:aD(this.activityRegularizer),biasConstraint:bk(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class kD extends wD{constructor(e,t){super(e,t),this.kernel=null,kD.verifyArgs(t),this.filters=t.filters,Tx(this.filters,"filters"),this.kernelInitializer=Ww(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=xk(t.kernelConstraint),this.kernelRegularizer=iD(t.kernelRegularizer)}build(e){e=jw(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new cx("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return hh((()=>{let t;e=Gw(e);const n=null==this.bias?null:this.bias.read(),r=Fx(this.activation.getClassName());if(null!=r&&2===this.rank)t=vD(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=bD(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=vD(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new lx("convolutions greater than 3D are not implemented yet.");t=xD(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=jw(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){const e=fD(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Pw(this.kernelInitializer),kernelRegularizer:aD(this.kernelRegularizer),kernelConstraint:bk(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new cx("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class CD extends kD{constructor(e){super(2,e),CD.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!Nx(e.kernelSize,"number",1,2))throw new cx("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}CD.className="Conv2D",fd(CD);class DD extends kD{constructor(e){super(3,e),DD.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new cx("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}DD.className="Conv3D",fd(DD);class SD extends CD{constructor(e){if(super(e),this.inputSpec=[new Qw({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new cx("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=jw(e)).length)throw new cx("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new cx("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qw({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return hh((()=>{let t=Gw(e);if(4!==t.shape.length)throw new cx("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,r=n[0];let a,o;"channelsFirst"===this.dataFormat?(a=2,o=3):(a=1,o=2);const i=n[a],s=n[o],u=this.kernelSize[0],c=this.kernelSize[1],l=this.strides[0],h=this.strides[1],d=[r,mD(i,l,u,this.padding),mD(s,h,c,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=cm(t,[0,2,3,1]));let p=Wp(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=cm(p,[0,3,1,2])),null!=this.bias&&(p=gw(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=jw(e)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const o=this.kernelSize[0],i=this.kernelSize[1],s=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[r]=mD(t[r],s,o,this.padding),t[a]=mD(t[a],u,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}SD.className="Conv2DTranspose",fd(SD);class ED extends DD{constructor(e){if(super(e),this.inputSpec=[new Qw({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new cx("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=jw(e)).length)throw new cx("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new cx("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qw({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return hh((()=>{let t=Gw(e);if(5!==t.shape.length)throw new cx("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,r=n[0];let a,o,i;"channelsFirst"===this.dataFormat?(i=2,a=3,o=4):(i=1,a=2,o=3);const s=n[i],u=n[a],c=n[o],l=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,mD(s,p,l,this.padding),mD(u,f,h,this.padding),mD(c,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=cm(t,[0,2,3,4,1]));let y=Gp(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=cm(y,[0,4,1,2,3])),null!==this.bias&&(y=gw(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=jw(e)).slice();let n,r,a,o;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,o=4):(n=4,r=1,a=2,o=3);const i=this.kernelSize[0],s=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],l=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=mD(t[r],c,i,this.padding),t[a]=mD(t[a],l,s,this.padding),t[o]=mD(t[o],h,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}ED.className="Conv3DTranspose",fd(ED);class ID extends kD{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new cx("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new cx("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new cx("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Ww(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=iD(t.depthwiseRegularizer),this.depthwiseConstraint=xk(t.depthwiseConstraint),this.pointwiseInitializer=Ww(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=iD(t.pointwiseRegularizer),this.pointwiseConstraint=xk(t.pointwiseConstraint)}build(e){if((e=jw(e)).length<this.rank+2)throw new cx("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new cx("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Qw({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return hh((()=>{let t;if(e=Gw(e),1===this.rank)throw new lx("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=cm(e,[0,2,3,1])),t=Gf(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=gw(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=cm(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Pw(this.depthwiseInitializer),e.pointwiseInitializer=Pw(this.pointwiseInitializer),e.depthwiseRegularizer=aD(this.depthwiseRegularizer),e.pointwiseRegularizer=aD(this.pointwiseRegularizer),e.depthwiseConstraint=bk(this.depthwiseConstraint),e.pointwiseConstraint=bk(this.pointwiseConstraint),e}}ID.className="SeparableConv";class ND extends ID{constructor(e){super(2,e)}}ND.className="SeparableConv2D",fd(ND);class TD extends kD{constructor(e){super(1,e),TD.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!Nx(e.kernelSize,"number",1,1))throw new cx("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}TD.className="Conv1D",fd(TD);class AD extends tk{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return hh((()=>{if(e=Gw(e),"channelsLast"===this.dataFormat){const t=sw(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return sw(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=sw(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return sw(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}AD.className="Cropping2D",fd(AD);class FD extends tk{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Vx(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,Ix(Lx,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return hh((()=>{let t=Gw(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=cm(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?lg.resizeNearestNeighbor(t,[e,r]):lg.resizeBilinear(t,[e,r]);return cm(a,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?lg.resizeNearestNeighbor(t,[e,r]):lg.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}FD.className="UpSampling2D",fd(FD);class _D extends wD{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Ww(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=xk(e.depthwiseConstraint),this.depthwiseRegularizer=iD(e.depthwiseRegularizer)}build(e){if((e=jw(e)).length<4)throw new cx("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new cx("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return hh((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0;return hh((()=>{null==a&&(a="channelsLast"),Vx(a);let i=gD(e,a);if(4!==e.rank)throw new cx("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new cx("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return i=Hp(i,t,n,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===a&&(i=cm(i,[0,3,1,2])),i}))}(e=Gw(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=gw(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=jw(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=fD(t,this.kernelSize[0],this.padding,this.strides[0]),o=fD(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,o]:[e[0],a,o,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Pw(this.depthwiseInitializer),e.depthwiseRegularizer=aD(this.depthwiseRegularizer),e.depthwiseConstraint=bk(this.depthwiseRegularizer),e}}function RD(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new cx("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function MD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return hh((()=>{const u=t.shape.length;if(u<3)throw new cx("Input should be at least 3D, but is ".concat(u,"D."));const c=[1,0].concat(ew(2,u));if(t=cm(t,c),null!=o)throw new lx("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=$h($h(a,"bool"),"float32"),a.rank===u-1&&(a=Qp(a,-1)),a=cm(a,c)),r&&(t=Uf(t,0),null!=a&&(a=Uf(a,0)));const l=[];let h,d=n;const p=t.shape[0],f=om(t);let m,g;null!=a&&(m=om(a));for(let t=0;t<p;++t){const n=f[t],r=hh((()=>e(n,d)));if(null==a)h=r[0],d=r[1];else{const e=hh((()=>{const e=m[t],n=xd(_f(e),e),a=td(ad(r[0],e),ad(d[0],n)),o=d.map(((t,a)=>td(ad(r[1][a],e),ad(t,n))));return{output:a,newStates:o}}));h=e.output,d=e.newStates}s&&l.push(h)}if(s){g=em(l,1)}return[h,g,d]}))}_D.className="DepthwiseConv2D",fd(_D);class OD extends tk{constructor(e){let t;if(super(e),null==e.cell)throw new cx("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new GD({cells:e.cell}):e.cell,null==t.stateSize)throw new cx("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Qw({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return ew(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Uw(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return hh((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new lx("Constants support is not implemented in RNN yet.");Uw(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Qw({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!jo(this.stateSpec.map((e=>e.shape[e.shape.length-1])),a))throw new cx("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=a.map((e=>new Qw({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];hh((()=>{if(!this.stateful)throw new sx("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new cx("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Af([n,e]))):this.states_=[Af([n,this.cell.stateSize])];else if(null==e)dh(this.states_),null!=this.keptStates&&(dh(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>Af([n,e]))):this.states_[0]=Af([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new cx("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):dh(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,o=[n,a];if(!jo(r.shape,o))throw new cx("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(o,", received shape=").concat(r.shape));this.states_[t]=r}}this.states_=this.states_.map((e=>ph(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=RD(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let o=[],i=[];if(null!=n){t.initialState=n,o=o.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Qw({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,o=o.concat(r),this.numConstants=r.length);if(o[0]instanceof Zw){const n=[e].concat(o),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const s=super.apply(n,t);return this.inputSpec=a,s}return super.apply(e,t)}call(e,t){return hh((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let a=null==t?null:t.initialState;e=Gw(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==o)throw new cx("RNN Layer has ".concat(o," state(s) but was passed ")+"".concat(a.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},s=MD(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),u=s[0],c=s[1],l=s[2];this.stateful&&this.resetStates(l,r);const h=this.returnSequences?c:u;return this.returnState?[h].concat(l):h}))}getInitialState(e){return hh((()=>{let t=Af(e.shape);return t=uf(t,[1,2]),t=aw(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?lw(t,[1,e]):t)):this.cell.stateSize>1?[lw(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===OD.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=_k(t.cell,n);return new e(Object.assign(t,{cell:r}))}}OD.className="RNN",fd(OD);class zD extends tk{}class LD extends zD{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Tx(this.units,"units"),this.activation=$C(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Ww(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ww(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ww(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=iD(e.kernelRegularizer),this.recurrentRegularizer=iD(e.recurrentRegularizer),this.biasRegularizer=iD(e.biasRegularizer),this.kernelConstraint=xk(e.kernelConstraint),this.recurrentConstraint=xk(e.recurrentConstraint),this.biasConstraint=xk(e.biasConstraint),this.dropout=Jx([1,$x([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Jx([1,$x([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=jw(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return hh((()=>{if(2!==e.length)throw new cx("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const r=null!=t.training&&t.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=jD({ones:()=>_f(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=jD({ones:()=>_f(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=this.recurrentDropoutMask;a=dw(null!=o?ad(e,o):e,this.kernel.read()),null!=this.bias&&(a=gw(a,this.bias.read())),null!=i&&(n=ad(n,i));let s=td(a,dw(n,this.recurrentKernel.read()));return null!=this.activation&&(s=this.activation.apply(s)),[s,s]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ZC(this.activation),useBias:this.useBias,kernelInitializer:Pw(this.kernelInitializer),recurrentInitializer:Pw(this.recurrentInitializer),biasInitializer:Pw(this.biasInitializer),kernelRegularizer:aD(this.kernelRegularizer),recurrentRegularizer:aD(this.recurrentRegularizer),biasRegularizer:aD(this.biasRegularizer),activityRegularizer:aD(this.activityRegularizer),kernelConstraint:bk(this.kernelConstraint),recurrentConstraint:bk(this.recurrentConstraint),biasConstraint:bk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}LD.className="SimpleRNNCell",fd(LD);class BD extends OD{constructor(e){e.cell=new LD(e),super(e)}call(e,t){return hh((()=>{null!=this.cell.dropoutMask&&(dh(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dh(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}}BD.className="SimpleRNN",fd(BD);class PD extends zD{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new cx("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Tx(this.units,"units"),this.activation=$C(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=$C(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Ww(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ww(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ww(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=iD(e.kernelRegularizer),this.recurrentRegularizer=iD(e.recurrentRegularizer),this.biasRegularizer=iD(e.biasRegularizer),this.kernelConstraint=xk(e.kernelConstraint),this.recurrentConstraint=xk(e.recurrentConstraint),this.biasConstraint=xk(e.biasConstraint),this.dropout=Jx([1,$x([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Jx([1,$x([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=jw(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return hh((()=>{if(2!==e.length)throw new cx("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=jD({ones:()=>_f(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=jD({ones:()=>_f(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let i,s,u;0<this.dropout&&this.dropout<1&&(e=ad(e,a[0]));let c=dw(e,this.kernel.read());this.useBias&&(c=gw(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ad(r,o[0]));const l=this.recurrentKernel.read(),[h,d]=Jf(l,[2*this.units,this.units],l.rank-1),p=dw(r,h),[f,m,g]=Jf(c,3,c.rank-1),[y,b]=Jf(p,2,p.rank-1);i=this.recurrentActivation.apply(td(f,y)),s=this.recurrentActivation.apply(td(m,b));const v=dw(ad(s,r),d);u=this.activation.apply(td(g,v));const x=td(ad(i,r),ad(td(1,If(i)),u));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ZC(this.activation),recurrentActivation:ZC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Pw(this.kernelInitializer),recurrentInitializer:Pw(this.recurrentInitializer),biasInitializer:Pw(this.biasInitializer),kernelRegularizer:aD(this.kernelRegularizer),recurrentRegularizer:aD(this.recurrentRegularizer),biasRegularizer:aD(this.biasRegularizer),activityRegularizer:aD(this.activityRegularizer),kernelConstraint:bk(this.kernelConstraint),recurrentConstraint:bk(this.recurrentConstraint),biasConstraint:bk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}PD.className="GRUCell",fd(PD);class WD extends OD{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new PD(e),super(e)}call(e,t){return hh((()=>{null!=this.cell.dropoutMask&&(dh(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dh(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}WD.className="GRU",fd(WD);class UD extends zD{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Tx(this.units,"units"),this.activation=$C(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=$C(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Ww(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ww(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ww(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=iD(e.kernelRegularizer),this.recurrentRegularizer=iD(e.recurrentRegularizer),this.biasRegularizer=iD(e.biasRegularizer),this.kernelConstraint=xk(e.kernelConstraint),this.recurrentConstraint=xk(e.recurrentConstraint),this.biasConstraint=xk(e.biasConstraint),this.dropout=Jx([1,$x([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Jx([1,$x([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=jw(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends ww{apply(t,r){const a=e.apply([n]),o=(new Cw).apply([n]),i=e.apply([2*n]);return cw(cw(a,o),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return hh((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new cx("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=jD({ones:()=>_f(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=jD({ones:()=>_f(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=this.recurrentDropoutMask;let s,u,c,l;0<this.dropout&&this.dropout<1&&(e=ad(e,o[0]));let h=dw(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=ad(r,i[0])),h=td(h,dw(r,this.recurrentKernel.read())),this.useBias&&(h=gw(h,this.bias.read()));const[d,p,f,m]=Jf(h,4,h.rank-1);s=this.recurrentActivation.apply(d),u=this.recurrentActivation.apply(p),c=td(ad(u,a),ad(s,this.activation.apply(f))),l=this.recurrentActivation.apply(m);const g=ad(l,this.activation.apply(c));return[g,g,c]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ZC(this.activation),recurrentActivation:ZC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Pw(this.kernelInitializer),recurrentInitializer:Pw(this.recurrentInitializer),biasInitializer:Pw(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:aD(this.kernelRegularizer),recurrentRegularizer:aD(this.recurrentRegularizer),biasRegularizer:aD(this.biasRegularizer),activityRegularizer:aD(this.activityRegularizer),kernelConstraint:bk(this.kernelConstraint),recurrentConstraint:bk(this.recurrentConstraint),biasConstraint:bk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}UD.className="LSTMCell",fd(UD);class VD extends OD{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new UD(e),super(e)}call(e,t){return hh((()=>{null!=this.cell.dropoutMask&&(dh(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dh(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}VD.className="LSTM",fd(VD);class GD extends zD{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return hh((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let o;for(let i=0;i<this.cells.length;++i){const s=this.cells[i];n=r[i],o=0===i?[e[0]].concat(n):[o[0]].concat(n),o=s.call(o,t),a.push(o.slice(1))}n=[];for(const e of a.slice().reverse())n.push(...e);return[o[0]].concat(n)}))}build(e){let t;Uw(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{qx("RNNCell_".concat(r),(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of t.cells)r.push(_k(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Xw(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}Yw(t)}}function jD(e){const{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:o}=e,i=()=>null!=o?o(t(),n):yw(t(),n),s=()=>bw(i,t,r);if(!a||a<=1)return ph(s().clone());return Array(a).fill(void 0).map(s).map((e=>ph(e.clone())))}GD.className="StackedRNNCells",fd(GD);var HD=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};class qD extends OD{constructor(e){if(e.unroll)throw new lx("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new lx("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Qw({ndim:5})]}call(e,t){return hh((()=>{if(null!=this.cell.dropoutMask&&(dh(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dh(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new cx("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return hh((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=Af([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];hh((()=>{if(!this.stateful)throw new sx("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new cx("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Af(a))):this.states_=[Af(a)];else if(null==e)dh(this.states_),null!=this.keptStates&&(dh(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>Af(a))):this.states_[0]=Af(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new cx("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):dh(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=a;if(!jo(n.shape,r))throw new cx("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(r,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map((e=>ph(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:o,dilationRate:i}=this.cell,s="channelsFirst"===t,u=e[s?3:2],c=e[s?4:3],l=fD(u,r[0],a,o[0],i[0]),h=fD(c,r[1],a,o[1],i[1]);return[...e.slice(0,2),...s?[n,l,h]:[l,h,n]]}}qD.className="ConvRNN2D";class KD extends UD{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:o,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Tx(this.filters,"filters"),this.kernelSize=pD(n,2,"kernelSize"),this.kernelSize.forEach((e=>Tx(e,"kernelSize"))),this.strides=pD(r||1,2,"strides"),this.strides.forEach((e=>Tx(e,"strides"))),this.padding=a||"valid",Gx(this.padding),this.dataFormat=o||"channelsLast",Vx(this.dataFormat),this.dilationRate=pD(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>Tx(e,"dilationRate")))}build(e){var t;e=jw(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new cx("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends ww{apply(e,t){return uw([n.apply([r]),Ff([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return hh((()=>{if(3!==e.length)throw new cx("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,r=e[0],a=e[1],o=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=jD({ones:()=>_f(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,s=(e,t,n)=>t&&t[n]?ad(t[n],e):e;let u=s(r,i,0),c=s(r,i,1),l=s(r,i,2),h=s(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=jD({ones:()=>_f(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=s(a,d,0),f=s(a,d,1),m=s(a,d,2),g=s(a,d,3);const[y,b,v,x]=Jf(this.kernel.read(),4,3),[w,k,C,D]=this.useBias?Jf(this.bias.read(),4):[null,null,null,null];u=this.inputConv(u,y,w,this.padding),c=this.inputConv(c,b,k,this.padding),l=this.inputConv(l,v,C,this.padding),h=this.inputConv(h,x,D,this.padding);const[S,E,I,N]=Jf(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,S),f=this.recurrentConv(f,E),m=this.recurrentConv(m,I),g=this.recurrentConv(g,N);const T=this.recurrentActivation.apply(td(u,p)),A=this.recurrentActivation.apply(td(c,f)),F=td(ad(A,o),ad(T,this.activation.apply(td(l,m)))),_=ad(this.recurrentActivation.apply(td(h,g)),this.activation.apply(F));return[_,_,F]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=HD(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const a=Lp(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?gw(a,n,this.dataFormat):a}recurrentConv(e,t){return Lp(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}KD.className="ConvLSTM2DCell",fd(KD);class XD extends qD{constructor(e){const t=new KD(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}XD.className="ConvLSTM2D",fd(XD);class YD extends tk{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return hh((()=>{this.invokeCallHook(e,t);const n=Gw(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return bw((()=>yw(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}YD.className="Dropout",fd(YD);class QD extends YD{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}QD.className="SpatialDropout1D",fd(QD);class ZD extends tk{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Tx(this.units,"units"),this.activation=$C(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Ww(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Ww(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=xk(e.kernelConstraint),this.biasConstraint=xk(e.biasConstraint),this.kernelRegularizer=iD(e.kernelRegularizer),this.biasRegularizer=iD(e.biasRegularizer),this.activityRegularizer=iD(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=jw(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=jw(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return hh((()=>{this.invokeCallHook(e,t);const n=Gw(e),r=Fx(this.activation.getClassName());let a;return null!=r?a=dw(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=dw(n,this.kernel.read()),null!=this.bias&&(a=gw(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const e={units:this.units,activation:ZC(this.activation),useBias:this.useBias,kernelInitializer:Pw(this.kernelInitializer),biasInitializer:Pw(this.biasInitializer),kernelRegularizer:aD(this.kernelRegularizer),biasRegularizer:aD(this.biasRegularizer),activityRegularizer:aD(this.activityRegularizer),kernelConstraint:bk(this.kernelConstraint),biasConstraint:bk(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}ZD.className="Dense",fd(ZD);class JD extends tk{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=jw(e);for(const t of e.slice(1))if(null==t)throw new cx('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],Zx(e,1)]}call(e,t){return hh((()=>{this.invokeCallHook(e,t);let n=Gw(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=cm(n,e)}return function(e){if(e.rank<=1)throw new cx("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],Zx(e.shape,1)];return Cp(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}JD.className="Flatten",fd(JD);class $D extends tk{constructor(e){super(e),this.supportsMasking=!0,this.activation=$C(e.activation)}call(e,t){return hh((()=>{this.invokeCallHook(e,t);const n=Gw(e);return this.activation.apply(n)}))}getConfig(){const e={activation:ZC(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}$D.className="Activation",fd($D);class eS extends tk{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return hh((()=>{return e=Gw(e),t=e,n=this.n,hh((()=>{if(2!==t.shape.length)throw new cx("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(t.shape.length," tensor."));return lw(aw(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}eS.className="RepeatVector",fd(eS);class tS extends tk{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let a=1,o=null;for(let s=0;s<r.length;++s){const e=r[s];if(this.isUnknown(e)){if(null!==o)throw new cx("Can only specifiy one unknown dimension.");o=s}else a*=e}const i=Zx(e);if(null!==o){if(0===a||i%a!==0)throw new cx(n);r[o]=i/a}else if(i!==a)throw new cx(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return hh((()=>{this.invokeCallHook(e,t);const n=Gw(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Cp(n,a)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}tS.className="Reshape",fd(tS);class nS extends tk{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=ew(1,e.dims.length+1);if(!jo(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Qw({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=jw(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return cm(Gw(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}nS.className="Permute",fd(nS);class rS extends tk{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=Gw(e);return ip(Nf(n,this.maskValue),-1)}call(e,t){return hh((()=>{this.invokeCallHook(e,t);const n=Gw(e),r=ip(Nf(n,this.maskValue),-1,!0);return ad(n,$h(r,n.dtype))}))}}rS.className="Masking",fd(rS);class aS extends tk{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(yx(e.inputLength))}this.inputDim=e.inputDim,Tx(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Tx(this.outputDim,"outputDim"),this.embeddingsInitializer=Ww(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=iD(e.embeddingsRegularizer),this.activityRegularizer=iD(e.activityRegularizer),this.embeddingsConstraint=xk(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return hh((()=>this.maskZero?(e=Gw(e),Nf(e,sd(e))):null))}computeOutputShape(e){if(e=jw(e),null==this.inputLength)return[...e,this.outputDim];const t=yx(this.inputLength);if(t.length!==e.length-1)throw new cx('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let r=0;r<t.length;++r){const a=t[r],o=e[r+1];if(null!=a&&null!=o&&a!==o)throw new cx('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==a&&(t[n]=o),n++}}return[e[0],...t,this.outputDim]}call(e,t){return hh((()=>{this.invokeCallHook(e,t);let n=Gw(e);"int32"!==n.dtype&&(n=rw(n,"int32"));const r=pw(this.embeddings.read(),Cp(n,[n.size]));return Cp(r,jw(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Pw(this.embeddingsInitializer),embeddingsRegularizer:aD(this.embeddingsRegularizer),activityRegularizer:aD(this.activityRegularizer),embeddingsConstraint:bk(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}aS.className="Embedding",fd(aS);class oS extends tk{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new lx}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const a=e[e.length-t.length+r],o=t[r];if(null==a||null==o||a<0||o<0)n.push(null);else if(1===a)n.push(o);else if(1===o)n.push(a);else{if(a!==o)throw new cx("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[jw(e)]),e.length<2)throw new cx("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=Sx(t),t.length>1)throw new cx("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===Sx(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return hh((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=$x(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=aw(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const o of e){const e=o.rank;if(null==e){const e=o.shape,r=e[0],a=e.slice(1).concat([r]);let i=Cp(o,[r].concat(Zx(e.slice(1))));i=cm(i,[1,0]),i=Cp(i,a),t.push(i),n=!0}else if(e>1){const r=ew(1,e).concat([0]);t.push(cm(o,r)),n=!0}else t.push(o)}let r=this.mergeFunction(t);const a=r.rank;if(n)if(null==a){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=Cp(cm(Cp(r,[-1,t]),[1,0]),n)}else if(a>1){const e=[a-1].concat(ew(0,a-1));r=cm(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=Sx(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return hh((()=>{if(null==t)return null;if(!Array.isArray(t))throw new cx("`mask` should be an Array");if(!Array.isArray(e))throw new cx("`inputs` should be an Array");if(t.length!==e.length)throw new cx("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:Qp(e,0))))[0];for(let e=1;e<t.length-1;++e)n=vf(n,t[e]);return n}))}}class iS extends oS{constructor(e){super(e)}mergeFunction(e){return hh((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=td(t,e[n]);return t}))}}iS.className="Add",fd(iS);class sS extends oS{constructor(e){super(e)}mergeFunction(e){return hh((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ad(t,e[n]);return t}))}}sS.className="Multiply",fd(sS);class uS extends oS{constructor(e){super(e)}mergeFunction(e){return hh((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=td(t,e[n]);return ad(1/e.length,t)}))}}uS.className="Average",fd(uS);class cS extends oS{constructor(e){super(e)}mergeFunction(e){return hh((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ed(t,e[n]);return t}))}}cS.className="Maximum",fd(cS);class lS extends oS{constructor(e){super(e)}mergeFunction(e){return hh((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Sf(t,e[n]);return t}))}}lS.className="Minimum",fd(lS);class hS extends oS{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new cx("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let a=!1;for(const e of n)if(jo(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new cx("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return hh((()=>uw(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new cx("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new cx("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new cx("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new cx("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return hh((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let o=0;o<e.length;++o)null==t[o]?r.push($h(_f(e[o]),"bool")):t[o].rank<e[o].rank?r.push(Qp(t[o],-1)):r.push(t[o]);const a=_p(r,this.axis);return op(a,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function dS(e,t){for(;e<0;)e+=t;return e}hS.className="Concatenate",fd(hS);class pS extends oS{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Wo(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new lx("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new cx("Dimension incompatibility: "+"".concat(t[r[0]]," !== ").concat(n[r[1]]))}mergeFunction(e){if(2!==e.length)throw new cx("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>dS(t,e[n].shape.length))):[dS(this.axes,n.shape.length),dS(this.axes,r.shape.length)],this.normalize&&(n=Rk(n,t[0]),r=Rk(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new lx("batchDot is not implemented for tensors of 4D or higher rank yet");if(Wo(e.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length))),Wo(e.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new lx("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);const o=n;return hh((()=>{let n,i;if(r>a){n=r-a;const e=[];for(let t=0;t<n;++t)e.push(1);t=Cp(t,t.shape.concat(e))}else if(a>r){n=a-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=Cp(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=o[0]===o[1]?uf(ad(e,t),o[0]):uf(ad(cm(e,[1,0]),t),o[1]);else{const n=o[0]!==e.shape.length-1,r=o[1]===t.shape.length-1;i=xf(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=$f(i,t)}return 1===i.shape.length&&(i=Qp(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[dS(this.axes,e.length),dS(this.axes,t.length)],n}computeOutputShape(e){Wo(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new lx("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}pS.className="Dot",fd(pS);class fS extends tk{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return hh((()=>{this.invokeCallHook(e,t);const n=Gw(e);return bw((()=>td(hw(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}fS.className="GaussianNoise",fd(fS);class mS extends tk{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return hh((()=>{this.invokeCallHook(e,t);const n=Gw(e);if(this.rate>0&&this.rate<1){return bw((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return ad(n,hw(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}mS.className="GaussianDropout",fd(mS);class gS extends tk{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Gw(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return hh((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=Gw(e),r=-1.7580993408473766;let a=nf(Bf(n),this.rate);a=rw(a,"float32");const o=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-o*r*this.rate,s=td(ad(t,a),ad(td(a,-1),r));return td(ad(s,o),i)};return bw(r,(()=>Gw(e)),t.training||!1)}return e}))}}function yS(e,t,n,r,a){let o,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)o=Ip(e,t,n,r,a,i);else if(3===e.rank)o=Np(e,t,n,r,a,i);else{if(4!==e.rank)throw new lx("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");o=Tp(e,t,n,r,a,i)}return o}function bS(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return jo(r.slice().sort(),ew(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return hh((()=>{const o=Ef(e,r),i=o.mean,s=o.variance;return[yS(e,i,s,n,t,a),i,s]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return hh((()=>{const o=Ef(e,r),i=o.mean,s=o.variance,u=[];for(const t of ew(0,e.rank))-1!==r.indexOf(t)?u.push(1):u.push(e.shape[t]);const c=Cp(i,u),l=Cp(s,u),h=null==t?null:Cp(t,u),d=null==n?null:Cp(n,u);return[yS(e,c,l,d,h,a),i,s]}))}(e,t,n,r,a)}gS.className="AlphaDropout",fd(gS);class vS extends tk{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Ww(e.betaInitializer||"zeros"),this.gammaInitializer=Ww(e.gammaInitializer||"ones"),this.movingMeanInitializer=Ww(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Ww(e.movingVarianceInitializer||"ones"),this.betaConstraint=xk(e.betaConstraint),this.gammaConstraint=xk(e.gammaConstraint),this.betaRegularizer=iD(e.betaRegularizer),this.gammaRegularizer=iD(e.gammaRegularizer)}build(e){e=jw(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new cx("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new Qw({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return hh((()=>{const n=null!=t.training&&t.training,r=Gw(e),a=r.shape,o=a.length,i=ew(0,o),s=this.axis>=0?this.axis:this.axis+o;i.splice(s,1);const u=px(1,o);u[s]=a[s];const c=i.slice();c.sort();const l=!jo(c,ew(0,o).slice(0,o-1));if(!n)return(()=>{if(l){const e=Cp(this.movingMean.read(),u),t=Cp(this.movingVariance.read(),u),n=this.center?Cp(this.beta.read(),u):null,a=this.scale?Cp(this.gamma.read(),u):null;return yS(r,e,t,n,a,this.epsilon)}return yS(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=bS(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{hh((()=>{const r=1-n,a=e.read(),o=ad(xd(a,t),r);e.write(xd(a,o))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Pw(this.betaInitializer),gammaInitializer:Pw(this.gammaInitializer),movingMeanInitializer:Pw(this.movingMeanInitializer),movingVarianceInitializer:Pw(this.movingVarianceInitializer),betaRegularizer:aD(this.betaRegularizer),gammaRegularizer:aD(this.gammaRegularizer),betaConstraint:bk(this.betaConstraint),gammaConstraint:bk(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}vS.className="BatchNormalization",fd(vS);class xS extends tk{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Ww(e.betaInitializer||"zeros"),this.gammaInitializer=Ww(e.gammaInitializer||"ones"),this.betaRegularizer=iD(e.betaRegularizer),this.gammaRegularizer=iD(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=jw(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error("Invalid axis: ".concat(a));if(this.axis.length!==Sx(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=Gw(e),r=n.shape,a=r.length;return hh((()=>{let{mean:e,variance:t}=Ef(n,this.axis,!0);const o=px(1,a);for(const n of this.axis)o[n]=r[n];const i=e=>null!=e&&e.shape.length!==a?Cp(e,o):e;let s=this.scale?i(this.gamma.read()):null,u=this.center?i(this.beta.read()):null;const c=[],l=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(c.push(r[n]),l.push(1)):(c.push(1),l.push(r[n]));return e=Zp(e,c),t=Zp(t,c),null!=s&&(s=Zp(s,l)),null!=u&&(u=Zp(u,l)),yS(n,e,t,u,s,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Pw(this.betaInitializer),gammaInitializer:Pw(this.gammaInitializer),betaRegularizer:aD(this.betaRegularizer),gammaRegularizer:aD(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}xS.className="LayerNormalization",fd(xS);class wS extends tk{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new cx("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new cx("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new cx("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Qw({ndim:4})]}computeOutputShape(e){let t,n;return e=jw(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return hh((()=>{return t=Gw(e),n=this.padding,r=this.dataFormat,hh((()=>{if(4!==t.rank)throw new cx("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(t.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new cx("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new cx("Unknown data format: ".concat(r,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Rf(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function kS(e,t,n,r,a,o){return hh((()=>{let i;Vx(a),jx(o),Gx(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==o&&(o="max"),e=gD(e,a);const s="same"===r?"same":"valid";return i="max"===o?wf(e,t,n,s):Dp(e,t,n,s),"channelsFirst"===a&&(i=cm(i,[0,3,1,2])),i}))}function CS(e,t,n,r,a,o){return hh((()=>{let i;Vx(a),jx(o),Gx(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==o&&(o="max"),e=yD(e,a);const s="same"===r?"same":"valid";return i="max"===o?kf(e,t,n,s):Sp(e,t,n,s),"channelsFirst"===a&&(i=cm(i,[0,4,1,2,3])),i}))}wS.className="ZeroPadding2D",fd(wS);class DS extends tk{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new cx("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(Tx(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new cx("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}Tx(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Gx(this.padding),this.inputSpec=[new Qw({ndim:3})]}computeOutputShape(e){const t=fD((e=jw(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return hh((()=>{this.invokeCallHook(e,t),e=aw(Gw(e),2);const n=this.poolingFunction(Gw(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return $f(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class SS extends DS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Vx(a),Gx(r),kS(e,t,n,r,a,"max")}}SS.className="MaxPooling1D",fd(SS);class ES extends DS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Vx(a),Gx(r),kS(e,t,n,r,a,"avg")}}ES.className="AveragePooling1D",fd(ES);class IS extends tk{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new cx("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];Tx(this.poolSize,"poolSize"),Tx(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Vx(this.dataFormat),Gx(this.padding),this.inputSpec=[new Qw({ndim:4})]}computeOutputShape(e){e=jw(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=fD(t,this.poolSize[0],this.padding,this.strides[0]),n=fD(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return hh((()=>(this.invokeCallHook(e,t),this.poolingFunction(Gw(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class NS extends IS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Vx(a),Gx(r),kS(e,t,n,r,a,"max")}}NS.className="MaxPooling2D",fd(NS);class TS extends IS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Vx(a),Gx(r),kS(e,t,n,r,a,"avg")}}TS.className="AveragePooling2D",fd(TS);class AS extends tk{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new cx("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Tx(this.poolSize,"poolSize"),Tx(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Vx(this.dataFormat),Gx(this.padding),this.inputSpec=[new Qw({ndim:5})]}computeOutputShape(e){e=jw(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=fD(t,this.poolSize[0],this.padding,this.strides[0]),n=fD(n,this.poolSize[1],this.padding,this.strides[1]),r=fD(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return hh((()=>(this.invokeCallHook(e,t),this.poolingFunction(Gw(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class FS extends AS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Vx(a),Gx(r),CS(e,t,n,r,a,"max")}}FS.className="MaxPooling3D",fd(FS);class _S extends AS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Vx(a),Gx(r),CS(e,t,n,r,a,"avg")}}_S.className="AveragePooling3D",fd(_S);class RS extends tk{constructor(e){super(e),this.inputSpec=[new Qw({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new lx}}class MS extends RS{constructor(e){super(e||{})}call(e,t){return hh((()=>{const t=Gw(e);return Cf(t,1)}))}}MS.className="GlobalAveragePooling1D",fd(MS);class OS extends RS{constructor(e){super(e||{})}call(e,t){return hh((()=>{const t=Gw(e);return sf(t,1)}))}}OS.className="GlobalMaxPooling1D",fd(OS);class zS extends tk{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Vx(this.dataFormat),this.inputSpec=[new Qw({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new lx}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class LS extends zS{call(e,t){return hh((()=>{const t=Gw(e);return"channelsLast"===this.dataFormat?Cf(t,[1,2]):Cf(t,[2,3])}))}}LS.className="GlobalAveragePooling2D",fd(LS);class BS extends zS{call(e,t){return hh((()=>{const t=Gw(e);return"channelsLast"===this.dataFormat?sf(t,[1,2]):sf(t,[2,3])}))}}BS.className="GlobalMaxPooling2D",fd(BS);class PS extends tk{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=_k(t.layer,n);delete t.layer;const a={layer:r};return Object.assign(a,t),new e(a)}}class WS extends PS{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=jw(e)).length<3)throw new cx("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=jw(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return hh((()=>MD(((e,n)=>[Gw(this.layer.call(e,t)),[]]),e=Gw(e),[],!1,null,null,!1,!0)[1]))}}WS.className="TimeDistributed",fd(WS);class US extends PS{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=_k(n),t.goBackwards=!0!==t.goBackwards;const r={};var a;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=_k(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,a=this.mergeMode,Ix(Wx,"BidirectionalMergeMode",a),e.weights)throw new lx("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),t=a[0]):t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):gx(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=RD(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const o=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new cx("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,o.push(...n);const r=n.map((e=>new Qw({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new lx("Support for constants in Bidirectional layers is not implemented yet.");const s=o[0]instanceof Zw;for(const u of o)if(u instanceof Zw!==s)throw new cx("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(s){const n=[e].concat(o),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const s=super.apply(n,t);return this.inputSpec=a,s}return super.apply(e,t)}call(e,t){return hh((()=>{const n=t.initialState;let r,a,o,i;if(null==n)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const o=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(o=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=Uf(a,1)),"concat"===this.mergeMode?i=uw([r,a]):"sum"===this.mergeMode?i=td(r,a):"ave"===this.mergeMode?i=ad(.5,td(r,a)):"mul"===this.mergeMode?i=ad(r,a):null==this.mergeMode&&(i=[r,a]),this.returnState?null==this.mergeMode?i.concat(o):[i].concat(o):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){qx(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),qx(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=_k(t.layer);if(delete t.layer,null!=t.numConstants)throw new lx("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}US.className="Bidirectional",fd(US);class VS extends tk{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return hh((()=>("float32"!==(e=Gw(e)).dtype&&(e=rw(e,"float32")),td(ad(e,this.scale),this.offset))))}}VS.className="Rescaling",fd(VS);const{resizeBilinear:GS,cropAndResize:jS}=lg;class HS extends tk{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,o,i,s){return hh((()=>{let u,c=!1;const l=[t/o,n/i,(r+t)/o,(a+n)/i],h=[];3===e.rank?(c=!0,u=em([e])):u=e;for(let e=0;e<u.shape[0];e++)h.push(l);const d=sh(h,[h.length,4]),p=Pf(0,h.length,1,"int32"),f=jS(u,d,p,[r,a],"nearest");return rw(c?Gw(om(f)):f,s)}))}upsize(e,t,n,r){return hh((()=>rw(GS(e,[t,n]),r)))}call(e,t){return hh((()=>{const t=Gw(e),n=t.dtype,r=t.shape,a=r[r.length-3],o=r[r.length-2];let i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let s=0;return o!==this.width&&(s=Math.floor((o-this.width)/2),0===s&&(s=1)),i>=0&&s>=0?this.centerCrop(t,i,s,this.height,this.width,a,o,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=jw(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}HS.className="CenterCrop",fd(HS);class qS extends tk{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=jw(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return hh((()=>{let n;if("int32"!==(e=Gw(e)).dtype&&(e=rw(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new cx("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));n=Gw(t.countWeights)}const r=sf(e),a=Df(e),o=tf(this.numTokens,r).bufferSync().get(0),i=nf(a,0).bufferSync().get(0);if(!o||!i)throw new cx("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(e,t,n,r){let a=Gw(e);if("int32"!==a.dtype&&(a=rw(a,"int32")),"int"===t)return a;const o=a.shape;if(0===a.rank&&(a=Qp(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=Qp(a,-1)),a.rank>2)throw new cx("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(t," and input shape ").concat(o)+" which would result in output rank ".concat(a.rank,"."));const i=["multiHot","oneHot"].includes(t),s=a;let u;if(u=jp(s,"undefined"!==typeof r&&"count"===t?r:[],n,i),"tfIdf"!==t)return u;if(r)return ad(u,r);throw new cx("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}qS.className="CategoryEncoding",fd(qS);const KS=new Set(["bilinear","nearest"]);class XS extends tk{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!KS.has(e.interpolation))throw new cx("Invalid interpolation parameter: ".concat(e.interpolation," is not implemented"));this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=jw(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return hh((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return lg.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return lg.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...KS]," are supported"))}))}}XS.className="Resizing",fd(XS);class YS{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}YS.className="RandomSeed";class QS extends tk{constructor(e){super(e),this.randomGenerator=new YS(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}QS.className="BaseRandomLayer";const ZS=new Set(["bilinear","nearest"]);class JS extends QS{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new cx("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new cx("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new cx("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!ZS.has(n))throw new cx("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=jw(e))[2];return[this.imgHeight,-1,t]}call(e,t){return hh((()=>{const t=Gw(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=Bf([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return lg.resizeBilinear(e,a);case"nearest":return lg.resizeNearestNeighbor(e,a);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...ZS]," are supported"))}}))}}JS.className="RandomWidth",fd(JS);var $S,eE;xi().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}($S||($S={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(eE||(eE={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function tE(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(oE(e)){const a=Array.isArray(e)?[]:{};r.add(e);for(const o in e){const i=tE(e[o],t,n,r);a[o]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,a.value),a.value}function nE(e){return rE(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:aE)}function rE(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(oE(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const o in r){const r=rE(e.map((e=>e[o])),t,n);a[o]=r}return n.delete(r),a}throw new Error("Can't recurse into non-iterable type: ".concat(r))}return a.value}function aE(e){return null===e?null:oE(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function oE(e){let t=!1;if(xi().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:n}=__webpack_require__(551);t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof El)&&!(e instanceof Promise)&&!t)}function iE(e){return function(e,t){return tE(e,t)}(e,sE)}function sE(e){return e instanceof El?{value:e.clone(),recurse:!1}:oE(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class uE{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class cE extends uE{constructor(){super(cE.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function lE(e){return new fE(e)}function hE(e,t){return new SE(e,t)}cE.INITIAL_CAPACITY=32;class dE{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new wE(this,e)}filter(e){return new vE(this,e)}map(e){return new xE(this,e)}mapAsync(e){return new kE(this,e)}serialMapAsync(e){return new kE(this,e).serial()}flatmap(e){return new DE(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new bE(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:aE;return this.rowMajorBatch(e,t).map((e=>nE(e,n)))}concatenate(e,t){return new SE(new pE([this,e]),t)}take(e){return e<0||null==e?this:new yE(this,e)}skip(e){return e<0||null==e?this:new gE(this,e)}prefetch(e){return new IE(this,e)}shuffle(e,t){return new NE(this,e,t)}serial(){return new mE(this)}}class pE extends dE{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:iE(e),done:!1}}}class fE extends dE{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message="Error thrown while iterating through a dataset: ".concat(e.message),e}}}class mE extends dE{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class gE extends dE{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;dh(e.value)}return this.upstream.next()}}class yE extends dE{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class bE extends dE{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class vE extends dE{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;dh(e.value)}}}class xE extends dE{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Ul(e.value),n=this.transform(e.value),r=Ul(n);for(const a of t)Wl(a,r)||a.dispose();return{value:n,done:!1}}}class wE extends dE{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class kE extends dE{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Ul(e.value),n=await this.transform(e.value),r=Ul(n);for(const a of t)Wl(a,r)||a.dispose();return{value:n,done:!1}}}class CE extends dE{constructor(){super(),this.outputQueue=new cE,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class DE extends CE{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Ul(e.value),n=this.transform(e.value),r=Ul(n);this.outputQueue.pushAll(n);for(const a of t)Wl(a,r)||a.dispose();return!0}}class SE extends dE{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var EE;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(EE||(EE={}));class IE extends dE{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new uE(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class NE extends IE{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=$a.alea(n||cl().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class TE{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return Wo(e>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(e))),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),AE((async()=>(await n.iterator()).columnMajorBatch(e,t,FE)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,AE((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,AE((async()=>(await t.iterator()).filter((t=>hh((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return AE((async()=>(await t.iterator()).map((t=>hh((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return AE((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return AE((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,AE((async()=>hE(lE((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,AE((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const r=this,a=$a.alea(t||cl().toString());return AE((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,AE((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function AE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends TE{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function FE(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof El||dl(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof El?em(e):sh(e)}(e),recurse:!1}}return{value:null,recurse:!0}}TE.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function _E(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Wo("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors in the CPU backend.")))}))}const RE=Dy;class ME extends Mo{nextDataId(){return ME.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Ro(this,ch())}write(e,t,n){this.firstUse&&(this.firstUse=!1,xi().get("IS_NODE")&&zc("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ni(n[0])){const a=n.map((e=>ll(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return Vg(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>hl(e)));return Jh(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Jh(e.shape,e.dtype,t)}makeOutput(e,t,n){return ch().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=cl();e();return{kernelMs:cl()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){_E([e],"where");const t=this.readSync(e.dataId);return RE(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}ME.nextDataId=0;function OE(e){return(t,n,r)=>{const a=$o(n,t.length);for(let o=0;o<t.length;++o)a[o]=e(t[o],r);return a}}function zE(e,t,n){return LE(e,OE(t),n)}function LE(e,t,n){return r=>{let{inputs:a,attrs:o,backend:i}=r;const{x:s}=a;_E(s,e);const u=i,c=u.data.get(s.dataId).values;let l;if("string"===s.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");l=ky(c)}else l=c;const h=n||s.dtype,d=t(l,h,o);return u.makeTensorInfo(s.shape,h,d)}}fh("cpu",(()=>new ME),1);const BE=zE(Cs,(e=>e>=0?e:Math.exp(e)-1)),PE={kernelName:Cs,backendName:"cpu",kernelFunc:BE};function WE(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const UE={kernelName:Ws,backendName:"cpu",kernelFunc:WE};function VE(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:o}=r;_E([a],"leakyRelu");const i=Go(a.shape),s=n.data.get(a.dataId).values,u=Jo("float32",i);for(let c=0;c<s.length;c++)u[c]=s[c]<0?o*s[c]:s[c];return n.makeTensorInfo(a.shape,"float32",u)}const GE={kernelName:qs,backendName:"cpu",kernelFunc:VE};function jE(e){return(t,n,r,a,o)=>{const i=Sd(t,n),s=i.length,u=si(i),c=Jo(o,Go(i)),l=t.length,h=n.length,d=si(t),p=si(n),f=Cd(t,i),m=Cd(n,i);if(f.length+m.length===0)for(let g=0;g<c.length;++g)c[g]=e(r[g%r.length],a[g%a.length]);else for(let g=0;g<c.length;++g){const t=mi(g,s,u),n=t.slice(-l);f.forEach((e=>n[e]=0));const o=fi(n,l,d),i=t.slice(-h);m.forEach((e=>i[e]=0));const y=fi(i,h,p);c[g]=e(r[o],a[y])}return[c,i]}}const HE=jE(((e,t)=>e<0?t*e:e));function qE(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t;_E([r,a],"prelu");const o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[s,u]=HE(r.shape,a.shape,o,i,"float32");return n.makeTensorInfo(u,"float32",s)}const KE={kernelName:Iu,backendName:"cpu",kernelFunc:qE},XE=zE(Ou,(e=>Math.max(0,e))),YE={kernelName:Ou,backendName:"cpu",kernelFunc:XE},QE=zE(Uu,(e=>Math.min(Math.max(0,e),6))),ZE={kernelName:Uu,backendName:"cpu",kernelFunc:QE},JE=OE((e=>1/(1+Math.exp(-e)))),$E=zE(ec,(e=>1/(1+Math.exp(-e)))),eI={kernelName:ec,backendName:"cpu",kernelFunc:$E};function tI(e,t,n,r,a){if("linear"===n)return WE({inputs:{x:t},backend:e});if("relu"===n)return XE({inputs:{x:t},backend:e});if("elu"===n)return BE({inputs:{x:t},backend:e});if("relu6"===n)return QE({inputs:{x:t},backend:e});if("prelu"===n)return qE({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return VE({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return $E({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function nI(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,s=n.makeTensorInfo(r.shape,"complex64");return n.data.get(s.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",o),imag:n.makeTensorInfo(a.shape,"float32",i)},s}const rI={kernelName:Zi,backendName:"cpu",kernelFunc:nI};function aI(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return nI({inputs:{real:aI(e,t,"float32"),imag:aI(e,t,"float32")},backend:e})}const r=hi(Go(t),n);return e.makeTensorInfo(t,n,r)}function oI(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,o=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,o)}const iI={kernelName:Ru,backendName:"cpu",kernelFunc:oI};function sI(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=ul([0],n),[a,o]=jE(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[o,"bool",a]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(r))}function uI(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===a.dtype)return WE({inputs:{x:a},backend:n});const e=aI(n,a.shape,a.dtype),t=uI({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=nI({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=oI({inputs:{input:a},backend:n}),t=uI({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!ei(a.dtype,o)){const e=WE({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}const i=n.data.get(a.dataId).values,[s,u,c]=sI(i,a.shape,a.dtype,o);return n.makeTensorInfo(s,u,c)}const cI={kernelName:Xi,backendName:"cpu",kernelFunc:uI};function lI(e,t,n,r){return null==n?n=>{let{inputs:a,backend:o}=n;const{a:i,b:s}=a,u=o;_E([i,s],e);const c=u.data.get(i.dataId).values,l=u.data.get(s.dataId).values,h="string"===i.dtype?ky(c):c,d="string"===i.dtype?ky(l):l,p=r||i.dtype,[f,m]=t(i.shape,s.shape,h,d,p);return u.makeTensorInfo(m,p,f)}:e=>{let{inputs:a,backend:o}=e;const{a:i,b:s}=a,u=o;if("complex64"===i.dtype||"complex64"===s.dtype){const e=uI({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),t=u.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,o=u.data.get(r.dataId).values,c=u.data.get(a.dataId).values,l=uI({inputs:{x:s},backend:u,attrs:{dtype:"complex64"}}),h=u.data.get(l.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=u.data.get(d.dataId).values,m=u.data.get(p.dataId).values,[g,y,b]=n(i.shape,s.shape,o,c,f,m),v=u.makeTensorInfo(b,"float32",g),x=u.makeTensorInfo(b,"float32",y),w=nI({inputs:{real:v,imag:x},backend:u});return u.disposeIntermediateTensorInfo(e),u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(v),u.disposeIntermediateTensorInfo(x),w}{const e=u.data.get(i.dataId).values,n=u.data.get(s.dataId).values,a=r||i.dtype,[o,c]=t(i.shape,s.shape,e,n,a);return u.makeTensorInfo(c,a,o)}}}function hI(e){return(t,n,r,a,o,i)=>{const s=Sd(t,n),u=Go(s),c=s.length,l=si(s),h=Jo("float32",u),d=Jo("float32",u),p=Cd(t,s),f=Cd(n,s),m=Vg(r,a),g=Vg(o,i),y=t.length,b=si(t),v=n.length,x=si(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=r.real,d[w]=r.imag}else for(let w=0;w<h.length;w++){const t=mi(w,c,l),n=t.slice(-y);p.forEach((e=>n[e]=0));const r=fi(n,y,b),a=t.slice(-v);f.forEach((e=>a[e]=0));const o=fi(a,v,x),i=e(m[2*r],m[2*r+1],g[2*o],g[2*o+1]);h[w]=i.real,d[w]=i.imag}return[h,d,s]}}const dI=jE(((e,t)=>e+t)),pI=hI(((e,t,n,r)=>({real:e+n,imag:t+r}))),fI=lI(Ni,dI,pI),mI={kernelName:Ni,backendName:"cpu",kernelFunc:fI};function gI(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:o}=r,i=Go(a.shape),s=Yo(o,i),u=Go(s);Wo(i===u,(()=>"The new shape (".concat(s,") has ").concat(u," elements and the old ")+"shape (".concat(a.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(a.dataId);const c=n.data.get(a.dataId);if(null!=c.complexTensorInfos){const e=c.complexTensorInfos.real,t=c.complexTensorInfos.imag;e.shape=s,t.shape=s}return{dataId:a.dataId,shape:s,dtype:a.dtype}}const yI={kernelName:zu,backendName:"cpu",kernelFunc:gI};function bI(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o}=t,{transposeA:i,transposeB:s}=r;_E([a,o],"matMul");const u=a.shape.length,c=o.shape.length,l=i?a.shape[u-2]:a.shape[u-1],h=s?o.shape[c-1]:o.shape[c-2],d=i?a.shape[u-1]:a.shape[u-2],p=s?o.shape[c-2]:o.shape[c-1],f=a.shape.slice(0,-2),m=o.shape.slice(0,-2),g=Go(f),y=Go(m),b=Sd(a.shape.slice(0,-2),o.shape.slice(0,-2)).concat([d,p]);Wo(l===h,(()=>"Error in matMul: inner shapes (".concat(l,") and (")+"".concat(h,") of Tensors with shapes ").concat(a.shape," and ")+"".concat(o.shape," and transposeA=").concat(i)+" and transposeB=".concat(s," must match.")));const v=s?[y,p,h]:[y,h,p],x=gI({inputs:{x:a},backend:n,attrs:{shape:i?[g,l,d]:[g,d,l]}}),w=gI({inputs:{x:o},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],C=i?x.shape[2]:x.shape[1],D=s?w.shape[1]:w.shape[2],S=Math.max(g,y),E=n.data.get(x.dataId).values,I=n.data.get(w.dataId).values,N=si(x.shape),T=si(w.shape),[A,F,_]=i?[N[0],1,N[1]]:[N[0],N[1],1],[R,M,O]=s?[1,T[1],T[0]]:[T[1],1,T[0]],z=C*D,L=Jh([S,C,D],x.dtype),B=L.values,P=n.blockSize;for(let W=0;W<S;W++){const e=W%g,t=W%y;for(let n=0;n<C;n+=P){const r=Math.min(n+P,C);for(let a=0;a<D;a+=P){const o=Math.min(a+P,D);for(let i=0;i<k;i+=P){const s=Math.min(i+P,k);for(let u=n;u<r;u++)for(let n=a;n<o;n++){let r=0;for(let a=i;a<s;a++){r+=E[e*A+u*F+a*_]*I[a*R+n*M+t*O]}B[W*z+(u*D+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,L.dtype,L.values)}const vI={kernelName:Gi,backendName:"cpu",kernelFunc:bI};const xI={kernelName:Rc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o,bias:i,preluActivationWeights:s}=t,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=bI({inputs:{a:a,b:o},attrs:{transposeA:u,transposeB:c},backend:n}),i&&(p=fI({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),l&&(f=tI(n,d,l,s,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function wI(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const kI={kernelName:Si,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;_E(t,"abs");let r=new Float32Array(Go(t.shape));return r=wI(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},CI=zE(Ei,(e=>Math.acos(e))),DI={kernelName:Ei,backendName:"cpu",kernelFunc:CI},SI=zE(Ii,(e=>Math.acosh(e))),EI={kernelName:Ii,backendName:"cpu",kernelFunc:SI};const II={kernelName:Ti,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;_E(t,"addN");const a=r.map((e=>n.data.get(e.dataId).values)),o=Jh(r[0].shape,r[0].dtype),i=o.values;for(let s=0;s<r.length;s++){const e=a[s];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}};function NI(e,t,n,r,a){const o=t.length,i=Go(t),s=si(t),u=si(a),c=Jo(n,Go(a));for(let l=0;l<i;++l){const t=mi(l,o,s),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];c[fi(n,o,u)]=e[l]}return c}function TI(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:o}=n;_E(a,"transpose");const i=a.shape.length,s=new Array(i);for(let c=0;c<s.length;c++)s[c]=a.shape[o[c]];const u=NI(r.data.get(a.dataId).values,a.shape,a.dtype,o,s);return{dataId:r.write(u,s,a.dtype),shape:s,dtype:a.dtype}}const AI={kernelName:Sc,backendName:"cpu",kernelFunc:TI};const FI={kernelName:Ai,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;_E(a,"all");const s=Qo(o,a.shape);let u=s;const c=mf(u,a.shape.length);let l=a;null!=c&&(l=TI({inputs:{x:a},backend:n,attrs:{perm:c}}),u=yf(u.length,a.shape.length)),ff("all",u,l.shape.length);const[h,d]=df(l.shape,u),p=Go(d),f=hi(Go(h),l.dtype),m=n.data.get(l.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[y]=t}null!=c&&n.disposeIntermediateTensorInfo(l);const g=n.makeTensorInfo(h,l.dtype,f);if(i){const e=gI({inputs:{x:g},backend:n,attrs:{shape:pf(h,s)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const _I={kernelName:Fi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;_E(a,"any");const s=Qo(o,a.shape);let u=s;const c=mf(u,a.shape.length);let l=a;null!=c&&(l=TI({inputs:{x:a},backend:n,attrs:{perm:c}}),u=yf(u.length,a.shape.length)),ff("any",u,l.shape.length);const[h,d]=df(l.shape,u),p=Go(d),f=hi(Go(h),l.dtype),m=n.data.get(l.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[y]=t}null!=c&&n.disposeIntermediateTensorInfo(l);const g=n.makeTensorInfo(h,l.dtype,f);if(i){const e=gI({inputs:{x:g},backend:n,attrs:{shape:pf(h,s)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const RI={kernelName:_i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o}=r;_E(a,"argMax");let i=Qo(o,a.shape);const s=mf(i,a.shape.length);let u=a;const c=[];null!=s&&(u=TI({inputs:{x:a},backend:n,attrs:{perm:s}}),c.push(u),i=yf(i.length,u.shape.length)),i=[i[0]],ff("argMax",i,u.shape.length);const[l,h]=df(u.shape,i),d=hi(Go(l),"int32"),p=Go(h),f=n.data.get(u.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a>t&&(t=a,n=r)}d[m]=n}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l,"int32",d)}};const MI={kernelName:Ri,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o}=r;_E(a,"argMin");let i=Qo(o,a.shape);const s=mf(i,a.shape.length);let u=a;const c=[];null!=s&&(u=TI({inputs:{x:a},backend:n,attrs:{perm:s}}),c.push(u),i=yf(i.length,u.shape.length)),i=[i[0]],ff("argMin",i,u.shape.length);const[l,h]=df(u.shape,i),d=hi(Go(l),"int32"),p=Go(h),f=n.data.get(u.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a<t&&(t=a,n=r)}d[m]=n}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l,"int32",d)}},OI=zE(Mi,(e=>Math.asin(e))),zI={kernelName:Mi,backendName:"cpu",kernelFunc:OI},LI=zE(Oi,(e=>Math.asinh(e))),BI={kernelName:Oi,backendName:"cpu",kernelFunc:LI},PI=zE(zi,(e=>Math.atan(e))),WI={kernelName:zi,backendName:"cpu",kernelFunc:PI},UI=jE(((e,t)=>Math.atan2(e,t))),VI=lI(Bi,UI),GI={kernelName:Bi,backendName:"cpu",kernelFunc:VI},jI=zE(Li,(e=>Math.atanh(e))),HI={kernelName:Li,backendName:"cpu",kernelFunc:jI};function qI(e,t,n,r,a,o){const i=a.strideHeight,s=a.strideWidth,u=a.dilationHeight,c=a.dilationWidth,l=a.effectiveFilterHeight,h=a.effectiveFilterWidth,d=a.padInfo.top,p=a.padInfo.left,f="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Jh(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){const t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){const x=y*i-d,w=Math.max(0,x),k=Math.min(a.inHeight,l+x),C=t+y*b;for(let t=0;t<a.outWidth;++t){const i=t*s-p,l=Math.max(0,i),d=Math.min(a.inWidth,h+i);let y=f,b=0,x=0;for(let t=w;t<k;t+=u){const a=n+t*r[1];for(let t=l;t<d;t+=c){const n=e[a+t*r[2]+m];"max"===o&&n>y?y=n:"avg"===o&&(b+=n,x++)}if(isNaN(y))break}g[C+t*v+m]="avg"===o?b/x:y}}}return m}function KI(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Jh(r.outShape,"int32"),s=r.strideHeight,u=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Jh(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*s-p;let y=n;for(;y<0;)y+=c;const b=Math.min(r.inHeight,h+n);for(let s=0;s<r.outWidth;++s){const h=s*u-f;let p=h;for(;p<0;)p+=l;const v=Math.min(r.inWidth,d+h);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=c){const i=t-n;for(let n=p;n<v;n+=l){const s=n-h,u=m.get(g,t,n,e);u>x&&(x=u,w=a?o?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*d+s)}}i.set(w,g,t,s,e)}}return i}function XI(e,t,n,r,a,o){const i=a.strideDepth,s=a.strideHeight,u=a.strideWidth,c=a.dilationDepth,l=a.dilationHeight,h=a.dilationWidth,d=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Jh(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],C=a.outShape[3]*a.outShape[4],D=a.outShape[4];for(let S=0;S<a.batchSize;++S){const t=S*w,n=S*r[0];for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outDepth;++w){const S=w*i-m;let E=S;for(;E<0;)E+=c;const I=Math.min(a.inDepth,d+S),N=t+w*k;for(let t=0;t<a.outHeight;++t){const i=t*s-g;let d=i;for(;d<0;)d+=l;const m=Math.min(a.inHeight,p+i),w=N+t*C;for(let t=0;t<a.outWidth;++t){const i=t*u-y;let s=i;for(;s<0;)s+=h;const p=Math.min(a.inWidth,f+i),g=w+t*D;let k=b,C=0,S=0;for(let t=E;t<I;t+=c){const a=n+t*r[1];for(let t=d;t<m;t+=l){const n=a+t*r[2];for(let t=s;t<p;t+=h){const a=e[n+t*r[3]+v];if("max"===o&&a>k?k=a:"avg"===o&&(C+=a,S++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===o?C/Math.max(S,1):k}}}}return v}const YI={kernelName:Pi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;_E(a,"avgPool");const{filterSize:o,strides:i,pad:s,dimRoundingMode:u}=r;Wo(vp(i,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")));const c=cp(a.shape,o,i,1,s,u);let l;if(1===c.filterWidth&&1===c.filterHeight&&jo(c.inShape,c.outShape))l=WE({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=si(a.shape),r=qI(e,a.shape,a.dtype,t,c,"avg");l=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return l}};const QI={kernelName:Ui,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:o,strides:i,pad:s,dimRoundingMode:u,dataFormat:c}=r;_E(a,"avgPool3d");const l=lp(a.shape,o,i,1,s,u,c),h=XI(n.data.get(a.dataId).values,a.shape,a.dtype,si(a.shape),l,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const ZI={kernelName:Vi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,{filterSize:i,strides:s,pad:u,dimRoundingMode:c}=r;_E([a,o],"avgPool3DGrad");const l=lp(o.shape,i,s,1,u,c),h=l.strideDepth,d=l.strideHeight,p=l.strideWidth,f=l.filterDepth,m=l.filterHeight,g=l.filterWidth,y=l.dilationDepth,b=l.dilationHeight,v=l.dilationWidth,x=l.effectiveFilterDepth,w=l.effectiveFilterHeight,k=l.effectiveFilterWidth,C=x-1-l.padInfo.front,D=k-1-l.padInfo.left,S=w-1-l.padInfo.top,E=Jh(o.shape,"float32"),I=1/(f*m*g),N=n.bufferSync(a);for(let T=0;T<l.batchSize;++T)for(let e=0;e<l.inChannels;++e)for(let t=0;t<l.inDepth;++t)for(let n=0;n<l.inHeight;++n)for(let r=0;r<l.inWidth;++r){const a=t-C,o=n-S,i=r-D;let s=0;for(let t=0;t<x;t+=y){const n=(a+t)/h;if(!(n<0||n>=l.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const r=(o+t)/d;if(!(r<0||r>=l.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){const a=(i+t)/p;if(a<0||a>=l.outWidth||Math.floor(a)!==a)continue;s+=N.get(T,n,r,a,e)}}}E.set(s*I,T,t,n,r,e)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}};const JI={kernelName:Wi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,i=o;_E([a,o],"avgPoolGrad");const{filterSize:s,strides:u,pad:c}=r,l=cp(i.shape,s,u,1,c),h=l.strideHeight,d=l.strideWidth,p=l.filterHeight,f=l.filterWidth,m=l.dilationHeight,g=l.dilationWidth,y=l.effectiveFilterHeight,b=l.effectiveFilterWidth,v=b-1-l.padInfo.left,x=y-1-l.padInfo.top,w=Jh(i.shape,"float32"),k=1/(p*f),C=n.data.get(a.dataId).values,D=Jh(a.shape,"float32",C);for(let S=0;S<l.batchSize;++S)for(let e=0;e<l.inChannels;++e)for(let t=0;t<l.inHeight;++t)for(let n=0;n<l.inWidth;++n){const r=t-x,a=n-v;let o=0;for(let t=0;t<y;t+=m){const n=(r+t)/h;if(!(n<0||n>=l.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const r=(a+t)/d;if(r<0||r>=l.outWidth||Math.floor(r)!==r)continue;o+=D.get(S,n,r,e)}}w.set(o*k,S,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const $I={kernelName:Os,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,scale:o,offset:i,mean:s,variance:u}=t;Wo(s.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Wo(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Wo(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),_E([a,s,u,o,i],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const l=n.data.get(a.dataId).values,h=n.data.get(s.dataId).values,d=n.data.get(u.dataId).values,p=o?n.data.get(o.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(l.length),g=f.length,y=p.length,b=d.length,v=h.length;let x=0,w=0,k=0,C=0;for(let D=0;D<l.length;++D)m[D]=f[x++]+(l[D]-h[w++])*p[k++]/Math.sqrt(d[C++]+c),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),C>=b&&(C=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};function eN(e,t,n,r,a){const o=ep(r,t,n),i=Go(n),s=si(r);if(o){const n=tp(t,s);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}const u=Jh(r,a,"string"===a?ky(e):e),c=Jh(n,a);for(let l=0;l<c.size;++l){const e=c.indexToLoc(l),n=e.map(((e,n)=>e+t[n]));c.set(u.get(...n),...e)}return"string"===a?Cy(c.values):c.values}function tN(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:o,size:i}=r;_E(a,"slice");const[s,u]=np(a,o,i);Vd(a,s,u);const c=eN(n.data.get(a.dataId).values,s,u,a.shape,a.dtype);return n.makeTensorInfo(u,a.dtype,c)}const nN={kernelName:Qu,backendName:"cpu",kernelFunc:tN};const rN={kernelName:ji,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:o,crops:i}=r;_E([a],"batchToSpaceND");const s=o.reduce(((e,t)=>e*t)),u=Sg(a.shape,o,s),c=Eg(u.length,o.length),l=Ig(a.shape,o,s),h=Ng(i,o.length),d=Tg(l,i,o.length),p=gI({inputs:{x:a},backend:n,attrs:{shape:u}}),f=TI({inputs:{x:p},backend:n,attrs:{perm:c}}),m=gI({inputs:{x:f},backend:n,attrs:{shape:l}}),g=tN({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function aN(e,t,n,r,a){const o=Go(r),i=hi(a,n);for(let s=0;s<e.length;s++){const n=e[s];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=o>0?t[s]:1)}return i}function oN(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e.shape[0],o=e.shape[1],i=Jh([a,n],t.dtype);for(let s=0;s<a;s++)for(let a=0;a<o;a++){const o=e.get(s,a);if(o<0)throw new Error("Input x must be non-negative!");o>=n||(r?i.set(1,s,o):t.size>0?i.set(i.get(s,o)+t.get(s,a),s,o):i.set(i.get(s,o)+1,s,o))}return i}const iN={kernelName:Hi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:i}=r,s=aN(n.data.get(a.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,s)}},sN=jE(((e,t)=>e&t)),uN={kernelName:qi,backendName:"cpu",kernelFunc:lI(qi,sN)};const cN={kernelName:Ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,s=Sd(Array.from(o),Array.from(i));return n.makeTensorInfo([s.length],"int32",Int32Array.from(s))}},lN=OE((e=>Math.ceil(e))),hN=LE(Yi,lN),dN={kernelName:Yi,backendName:"cpu",kernelFunc:hN},pN=zE(Qi,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),fN={kernelName:Qi,backendName:"cpu",kernelFunc:pN},mN={kernelName:Ji,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Go(t.shape)),a=n.data.get(t.dataId),o=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,s=n.data.get(o.dataId).values,u=n.data.get(i.dataId).values;for(let c=0;c<s.length;c++){const e=s[c],t=u[c];r[c]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function gN(e,t,n,r){const a=$o(n,Go(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Go(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const o="string"===n?ky(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const s=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[s+t]=o[i++]}r+=e.shape[1]}))}return a}function yN(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,o=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,o)}const bN={kernelName:Vs,backendName:"cpu",kernelFunc:yN};function vN(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,o=Qo(a,t[0].shape)[0];mg(t.map((e=>e.shape)),o);let i=gg(t.map((e=>e.shape)),o);if(0===Go(i))return n.makeTensorInfo(i,t[0].dtype,[]);const s=t.filter((e=>Go(e.shape)>0));if(1===s.length)return WE({inputs:{x:s[0]},backend:n});if("complex64"===s[0].dtype){const e=s.map((e=>oI({inputs:{input:e},backend:n}))),t=s.map((e=>yN({inputs:{input:e},backend:n}))),r=vN({inputs:e,backend:n,attrs:{axis:o}}),a=vN({inputs:t,backend:n,attrs:{axis:o}}),i=nI({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}const u=s.map((e=>{const t=Go(e.shape.slice(o));return gI({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),c=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=gg(u.map((e=>e.shape)),1);const l=1===u[0].shape[0],h=gN(c,i,t[0].dtype,l),d=gg(s.map((e=>e.shape)),o),p=n.makeTensorInfo(d,t[0].dtype,h);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const xN={kernelName:$i,backendName:"cpu",kernelFunc:vN};function wN(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dataFormat:u,dilations:c,dimRoundingMode:l}=r;_E([a,o],"conv2d");const h=wp(u),d=hp(a.shape,o.shape,i,c,s,l,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,v="channelsLast"===d.dataFormat,x=new kl(d.outShape,a.dtype),w=si(a.shape),k=si(o.shape),C=w[0],D=v?w[1]:w[2],S=v?w[2]:1,E=v?1:w[1],I=x.strides[0],N=v?x.strides[1]:x.strides[2],T=v?x.strides[2]:1,A=v?1:x.strides[1],F=n.data.get(a.dataId).values,_=n.data.get(o.dataId).values,R=x.values;for(let M=0;M<d.batchSize;++M){const e=M*C,t=M*I;for(let n=0;n<d.outHeight;++n){const r=t+n*N,a=n*d.strideHeight-b;for(let t=0;t<p;++t){const n=a+t*m;if(n<0||n>=d.inHeight)continue;const o=t*k[0],i=e+n*D;for(let e=0;e<d.outWidth;++e){const t=r+e*T,n=e*d.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=d.inWidth)continue;const a=i+r*S;let s=o+e*k[1];for(let e=0;e<d.inChannels;++e){const n=F[a+e*E];for(let e=0;e<d.outChannels;++e)R[t+e*A]+=n*_[s+e];s+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,R)}const kN={kernelName:es,backendName:"cpu",kernelFunc:wN};const CN={kernelName:ts,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,pad:s,dataFormat:u,dimRoundingMode:c,filterShape:l}=r;_E([a,o],"conv2dBackpropFilter");const h=wp(u),d=hp(a.shape,l,i,1,s,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new kl(d.filterShape,"float32"),v=d.padInfo.left,x=d.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(o.dataId).values,C=new kl(a.shape,a.dtype,w),D=new kl(o.shape,o.dtype,k);for(let S=0;S<m;++S){const e=Math.max(0,Math.ceil((x-S)/p)),t=Math.min(d.outHeight,(d.inHeight+x-S)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let o=0;o<d.inChannels;++o)for(let i=0;i<d.outChannels;++i){let s=0;for(let u=0;u<d.batchSize;++u)for(let c=e;c<t;++c){const e=S+c*p-x;for(let t=r;t<a;++t){const r=n+t*f-v;s+=y?C.get(u,e,r,o)*D.get(u,c,t,i):C.get(u,o,e,r)*D.get(u,i,c,t)}}b.set(s,S,n,o,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const DN={kernelName:ns,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{inputShape:i,strides:s,pad:u,dataFormat:c,dimRoundingMode:l}=r;_E([a,o],"conv2dBackpropInput");const h=si(o.shape),d=si(a.shape);let p=wp(c);const f=hp(i,o.shape,s,1,u,l,!1,p),m=new kl(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(o.dataId).values,[v,x,w]=h,{batchSize:k,filterHeight:C,filterWidth:D,inChannels:S,inHeight:E,inWidth:I,outChannels:N,outHeight:T,outWidth:A,strideHeight:F,strideWidth:_}=f;p=f.dataFormat;const R=C-1-f.padInfo.top,M=D-1-f.padInfo.left,O="channelsLast"===p,z=m.strides[0],L=O?m.strides[1]:m.strides[2],B=O?m.strides[2]:1,P=O?1:m.strides[1],W=d[0],U=O?d[1]:d[2],V=O?d[2]:1,G=O?1:d[1];for(let j=0;j<k;++j)for(let e=0;e<S;++e)for(let t=0;t<E;++t){const n=t-R,r=Math.max(0,Math.ceil(n/F)),a=Math.min(T,(C+n)/F);for(let o=0;o<I;++o){const i=o-M,s=Math.max(0,Math.ceil(i/_)),u=Math.min(A,(D+i)/_);let c=0;for(let t=r;t<a;++t){const r=t*F-n;for(let n=s;n<u;++n){const a=W*j+U*t+V*n,o=v*(C-1-r)+x*(D-1-(n*_-i))+w*e;for(let e=0;e<N;++e){c+=y[a+G*e]*b[o+e]}}}g[z*j+L*t+B*o+P*e]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const SN={kernelName:rs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:u}=r;_E([a,o],"conv3d");const c=dp(a.shape,o.shape,i,u,s),{filterDepth:l,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,v=g.top,x=new kl(c.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(o.dataId).values,C=x.values,D=si(a.shape),S=si(o.shape);for(let E=0;E<c.batchSize;++E){const e=E*D[0],t=E*x.strides[0];for(let n=0;n<c.outDepth;++n){const r=t+n*x.strides[1],a=n*c.strideDepth-y;for(let t=0;t<l;++t){const n=a+t*p;if(n<0||n>=c.inDepth)continue;const o=t*S[0],i=e+n*D[1];for(let e=0;e<c.outHeight;++e){const t=r+e*x.strides[2],n=e*c.strideHeight-v;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=c.inHeight)continue;const a=o+e*S[1],s=i+r*D[2];for(let e=0;e<c.outWidth;++e){const n=t+e*c.outChannels,r=e*c.strideWidth-b;for(let e=0;e<d;++e){const t=r+e*m;if(t<0||t>=c.inWidth)continue;const o=a+e*S[2],i=s+t*c.inChannels;let u=o;for(let e=0;e<c.inChannels;++e){const t=w[i+e];for(let e=0;e<c.outChannels;++e)C[n+e]+=t*k[u+e];u+=c.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const EN={kernelName:as,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,pad:s,filterShape:u}=r;_E([a,o],"conv3dBackpropFilterV2");const c=si(a.shape),l=si(o.shape),h=dp(a.shape,u,i,1,s),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new kl(h.filterShape,"float32"),v=b.values,[x,w,k,C]=b.strides,D=n.data.get(o.dataId).values,[S,E,I,N]=l,T=n.data.get(a.dataId).values,[A,F,_,R]=c,M=h.padInfo.front,O=h.padInfo.left,z=h.padInfo.top;for(let L=0;L<m;++L){const e=Math.max(0,Math.ceil((M-L)/d)),t=Math.min(h.outDepth,(h.inDepth+M-L)/d),n=L*x;for(let r=0;r<g;++r){const a=Math.max(0,Math.ceil((z-r)/p)),o=Math.min(h.outHeight,(h.inHeight+z-r)/p),i=r*w+n;for(let n=0;n<y;++n){const s=Math.max(0,Math.ceil((O-n)/f)),u=Math.min(h.outWidth,(h.inWidth+O-n)/f),c=n*k+i;for(let i=0;i<h.inChannels;++i){const l=i*C+c;for(let c=0;c<h.outChannels;++c){let m=0;for(let l=0;l<h.batchSize;++l){const h=l*A,g=l*S;for(let l=e;l<t;++l){const e=(L+l*d-M)*F+h,t=l*E+g;for(let l=a;l<o;++l){const a=(r+l*p-z)*_+e,o=l*I+t;for(let e=s;e<u;++e){const t=e*N+o;m+=T[(n+e*f-O)*R+a+i]*D[t+c]}}}}v[l+c]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const IN={kernelName:os,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{pad:i,strides:s,inputShape:u}=r;_E([a],"conv3dBackpropInputV2");const c=si(a.shape),l=si(o.shape),h=dp(u,o.shape,s,1,i),d=new kl(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(a.dataId).values,[v,x,w,k]=c,C=n.data.get(o.dataId).values,[D,S,E,I]=l,{batchSize:N,filterDepth:T,filterHeight:A,filterWidth:F,inChannels:_,inDepth:R,inHeight:M,inWidth:O,outChannels:z,outDepth:L,outHeight:B,outWidth:P,strideDepth:W,strideHeight:U,strideWidth:V}=h,G=T-1-h.padInfo.front,j=A-1-h.padInfo.top,H=F-1-h.padInfo.left;for(let q=0;q<N;++q)for(let e=0;e<_;++e)for(let t=0;t<R;++t){const n=t-G,r=Math.max(0,Math.ceil(n/W)),a=Math.min(L,(T+n)/W);for(let o=0;o<M;++o){const i=o-j,s=Math.max(0,Math.ceil(i/U)),u=Math.min(B,(A+i)/U);for(let c=0;c<O;++c){const l=c-H,h=Math.max(0,Math.ceil(l/V)),d=Math.min(P,(F+l)/V);let N=0;for(let t=r;t<a;++t){const r=t*W-n;for(let n=s;n<u;++n){const a=n*U-i;for(let o=h;o<d;++o){const i=v*q+x*t+w*n+k*o,s=D*(T-1-r)+S*(A-1-a)+E*(F-1-(o*V-l))+I*e;for(let e=0;e<z;++e){N+=b[i+e]*C[s+e]}}}}p[f*q+m*t+g*o+y*c+e]=N}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},NN=zE(is,(e=>Math.cos(e))),TN={kernelName:is,backendName:"cpu",kernelFunc:NN},AN=zE(ss,(e=>Math.cosh(e))),FN={kernelName:ss,backendName:"cpu",kernelFunc:AN};const _N={kernelName:ls,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:o,boxInd:i}=t,{cropSize:s,method:u,extrapolationValue:c}=r,[l,h,d,p]=a.shape,f=o.shape[0],[m,g]=s,y=Jh([f,m,g,p],"float32"),b=n.data.get(o.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,w=si(a.shape),k=si(y.shape);for(let C=0;C<f;C++){const e=4*C,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],o=v[C];if(o>=l)continue;const i=m>1?(r-t)*(h-1)/(m-1):0,s=g>1?(a-n)*(d-1)/(g-1):0;for(let l=0;l<m;l++){const e=m>1?t*(h-1)+l*i:.5*(t+r)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+l*k[1]+C*k[0];y.values[n]=c}else if("bilinear"===u){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const u=g>1?n*(d-1)+e*s:.5*(n+a)*(d-1);if(u<0||u>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+l*k[1]+C*k[0];y.values[n]=c}continue}const h=Math.floor(u),f=Math.ceil(u),m=u-h;for(let n=0;n<p;n++){let a=n+h*w[2]+t*w[1]+o*w[0];const s=x[a];a=n+f*w[2]+t*w[1]+o*w[0];const u=x[a];a=n+h*w[2]+r*w[1]+o*w[0];const c=x[a];a=n+f*w[2]+r*w[1]+o*w[0];const d=s+(u-s)*m,p=c+(x[a]-c)*m;a=n+e*k[2]+l*k[1]+C*k[0],y.values[a]=d+(p-d)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(d-1)+t*s:.5*(n+a)*(d-1);if(r<0||r>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+l*k[1]+C*k[0];y.values[n]=c}continue}const i=Math.round(r),u=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+u*w[1]+o*w[0],r=e+t*k[2]+l*k[1]+C*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const RN={kernelName:us,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,exclusive:i,reverse:s}=r;_E(a,"cumprod");const u=mf([o],a.shape.length);let c=a;null!=u&&(c=TI({inputs:{x:a},backend:n,attrs:{perm:u}}));const l=yf(1,a.shape.length)[0];if(l!==c.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(l));const h=Ol(c.dtype,"int32"),d=li(Go(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=s?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?1:p[t];else{const n=m(y,e-1);d[t]=i?p[n]*d[n]:p[t]*d[n]}}const g=n.makeTensorInfo(c.shape,h,d);if(null!=u){const e=TI({inputs:{x:g},backend:n,attrs:{perm:gf(u)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),e}return g}};const MN={kernelName:cs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,exclusive:i,reverse:s}=r;_E(a,"cumsum");const u=mf([o],a.shape.length);let c=a;null!=u&&(c=TI({inputs:{x:a},backend:n,attrs:{perm:u}}));const l=yf(1,a.shape.length)[0];if(l!==c.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(c.shape.length-1," but got axis=").concat(l));const h=Ol(c.dtype,"int32"),d=hi(Go(c.shape),h),p=n.data.get(c.dataId).values,f=c.shape[c.shape.length-1],m=s?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=i?0:p[t];else{const n=m(y,e-1);d[t]=i?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(c.shape,h,d);if(null!=u){const e=TI({inputs:{x:g},backend:n,attrs:{perm:gf(u)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(c),e}return g}};const ON={kernelName:hs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:i,binaryOutput:s}=r;if(1===a.shape.length){const e=aN(n.data.get(a.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,e)}if(2===a.shape.length){const e=oN(n.bufferSync(a),n.bufferSync(o),i,s);return n.makeTensorInfo(e.shape,o.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};const zN={kernelName:ds,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:o,dataFormat:i}=r;Wo("NHWC"===i,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(i)));const s=a.shape[0],u=a.shape[1],c=a.shape[2],l=a.shape[3],h=u*o,d=c*o,p=l/(o*o),f=n.data.get(a.dataId).values,m=new Float32Array(s*h*d*p);let g=0;for(let y=0;y<s;++y)for(let e=0;e<h;++e){const t=Math.floor(e/o),n=e%o;for(let e=0;e<d;++e){const r=Math.floor(e/o),a=(n*o+e%o)*p;for(let e=0;e<p;++e){const n=e+a+l*(r+c*(t+u*y));m[g++]=f[n]}}}return n.makeTensorInfo([s,h,d,p],a.dtype,m)}};function LN(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:u,dimRoundingMode:c}=r;_E([a,o],"depthwiseConv2DNative");const l=si(a.shape),h=si(o.shape);let d=u;null==d&&(d=[1,1]),Wo(vp(i,d),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(i," and dilations '").concat(d,"'")));const p=hp(a.shape,o.shape,i,d,s,c,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new kl(p.outShape,a.dtype),C=n.data.get(a.dataId).values,D=n.data.get(o.dataId).values,S=k.values;for(let E=0;E<p.batchSize;++E){const e=E*l[0],t=E*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],a=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=a+t*g;if(n<0||n>=p.inHeight)continue;const o=t*h[0],i=e+n*l[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const a=o+e*h[1],s=i+r*p.inChannels;let u=t,c=a;for(let e=0;e<p.inChannels;++e){const t=C[s+e];for(let e=0;e<w;++e)S[u+e]+=t*D[c+e];u+=w,c+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const BN={kernelName:ps,backendName:"cpu",kernelFunc:LN};const PN={kernelName:fs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,dilations:s,pad:u,dimRoundingMode:c,filterShape:l}=r;_E([a,o],"depthwiseConv2dNativeBackpropFilter");const h=hp(a.shape,l,i,s,u,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new kl(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,x=n.data.get(a.dataId).values,w=new kl(a.shape,a.dtype,x),k=n.data.get(o.dataId).values,C=new kl(o.shape,o.dtype,k);for(let D=0;D<f;++D){const e=Math.max(0,Math.ceil((b-D)/d)),t=Math.min(h.outHeight,(h.inHeight+b-D)/d);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/p)),a=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let o=0;o<h.outChannels;++o){const i=Math.trunc(o/v),s=o%v;let u=0;for(let c=0;c<h.batchSize;++c)for(let s=e;s<t;++s){const e=D+s*d-b;for(let t=r;t<a;++t){const r=n+t*p-y;u+=w.get(c,e,r,i)*C.get(c,s,t,o)}}g.set(u,D,n,i,s)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const WN={kernelName:ms,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{strides:i,dilations:s,pad:u,dimRoundingMode:c,inputShape:l}=r;_E([a,o],"depthwiseConv2DNativeBackpropInput");const h=si(a.shape),d=si(o.shape),p=hp(l,o.shape,i,s,u,c,!0),f=new kl(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(a.dataId).values,[x,w,k]=h,C=n.data.get(o.dataId).values,[D,S,E]=d,{batchSize:I,filterHeight:N,filterWidth:T,inChannels:A,inHeight:F,inWidth:_,outChannels:R,outHeight:M,outWidth:O,strideHeight:z,strideWidth:L}=p,B=N-1-p.padInfo.top,P=T-1-p.padInfo.left,W=R/A;for(let U=0;U<I;++U)for(let e=0;e<A;++e)for(let t=0;t<F;++t){const n=t-B,r=Math.max(0,Math.ceil(n/z)),a=Math.min(M,(N+n)/z);for(let o=0;o<_;++o){const i=o-P,s=Math.max(0,Math.ceil(i/L)),u=Math.min(O,(T+i)/L);let c=0;for(let t=r;t<a;++t){const r=t*z-n;for(let n=s;n<u;++n){const a=x*U+w*t+k*n,o=D*(N-1-r)+S*(T-1-(n*L-i))+E*e;for(let t=0;t<W;++t){c+=v[a+(e*W+t)]*C[o+t]}}}m[g*U+y*t+b*o+e]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const UN={kernelName:gs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=Go(r.shape),o=n.data.get(r.dataId).values,i=Jh([a,a],r.dtype),s=i.values;for(let c=0;c<o.length;c++)s[c*a+c]=o[c];const u=[...r.shape,...r.shape];return n.makeTensorInfo(u,i.dtype,i.values)}},VN={kernelName:ys,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:o}=t,{strides:i,pad:s,dilations:u}=r,c=n,l=c.data.get(a.dataId).values,h=a.shape.length,d=c.data.get(o.dataId).values,p=o.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:C,filterWidth:D,dilationHeight:S,dilationWidth:E,outShape:I}=up(a.shape,o.shape,i,s,"NHWC",u),N=Go(I),T=I.length,A=$o(a.dtype,N);for(let F=0;F<f;++F)for(let e=0;e<b;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const r=n*k-x.left;for(let i=0;i<y;++i){let s=Number.MIN_SAFE_INTEGER;for(let e=0;e<C;++e){const n=t+e*S;if(n>=0&&n<m)for(let t=0;t<D;++t){const u=r+t*E;if(u>=0&&u<g){const r=fi([F,n,u,i],h,si(a.shape)),c=fi([e,t,i],p,si(o.shape)),f=l[r]+d[c];f>s&&(s=f)}}}A[fi([F,e,n,i],T,si(I))]=s}}}return{dataId:c.write(ul(A,a.dtype),I,a.dtype),shape:I,dtype:a.dtype}}},GN={kernelName:vs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:o,dy:i}=t,{strides:s,pad:u,dilations:c}=r,l=n,h=ci(a.shape,l.data.get(a.dataId).values),d=ci(o.shape,l.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:C,dilationHeight:D,dilationWidth:S,outShape:E}=up(a.shape,o.shape,s,u,"NHWC",c);Wo(i.rank===E.length,(()=>"Error in ".concat(vs,", dy ")+"must have the same rank as output ".concat(E.length,", but got ")+"".concat(i.rank)));const I=ci(E,l.data.get(i.dataId).values),N=di(o.shape,o.dtype);for(let T=0;T<p;++T)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let a=0;a<g;++a){let o=Number.MIN_SAFE_INTEGER,i=0,s=0;for(let e=0;e<k;++e){const n=t+e*D;if(n>=0&&n<f)for(let t=0;t<C;++t){const u=r+t*S;if(u>=0&&u<m){const r=h[T][n][u][a]+d[e][t][a];r>o&&(o=r,i=e,s=t)}}}N[i][s][a]+=I[T][e][n][a]}}}return{dataId:l.write(ul(N,a.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},jN={kernelName:bs,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:o,dy:i}=t,{strides:s,pad:u,dilations:c}=r,l=n,h=ci(a.shape,l.data.get(a.dataId).values),d=ci(o.shape,l.data.get(o.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:C,dilationHeight:D,dilationWidth:S,outShape:E}=up(a.shape,o.shape,s,u,"NHWC",c);Wo(i.rank===E.length,(()=>"Error in ".concat(bs,", dy ")+"must have the same rank as output ".concat(E.length,", but got ")+"".concat(i.rank)));const I=ci(E,l.data.get(i.dataId).values),N=di(a.shape,a.dtype);for(let T=0;T<p;++T)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let a=0;a<g;++a){let o=Number.MIN_SAFE_INTEGER,i=t<0?0:t,s=r<0?0:r;for(let e=0;e<k;++e){const n=t+e*D;if(n>=0&&n<f)for(let t=0;t<C;++t){const u=r+t*S;if(u>=0&&u<m){const r=h[T][n][u][a]+d[e][t][a];r>o&&(o=r,i=n,s=u)}}}N[T][i][s][a]+=I[T][e][n][a]}}}return{dataId:l.write(ul(N,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const HN={kernelName:xs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:o,options:i}=r,{contextOptions:s,imageOptions:u}=i||{},c=(null===u||void 0===u?void 0:u.alpha)||1,l=(null===s||void 0===s?void 0:s.contextType)||"2d";if("2d"!==l)throw new Error("Context type ".concat(s.contextType," is not supported by the CPU backend."));const h=o.getContext(l,(null===s||void 0===s?void 0:s.contextAttributes)||{});if(null==h)throw new Error("Could not get the context with ".concat(l," type."));const[d,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const e=[0,0,0,255*c];for(let n=0;n<f;n++){const t=m[v*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===a.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}o.width=p,o.height=d;const b=new ImageData(y,p,d);return h.putImageData(b,0,0),a}},qN=jE(((e,t)=>e*t)),KN=hI(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),XN=lI(gu,qN,KN),YN={kernelName:gu,backendName:"cpu",kernelFunc:XN};function QN(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;let s;_E(a,"sum"),s="bool"===a.dtype?uI({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):WE({inputs:{x:a},backend:n});const u=s.shape.length,c=Qo(o,s.shape),l=mf(c,u);let h=c,d=s;null!=l&&(d=TI({inputs:{x:s},backend:n,attrs:{perm:l}}),h=yf(h.length,u)),ff("sum",h,d.shape.length);const[p,f]=df(d.shape,h);let m=aI(n,p,Ol(d.dtype,"int32"));const g=Go(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let v=0;v<y.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(i){const e=m;m=gI({inputs:{x:m},backend:n,attrs:{shape:pf(m.shape,c)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(s),null!=l&&n.disposeIntermediateTensorInfo(d),m}const ZN={kernelName:rc,backendName:"cpu",kernelFunc:QN};const JN={kernelName:ks,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,o=t,{allDims:i,summedDims:s,idDims:u}=ey(a,o.length);ny(i.length,u,o);const{path:c,steps:l}=ry(s,u),h=l.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of l[m]){const{permutationIndices:t,expandDims:r}=ty(p,u[e]);let a;ay(t)?a=o[e]:(a=TI({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);jo(a.shape,i)||(a=gI({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===d?d=a:(d=XN({inputs:{a:a,b:d},backend:n}),f.push(d))}m<h-1&&(c[m]>=0&&(d=QN({inputs:{x:d},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}};const $N={kernelName:Ds,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:a}=t;_E([r,a],"eluGrad");const o=new Float32Array(Go(a.shape)),i=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values;for(let u=0;u<i.length;++u){const e=i[u];o[u]=e>=0?s[u]:s[u]*(e+1)}return n.makeTensorInfo(a.shape,"float32",o)}},eT=jE(((e,t)=>e===t?1:0)),tT=lI(Es,eT,null,"bool"),nT={kernelName:Es,backendName:"cpu",kernelFunc:tT},rT=zg,aT=Lg,oT=Bg,iT=Pg,sT=Wg,uT=Ug,cT=zE(Ss,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+rT*n);return t*(1-((((uT*r+sT)*r+iT)*r+oT)*r+aT)*r*Math.exp(-n*n))})),lT={kernelName:Ss,backendName:"cpu",kernelFunc:cT},hT=OE((e=>Math.exp(e))),dT=LE(Is,hT,"float32"),pT={kernelName:Is,backendName:"cpu",kernelFunc:dT};function fT(e){const{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:o}=r,i=a.shape.length,s=a.shape.slice();let u=o;return o<0&&(Wo(-(i+1)<=o,(()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]"))),u=i+o+1),s.splice(u,0,1),gI({inputs:{x:a},backend:n,attrs:{shape:s}})}const mT={kernelName:Ns,backendName:"cpu",kernelFunc:fT},gT=OE((e=>Math.expm1(e))),yT=LE(Ts,gT),bT={kernelName:Ts,backendName:"cpu",kernelFunc:yT},vT=jE(((e,t)=>e/t)),xT=lI(ws,vT),wT={kernelName:ws,backendName:"cpu",kernelFunc:xT},kT=jE(((e,t)=>e-t)),CT=hI(((e,t,n,r)=>({real:e-n,imag:t-r}))),DT=lI(vc,kT,CT),ST={kernelName:vc,backendName:"cpu",kernelFunc:DT};function ET(e,t,n){const r=e.shape,a=r[0],o=r[1],i=n.data.get(e.dataId),s=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,c=[a,o],l=Go(c),h=Jo("float32",l),d=Jo("float32",l);for(let g=0;g<a;g++){const e=tN({inputs:{x:s},backend:n,attrs:{begin:[g,0],size:[1,o]}}),r=tN({inputs:{x:u},backend:n,attrs:{begin:[g,0],size:[1,o]}}),a=nI({inputs:{real:e,imag:r},backend:n}),{real:i,imag:c}=IT(a,t,n),l=Vg(i,c);for(let t=0;t<o;t++){const e=qg(l,t);h[g*o+t]=e.real,d[g*o+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(c,"float32",h),f=n.makeTensorInfo(c,"float32",d),m=nI({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function IT(e,t,n){const r=Go(e.shape),a=n.data.get(e.dataId),o=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(function(e){return 0===(e&e-1)}(r)){const a=NT(o,i,r,t,n),s=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(s,"float32",a.real),t=n.makeTensorInfo(s,"float32",a.imag),o=n.makeTensorInfo([],"float32",sl(r,"float32")),i=WE({inputs:{x:o},backend:n}),u=wT.kernelFunc({inputs:{a:e,b:o},backend:n}),c=wT.kernelFunc({inputs:{a:t,b:i},backend:n}),l=n.data.get(u.dataId).values,h=n.data.get(c.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),{real:l,imag:h}}return a}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let a=0;a<t;a++){let o=0,i=0;for(let r=0;r<t;r++){const s=Yg(a*r,t,n),u=qg(e,r);o+=u.real*s.real-u.imag*s.imag,i+=u.real*s.imag+u.imag*s.real}n&&(o/=t,i/=t),Kg(r,o,i,a)}return r}(Vg(o,i),r,t);return Gg(e)}}function NT(e,t,n,r,a){if(1===n)return{real:e,imag:t};const o=Vg(e,t),i=n/2,s=jg(o),u=s.real,c=s.imag,l=[u.length],h=a.makeTensorInfo(l,"float32",u),d=a.makeTensorInfo(l,"float32",c),p=nI({inputs:{real:h,imag:d},backend:a}),f=Hg(o),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),v=a.makeTensorInfo(y,"float32",g),x=nI({inputs:{real:b,imag:v},backend:a}),w=NT(u,c,i,r,a),k=w.real,C=w.imag,D=[k.length],S=a.makeTensorInfo(D,"float32",k),E=a.makeTensorInfo(D,"float32",C),I=nI({inputs:{real:S,imag:E},backend:a}),N=NT(m,g,i,r,a),T=N.real,A=N.imag,F=[T.length],_=a.makeTensorInfo(F,"float32",T),R=a.makeTensorInfo(F,"float32",A),M=nI({inputs:{real:_,imag:R},backend:a}),O=Xg(n,r),z=[O.real.length],L=a.makeTensorInfo(z,"float32",O.real),B=a.makeTensorInfo(z,"float32",O.imag),P=nI({inputs:{real:L,imag:B},backend:a}),W=XN({inputs:{a:P,b:M},backend:a}),U=fI({inputs:{a:I,b:W},backend:a}),V=DT({inputs:{a:I,b:W},backend:a}),G=oI({inputs:{input:U},backend:a}),j=oI({inputs:{input:V},backend:a}),H=yN({inputs:{input:U},backend:a}),q=yN({inputs:{input:V},backend:a}),K=vN({inputs:[G,j],backend:a,attrs:{axis:0}}),X=vN({inputs:[H,q],backend:a,attrs:{axis:0}}),Y=a.data.get(K.dataId).values,Q=a.data.get(X.dataId).values;return a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(S),a.disposeIntermediateTensorInfo(E),a.disposeIntermediateTensorInfo(I),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(X),{real:Y,imag:Q}}const TT={kernelName:As,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Go(r.shape),o=r.shape[r.shape.length-1],i=gI({inputs:{x:r},backend:n,attrs:{shape:[a/o,o]}}),s=ET(i,!1,n),u=gI({inputs:{x:s},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),u}};function AT(e){const{backend:t,attrs:n}=e,{shape:r,value:a,dtype:o}=n,i=o||ai(a),s=$o(i,Go(r));return function(e,t){e.fill(t)}(s,a),t.makeTensorInfo(r,i,s)}const FT={kernelName:Fs,backendName:"cpu",kernelFunc:AT};const _T={kernelName:_s,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,o=r,i=Jo(a.dtype,Go(a.shape)),[s,u,c,l]=a.shape,h=o.data.get(a.dataId).values;for(let d=0;d<s;d++){const e=d*c*u*l;for(let t=0;t<u;t++){const n=t*(c*l);for(let t=0;t<c;t++){const r=t*l;for(let a=0;a<l;a++){const o=Math.round(c-t-1),s=e+n+r+a;let u=h[s];if(o>=0&&o<c){u=h[e+n+o*l+a]}i[s]=u}}}}return{dataId:o.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},RT=OE((e=>Math.floor(e))),MT=LE(Rs,RT),OT={kernelName:Rs,backendName:"cpu",kernelFunc:MT},zT=jE(((e,t)=>Math.floor(e/t))),LT=lI(Ms,zT,null,"int32"),BT={kernelName:Ms,backendName:"cpu",kernelFunc:LT};const PT={kernelName:Mc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o,bias:i,preluActivationWeights:s}=t,{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=wN({inputs:{x:a,filter:o},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:d}});if(i){const e=m;if("NCHW"===l&&1===i.shape.length&&1!==i.shape[0]){const e=gI({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=fI({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=fI({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===l&&"prelu"===p&&1===s.shape.length&&1!==s.shape[0]){const e=gI({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});m=tI(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=tI(n,m,p,s,f);n.disposeIntermediateTensorInfo(e)}return m}};const WT={kernelName:Oc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o,bias:i,preluActivationWeights:s}=t,{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=LN({inputs:{x:a,filter:o},backend:n,attrs:{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=fI({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=tI(n,m,p,s,f),n.disposeIntermediateTensorInfo(e)}return m}};function UT(e,t,n,r,a,o,i,s,u){const c=Jh([r,o],n);for(let l=0;l<r;l++){const n=[];let r=0;for(let t=0;t<a;t++){const o=e[l*a+t];r+=o*i[t],n.push(o)}if(r<0||r>=u/o)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(s));for(let e=0;e<o;e++)c.values[l*o+e]=t.get(...t.indexToLoc(r*o+e))}return c}const VT={kernelName:Ls,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,o=Go(r.shape),i=a.shape,s=i[i.length-1],[u,c,l,h]=Ag(r,a);if(0===c)return n.makeTensorInfo(u,r.dtype,[]);const d=UT(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,c,s,l,h,r.shape,o);return n.makeTensorInfo(u,r.dtype,d.values)}};function GT(e,t,n){const r=Jh(n,e.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a).slice(),o=n[0],i=n[2],s=t.locToIndex([o,i]);n[2]=t.values[s];const u=e.locToIndex(n);0<=u&&u<e.values.length&&(r.values[a]=e.values[u])}return r}const jT={kernelName:zs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:o}=t,{axis:i,batchDims:s}=r;_E([a,o],"gatherV2");const u=Qo(i,a.shape)[0],c=n.data.get(o.dataId).values,l=a.shape[u];for(let v=0;v<c.length;++v){const e=c[v];Wo(e<=l-1&&e>=0,(()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(l-1,"]")))}let h=s;null==s&&(h=0);const d=Go(o.shape),p=wy(a,o,u,h),f=gI({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=gI({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=GT(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},HT=jE(((e,t)=>e>t?1:0)),qT=lI(Bs,HT,null,"bool"),KT={kernelName:Bs,backendName:"cpu",kernelFunc:qT},XT=jE(((e,t)=>e>=t?1:0)),YT=lI(Ps,XT,null,"bool"),QT={kernelName:Ps,backendName:"cpu",kernelFunc:YT};const ZT={kernelName:Us,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Go(r.shape),o=r.shape[r.shape.length-1],i=gI({inputs:{x:r},backend:n,attrs:{shape:[a/o,o]}}),s=ET(i,!0,n),u=gI({inputs:{x:s},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),u}},JT=zE(Gs,(e=>Number.isFinite(e)?1:0),"bool"),$T={kernelName:Gs,backendName:"cpu",kernelFunc:JT},eA=zE(js,(e=>Math.abs(e)===1/0?1:0),"bool"),tA={kernelName:js,backendName:"cpu",kernelFunc:eA},nA=zE(Hs,(e=>Number.isNaN(e)?1:0),"bool"),rA={kernelName:Hs,backendName:"cpu",kernelFunc:nA},aA=jE(((e,t)=>e<t?1:0)),oA=lI(Ks,aA,null,"bool"),iA={kernelName:Ks,backendName:"cpu",kernelFunc:oA},sA=jE(((e,t)=>e<=t?1:0)),uA=lI(Xs,sA,null,"bool"),cA={kernelName:Xs,backendName:"cpu",kernelFunc:uA};function lA(e,t,n){const r=(t-e)/(n-1),a=hi(n,"float32");a[0]=e;for(let o=1;o<a.length;o++)a[o]=a[o-1]+r;return a}const hA={kernelName:Ys,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:o}=n,i=lA(r,a,o);return t.makeTensorInfo([i.length],"float32",i)}},dA=OE((e=>Math.log(e))),pA=LE(Qs,dA),fA={kernelName:Qs,backendName:"cpu",kernelFunc:pA},mA=zE(Zs,(e=>Math.log1p(e))),gA={kernelName:Zs,backendName:"cpu",kernelFunc:mA},yA=jE(((e,t)=>e&&t)),bA=lI(Js,yA,null,"bool"),vA={kernelName:Js,backendName:"cpu",kernelFunc:bA},xA=zE($s,(e=>e?0:1),"bool"),wA={kernelName:$s,backendName:"cpu",kernelFunc:xA},kA=jE(((e,t)=>e||t)),CA=lI(eu,kA,null,"bool"),DA={kernelName:eu,backendName:"cpu",kernelFunc:CA};const SA={kernelName:tu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:o,bias:i,alpha:s,beta:u}=r;_E(a,"LRN");const c=a.shape[3],l=c-1,h=n.data.get(a.dataId).values,d=Go(a.shape),p=new Float32Array(d);function f(e){const t=e%c;let n=e-t+Math.max(0,t-o);const r=e-t+Math.min(t+o,l);let a=0;for(;n<=r;n++){const e=h[n];a+=e*e}return a}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(i+s*e,-u);p[m]=t}return n.makeTensorInfo(a.shape,a.dtype,p)}};const EA={kernelName:nu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,y:o,dy:i}=t,{depthRadius:s,bias:u,alpha:c,beta:l}=r;_E(i,"LRNGrad");const h=Go(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(o.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const e=b%d,t=b-e+Math.max(0,e-s),n=b-e+Math.min(d,e+s+1);let r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=c*r+u;for(let a=t;a<n;a++){let e=-2*c*l*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-l)),e*=p[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}};function IA(e,t,n,r){const a=Jo(r,Go(n));for(let o=0;o<a.length;++o){const n=o*t;let r=e[n];for(let a=0;a<t;++a){const t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[o]=r}return a}function NA(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:o,keepDims:i}=r,s=n;let u=a.shape;const c=u.length,l=Qo(o,u);let h=l;const d=mf(h,c);let p=s.data.get(a.dataId).values;if(null!=d){const e=new Array(c);for(let t=0;t<e.length;t++)e[t]=u[d[t]];p=NI(p,u,a.dtype,d,e),h=yf(h.length,c),u=e}_E(a,"max"),ff("max",h,c);const[f,m]=df(u,h),g=IA(p,Go(m),f,a.dtype),y=s.write(g,f,a.dtype);let b=f;if(i){b=pf(f,l)}return{dataId:y,shape:b,dtype:a.dtype}}const TA={kernelName:ru,backendName:"cpu",kernelFunc:NA},AA=jE(((e,t)=>Math.max(e,t))),FA=lI(au,AA),_A={kernelName:au,backendName:"cpu",kernelFunc:FA};const RA={kernelName:ou,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;_E(a,"maxPool");const{filterSize:o,strides:i,pad:s,dimRoundingMode:u}=r;Wo(vp(i,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")));const c=cp(a.shape,o,i,1,s,u);let l;if(1===c.filterWidth&&1===c.filterHeight&&jo(c.inShape,c.outShape))l=WE({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=si(a.shape),r=qI(e,a.shape,a.dtype,t,c,"max");l=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return l}};const MA={kernelName:su,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:o,strides:i,pad:s,dimRoundingMode:u,dataFormat:c}=r;_E(a,"maxPool3d");const l=lp(a.shape,o,i,1,s,u,c),h=XI(n.data.get(a.dataId).values,a.shape,a.dtype,si(a.shape),l,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const OA={kernelName:uu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,{filterSize:i,strides:s,pad:u,dimRoundingMode:c}=r;_E([a,o],"maxPool3DGrad");const l=lp(o.shape,i,s,1,u,c),h=function(e,t){const n=Jh(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,o=t.strideWidth,i=t.dilationDepth,s=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,l=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-d;let v=b;for(;v<0;)v+=i;const x=Math.min(t.inDepth,c+b);for(let r=0;r<t.outHeight;++r){const c=r*a-p;let d=c;for(;d<0;)d+=s;const w=Math.min(t.inHeight,l+c);for(let a=0;a<t.outWidth;++a){const p=a*o-f;let k=p;for(;k<0;)k+=u;const C=Math.min(t.inWidth,h+p);let D=Number.NEGATIVE_INFINITY,S=-1;for(let t=v;t<x;t+=i){const n=t-b;for(let r=d;r<w;r+=s){const a=r-c;for(let o=k;o<C;o+=u){const i=o-p,s=e.get(m,t,r,o,g);s>=D&&(D=s,S=n*l*h+a*l+i)}}}n.set(S,m,y,r,a,g)}}}return n}(n.bufferSync(o),l),d=l.strideDepth,p=l.strideHeight,f=l.strideWidth,m=l.dilationDepth,g=l.dilationHeight,y=l.dilationWidth,b=l.effectiveFilterDepth,v=l.effectiveFilterHeight,x=l.effectiveFilterWidth,w=b-1-l.padInfo.front,k=x-1-l.padInfo.left,C=v-1-l.padInfo.top,D=Jh(o.shape,"float32"),S=n.bufferSync(a);for(let E=0;E<l.batchSize;++E)for(let e=0;e<l.inChannels;++e)for(let t=0;t<l.inDepth;++t)for(let n=0;n<l.inHeight;++n)for(let r=0;r<l.inWidth;++r){const a=t-w,o=n-C,i=r-k;let s=0;for(let t=0;t<b;t+=m){const n=(a+t)/d;if(!(n<0||n>=l.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){const a=(o+r)/p;if(!(a<0||a>=l.outHeight||Math.floor(a)!==a))for(let o=0;o<x;o+=y){const u=(i+o)/f;if(u<0||u>=l.outWidth||Math.floor(u)!==u)continue;const c=b*v*x-1-h.get(E,n,a,u,e)===t*v*x+r*x+o?1:0;if(0===c)continue;s+=S.get(E,n,a,u,e)*c}}}D.set(s,E,t,n,r,e)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}};const zA={kernelName:iu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o,output:i}=t,s=o;_E([o,i],"maxPoolGrad");const{filterSize:u,strides:c,pad:l,dimRoundingMode:h}=r,d=cp(s.shape,u,c,1,l,h),p=n.data.get(s.dataId).values,f=Jh(d.outShape,s.dtype,KI(p,s.shape,s.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=x-1-d.padInfo.left,k=v-1-d.padInfo.top,C=Jh(s.shape,"float32"),D=n.data.get(a.dataId).values,S=Jh(a.shape,"float32",D);for(let E=0;E<d.batchSize;++E)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const r=t-k,a=n-w;let o=0;for(let t=0;t<v;t+=y){const n=(r+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){const i=(a+r)/g;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;const s=v*x-1-f.get(E,n,i,e)===t*x+r?1:0;if(0===s)continue;o+=S.get(E,n,i,e)*s}}C.set(o,E,t,n,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}};const LA={kernelName:cu,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:o,strides:i,pad:s,includeBatchInIndex:u}=n,c=r;_E(a,"MaxPoolWithArgmax");const l=c.data.get(a.dataId).values,h=cp(a.shape,o,i,[1,1],s),[d,p]=function(e,t,n,r,a){const o=qI(e,0,n,si(t),a,"max"),i=KI(e,t,n,a,!0,r);return[o.values,i.values]}(l,a.shape,a.dtype,u,h),f=c.write(d,h.outShape,a.dtype),m=c.write(p,h.outShape,a.dtype);return[{dataId:f,shape:h.outShape,dtype:a.dtype},{dataId:m,shape:h.outShape,dtype:"int32"}]}};const BA={kernelName:lu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=Qo(o,a.shape),u=Go(df(a.shape,s)[1]),c=[],l=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(l);const h=uI({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(h);const d=xT({inputs:{a:h,b:l},backend:n});c.push(d);const p=QN({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:i}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const PA={kernelName:hu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;_E(a,"min");const s=Qo(o,a.shape);let u=s;const c=mf(u,a.shape.length);let l=a;null!=c&&(l=TI({inputs:{x:a},backend:n,attrs:{perm:c}}),u=yf(u.length,a.shape.length)),ff("min",u,l.shape.length);const[h,d]=df(l.shape,u),p=Go(d),f=hi(Go(h),l.dtype),m=n.data.get(l.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=c&&n.disposeIntermediateTensorInfo(l);const g=n.makeTensorInfo(h,l.dtype,f);if(i){const e=gI({inputs:{x:g},backend:n,attrs:{shape:pf(h,s)}});return n.disposeIntermediateTensorInfo(g),e}return g}},WA=jE(((e,t)=>Math.min(e,t))),UA=lI(du,WA),VA={kernelName:du,backendName:"cpu",kernelFunc:UA};const GA={kernelName:pu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:o,mode:i}=r;_E(a,"mirrorPad");const s=o.map(((e,t)=>e[0]+a.shape[t]+e[1])),u=o.map((e=>e[0])),c=o.map(((e,t)=>e[0]+a.shape[t])),l="reflect"===i?0:1,h=n.data.get(a.dataId).values,d=a.shape.length,p=si(a.shape),f=Go(s),m=s.length,g=si(s),y=Jo(a.dtype,f);for(let b=0;b<f;b++){let e=mi(b,m,g);for(let n=0;n<m;n++)e[n]<u[n]?e[n]=2*u[n]-e[n]-l:e[n]>=c[n]&&(e[n]=2*(c[n]-1)-e[n]+l);e=e.map(((e,t)=>e-u[t]));const t=fi(e,d,p);y[b]=h[t]}return{dataId:n.write(y,s,a.dtype),shape:s,dtype:a.dtype}}},jA=jE(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),HA=lI(fu,jA),qA={kernelName:fu,backendName:"cpu",kernelFunc:HA};function KA(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:o}=r,i=a.shape.length;let s=o;if(-1===s&&(s=i-1),s!==i-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(i," and dim was ").concat(s));const u=Qo([s],a.shape),c=NA({inputs:{x:a},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),l=pf(c.shape,u),h=gI({inputs:{x:c},backend:n,attrs:{shape:l}}),d=DT({inputs:{a:a,b:h},backend:n}),p=dT({inputs:{x:d},backend:n}),f=QN({inputs:{x:p},backend:n,attrs:{axis:u,keepDims:!1}}),m=gI({inputs:{x:f},backend:n,attrs:{shape:l}}),g=xT({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const XA={kernelName:ic,backendName:"cpu",kernelFunc:KA};const YA={kernelName:mu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:o,seed:i,normalized:s}=r;_E(a,"multinomial");const u=s?a:KA({inputs:{logits:a},backend:n,attrs:{dim:-1}}),c=u.shape[0],l=u.shape[1],h=n.data.get(u.dataId).values,d=[c,o],p=hi(Go(d),"int32");for(let f=0;f<c;++f){const e=f*l,t=new Float32Array(l-1);t[0]=h[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+h[e+a];const n=$a.alea(i.toString()),r=f*o;for(let a=0;a<o;++a){const e=n();p[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+a]=n;break}}}return s||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(d,"int32",p)}};function QA(e,t,n){const r=sl(-1,n);return qN([],t,r,e,n)}const ZA={kernelName:yu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;_E(r,"neg");const a=n.data.get(r.dataId).values,[o,i]=QA(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,o)}},JA=zm;const $A={kernelName:vu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:u}=r;_E(a,"NonMaxSuppression");const c=n.data.get(a.dataId).values,l=n.data.get(o.dataId).values,{selectedIndices:h}=JA(c,l,i,s,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},eF=Lm;const tF={kernelName:xu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:u,padToMaxOutputSize:c}=r;_E(a,"NonMaxSuppressionPadded");const l=n.data.get(a.dataId).values,h=n.data.get(o.dataId).values,{selectedIndices:d,validOutputs:p}=eF(l,h,i,s,u,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},nF=Bm;const rF={kernelName:wu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:u,softNmsSigma:c}=r;_E(a,"NonMaxSuppressionWithScore");const l=n.data.get(a.dataId).values,h=n.data.get(o.dataId).values,d=i,p=s,f=u,m=c,{selectedIndices:g,selectedScores:y}=nF(l,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},aF=jE(((e,t)=>e!==t?1:0)),oF=lI(bu,aF,null,"bool"),iF={kernelName:bu,backendName:"cpu",kernelFunc:oF};const sF={kernelName:Cu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:o,depth:i,onValue:s,offValue:u}=r;_E(a,"oneHot");const c=Go(a.shape),l=new Float32Array(c*i);l.fill(u);const h=n.data.get(a.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<i&&(l[d*i+h[d]]=s);return n.makeTensorInfo([...a.shape,i],o,l)}};function uF(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=oI({inputs:{input:r},backend:n}),t=uF({inputs:{x:e},backend:n}),a=yN({inputs:{input:r},backend:n}),o=uF({inputs:{x:a},backend:n}),i=nI({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),i}return AT({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const cF={kernelName:Tc,backendName:"cpu",kernelFunc:uF};const lF={kernelName:ku,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const t=oI({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),o=yN({inputs:{input:a},backend:r}),i=uF({inputs:{x:o},backend:r}),s=nI({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),s}return AT({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function hF(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return fT({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const o=t[0].shape,i=t[0].dtype;t.forEach((e=>{Uo(o,e.shape,"All tensors passed to stack must have matching shapes"),Wo(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const s=[],u=vN({inputs:t.map((e=>{const t=fT({inputs:{input:e},backend:n,attrs:{dim:a}});return s.push(t),t})),backend:n,attrs:{axis:a}});return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const dF={kernelName:Du,backendName:"cpu",kernelFunc:hF};const pF={kernelName:Su,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:o,constantValue:i}=r;_E(a,"pad");const s=o.map(((e,t)=>e[0]+a.shape[t]+e[1])),u=o.map((e=>e[0])),c=n.data.get(a.dataId).values,l=Go(a.shape),h=a.shape.length,d=si(a.shape),p=Go(s),f=s.length,m=si(s),g=Jo(a.dtype,p);0!==i&&g.fill(i);for(let y=0;y<l;y++){g[fi(mi(y,h,d).map(((e,t)=>e+u[t])),f,m)]=c[y]}return{dataId:n.write(g,s,a.dtype),shape:s,dtype:a.dtype}}},fF=jE(((e,t)=>Math.pow(e,t))),mF=lI(Eu,fF),gF={kernelName:Eu,backendName:"cpu",kernelFunc:mF};function yF(e,t,n,r){const[a,o]=df(e,r),i=Ol(t,"int32"),s=hi(Go(a),i),u=Go(o);for(let c=0;c<s.length;++c){const e=c*u;let t=1;for(let r=0;r<u;++r)t*=n[e+r];s[c]=t}return{outVals:s,outShape:a,outDtype:i}}const bF={kernelName:Nu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;_E(a,"prod");const s=a.shape.length,u=Qo(o,a.shape),c=mf(u,s);let l=u,h=a;const d=[];null!=c&&(h=TI({inputs:{x:a},backend:n,attrs:{perm:c}}),d.push(h),l=yf(l.length,s));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=yF(h.shape,h.dtype,p,l);let y=m;return i&&(y=pf(m,u)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function vF(e,t,n,r){const a=[];let o=0;const i=t.length-1+n.length,s=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let c=0;c<t.length-1;++c){u*=t[c];const e=t[c+1];for(let t=1;t<u+1;++t)s[c].push(t*e)}for(let c=0;c<e.length;++c){let r=e[c],i=e[c]+1;for(let e=0;e<n.length;++e){const a=n[e],o=e+t.length-1;if(o>=0){const e=s[o],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)s[o].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),o+=i-r)}return{outSplits:s,valueSlices:a,numValues:o}}function xF(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function wF(e,t,n,r,a){const o=t.slice();o[0]=a;const i=$o(n,Go(o)),s=e.length;return function(e,t,n,r,a,o){const i=xF(t,2)[1],s=xF(o,2)[1];let u=0;for(const c of n)for(let t=c[0];t<c[1];++t){for(let n=0;n<r;++n)a[u*s+n]=e[t*i+n];++u}}(e,t,r,0===s?0:s/t[0],i,o),[i,o]}function kF(e,t,n,r,a,o,i,s){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const a=mi(r,t.length,si(t)).join(",");throw new Error("indices[".concat(a,"] = ").concat(e," is not in [0, ").concat(n,")"))}}))}(o,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:l,numValues:h}=vF(o,i,e,u),d=function(e){const t=[];for(let n=0;n<e.length;++n){const r=$o("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(c),p=wF(n,r,a,l,h);return[d,p[0],p[1]]}const CF={kernelName:Tu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:o,indices:i}=t,{outputRaggedRank:s}=r,u=a.map((e=>n.data.get(e.dataId).values)),c=a.map((e=>e.shape)),l=n.data.get(o.dataId).values,h=n.data.get(i.dataId).values,[d,p,f]=kF(u,c,l,o.shape,o.dtype,h,i.shape),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}},DF=2147483647;function SF(e,t,n,r,a,o,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const s=0===t.length,u=0===a.length,c=0===i.length,l=[];s||l.push(t[0]),u||l.push(a[0]),c||l.push(i[0]);for(let m=1;m<l.length;++m)if(l[m]!==l[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===l.length?1:l[0],d=$o("int32",h+1);d[0]=0;for(let m=0;m<h;++m){const t=s?e[0]:e[m],n=u?r[0]:r[m],a=c?o[0]:o[m];if(0===a)throw new Error("Requires delta != 0");let i;if(a>0&&n<t||a<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/a)),i>DF)throw new Error("Requires ((limit - start) / delta) <= ".concat(DF));d[m+1]=d[m]+i}const p=$o(n,d[h]);let f=0;for(let m=0;m<h;++m){const t=d[m+1]-d[m];let n=s?e[0]:e[m];const r=c?o[0]:o[m];for(let e=0;e<t;++e)p[f++]=n,n+=r}return[d,p]}const EF={kernelName:Au,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:o}=t,i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values,[c,l]=SF(i,r.shape,r.dtype,s,a.shape,u,o.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([l.length],r.dtype,l)]}};var IF=yg;class NF{constructor(e,t,n,r,a,o,i,s,u,c){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=o,this.defaultValueShape=i,this.rowPartitionValues=s,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=vg(c),this.raggedRank=xg(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===IF.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===IF.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case IF.VALUE_ROWIDS:return NF.getMaxWidthValueRowID(t);case IF.ROW_SPLITS:return NF.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(IF[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let o=1;o<t;++o){const t=e[o];t!==r&&(r=t,a=Math.max(o-n,a),n=o)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return AF(e,n)}calculateOutputSize(e){const t=this.valuesShape;wg(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=bg(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),a=[];let o=0;for(let i=0;i<r;++i,o+=t)a.push(o);for(let i=r;i<e;++i)a.push(-1);return Wo(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const a=e.length,o=[];for(let i=0;i<a-1;++i){const a=e[i+1]-e[i];let s=Math.min(r,a),u=t[i];-1===u&&(s=0);for(let e=0;e<s;++e)o.push(u),u+=n;for(let e=0;e<a-s;++e)o.push(-1)}if(a>0&&o.length!==e[a-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,n,r){const a=e.length,o=[];if(0===a)return[];let i=0,s=e[0];if(s>=t.length)throw new Error("Got currentValueRowId=".concat(s,", which is not less than ").concat(t.length));let u=t[s];o.push(u);for(let c=1;c<a;++c){const a=e[c];if(a===s)u>=0&&(++i,i<r?u+=n:u=-1);else{if(i=0,s=a,a>=t.length)throw new Error("Got nextValueRowId=".concat(a," which is not less than ").concat(t.length));u=t[a]}o.push(u)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,n,r){const a=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case IF.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case IF.ROW_SPLITS:if(a.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(a.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error("Unsupported partition type: ".concat(IF[o]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case IF.FIRST_DIM_SIZE:return e[0];case IF.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case IF.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(IF[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let o=n.length-2;o>=0;--o)n[o]=n[o+1]*t[o+1];const r=AF(t,!1),a=$o(this.valuesDType,Go(r));if(n[0]*t[0]>0){let o=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){o=this.calculateOutputIndex(e-1,o,n[e],t[e])}this.setOutput(this.raggedRank,o,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;const a=this.values,o=n;let i=r.slice();i=i.slice(e+1);const s=Go(i),u=t.length;let c=this.defaultValue;if(c.length!==s&&1!==c.length){const e=this.defaultValueShape;hh((()=>{const t=Cp(c,e),n=Ap(t,i);c=n.dataSync()}))}let l=0,h=0,d=0;for(let p=0;p<=u;++p){let e=p<u?t[p]:-1;if(e!==d){if(h<d){const e=a.subarray(l*s);TF(o.subarray(h*s),e,(d-h)*s)}if(p>=u){const t=n.length;e=Math.floor(t/s)}if(e>d)if(1===this.defaultValue.length)o.subarray(d*s,e*s).fill(this.defaultValue[0]),d=e;else for(;e>d;){TF(o.slice(d*s),c,s),++d}e<0?(l=p+1,h=d):(l=p,h=d,d=h+1)}else++d}}}function TF(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function AF(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error("Dimension ".concat(r," must be >= 0"));if(r<-1)throw new Error("Dimension ".concat(r," must be >= -1"));r=-1}n.push(r)}return n}function FF(e,t,n,r,a,o,i,s,u,c){return new NF(e,t,n,r,a,o,i,s,u,c).compute()}const _F={kernelName:Fu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:o,defaultValue:i,rowPartitionTensors:s}=t,{rowPartitionTypes:u}=r,c=n.data.get(a.dataId).values,l=n.data.get(o.dataId).values,h=n.data.get(i.dataId).values,d=s.map((e=>n.data.get(e.dataId).values)),p=s.map((e=>e.shape)),[f,m]=FF(c,a.shape,l,o.shape,o.dtype,h,i.shape,d,p,u);return n.makeTensorInfo(f,o.dtype,m)}};function RF(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return hi(0,r);const a=hi(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),a[0]=e;for(let o=1;o<a.length;o++)a[o]=a[o-1]+n;return a}const MF={kernelName:_u,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,dtype:o,step:i}=n,s=RF(r,a,i,o);return t.makeTensorInfo([s.length],o,s)}},OF=zE(Mu,(e=>1/e)),zF={kernelName:Mu,backendName:"cpu",kernelFunc:OF};const LF={kernelName:Pu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:o,halfPixelCenters:i,size:s}=r;_E(a,"resizeBilinear");const u=si(a.shape),[c,l]=s,[h,d,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(Go([h,c,l,f])),y=[o&&c>1?d-1:d,o&&l>1?p-1:p],b=[o&&c>1?c-1:c,o&&l>1?l-1:l];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<h;k++)for(let e=0;e<c;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(d-1,Math.ceil(t)),o=k*u[0]+n*u[1],s=k*u[0]+a*u[1];for(let e=0;e<l;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),a=t-n,c=Math.min(p-1,Math.ceil(t)),l=o+n*u[2],h=s+n*u[2],d=o+c*u[2],y=s+c*u[2];for(let e=0;e<f;e++){const t=m[l+e],n=m[h+e],o=t+(m[d+e]-t)*a,i=o+(n+(m[y+e]-n)*a-o)*r;g[v++]=i}}}return n.makeTensorInfo([h,c,l,f],"float32",g)}};const BF={kernelName:Wu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:i}=r;_E([o,a],"resizeBilinearGrad");const s=si(a.shape),[u,c,l,h]=a.shape,[,d,p]=o.shape,f=new Float32Array(u*c*l*h),m=[i&&d>1?c-1:c,i&&p>1?l-1:l],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(o.dataId).values;let x=0;for(let w=0;w<u;w++){const e=w*s[0];for(let t=0;t<d;t++){const n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),c-1),o=e+r*s[1],i=e+a*s[1],u=n-r,d=1-u;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),l-1),a=t-n,c=1-a,p=o+n*s[2],m=o+r*s[2],g=i+n*s[2],y=i+r*s[2],w=d*c,k=d*a,C=u*c,D=u*a;for(let e=0;e<h;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*C,f[y+e]+=t*D}}}}return n.makeTensorInfo([u,l,c,h],"float32",f)}};const PF={kernelName:Lu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:o,halfPixelCenters:i,size:s}=r;_E(a,"resizeNearestNeighbor");const u=si(a.shape),[c,l]=s,[h,d,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(h*c*l*f),y=[o&&c>1?d-1:d,o&&l>1?p-1:p],b=[o&&c>1?c-1:c,o&&l>1?l-1:l],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let k=0;k<h;k++){const e=k*u[0];for(let t=0;t<c;t++){const n=i?v*(t+.5):v*t;let r=Math.min(d-1,o?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const a=e+r*u[1];for(let e=0;e<l;e++){const t=i?x*(e+.5):x*e;let n=Math.min(p-1,o?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=a+n*u[2];for(let e=0;e<f;e++){const t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([h,c,l,f],a.dtype,g)}};const WF={kernelName:Bu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:i}=r;_E([o,a],"resizeNearestNeighborGrad");const s=si(a.shape),u=si(o.shape),[c,l,h,d]=a.shape,[,p,f]=o.shape,m=new Float32Array(c*l*h*d),g=n.data.get(o.dataId).values,y=[i&&p>1?l-1:l,i&&f>1?h-1:h],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,C=2*Math.ceil(w)+2,D=2*Math.ceil(k)+2;for(let S=0;S<c;S++){const e=S*s[0];for(let t=0;t<l;t++){const n=e+t*s[1],r=Math.floor(t*w),a=Math.floor(r-C/2);for(let o=0;o<h;o++){const r=n+o*s[2],c=Math.floor(o*k),y=Math.floor(c-D/2);for(let n=0;n<d;n++){let s=0;for(let r=0;r<C;r++){const c=r+a;if(c<0||c>=p)continue;const d=e+c*u[1],m=c*v;if(t===Math.min(l-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<D;e++){const t=e+y;if(t<0||t>=f)continue;const r=d+t*u[2],a=t*x;o===Math.min(h-1,i?Math.round(a):Math.floor(a))&&(s+=g[r+n])}}m[r+n]=s}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};const UF={kernelName:Vu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:o}=r;_E(a,"reverse");const i=a.shape.length,s=Qo(o,a.shape);if(0===i)return WE({inputs:{x:a},backend:n});const u=new kl(a.shape,a.dtype),c=n.bufferSync(a);for(let l=0;l<u.size;l++){const e=u.indexToLoc(l),t=e.slice();s.forEach((e=>t[e]=a.shape[e]-1-t[e])),u.set(c.get(...t),...e)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},VF={kernelName:_c,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:o,fillValue:i,center:s}=n,u=r,c=Jo(a.dtype,Go(a.shape)),[l,h,d,p]=a.shape,[f,m]=Dg(s,h,d),g=Math.sin(o),y=Math.cos(o),b=u.data.get(a.dataId).values;for(let v=0;v<l;v++){const e=v*d*h*p;for(let t=0;t<h;t++){const n=t*(d*p);for(let r=0;r<d;r++){const a=r*p;for(let o=0;o<p;o++){const s=[l,t,r,o],u=s[2],v=s[1];let x=(u-f)*y-(v-m)*g,w=(u-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!==typeof i&&(k=3===o?255:i[o]),x>=0&&x<d&&w>=0&&w<h){k=b[e+w*(d*p)+x*p+o]}c[e+n+a+o]=k}}}}return{dataId:u.write(c,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},GF=zE(Gu,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),jF={kernelName:Gu,backendName:"cpu",kernelFunc:GF},HF=OE((e=>1/Math.sqrt(e))),qF=LE(ju,HF),KF={kernelName:ju,backendName:"cpu",kernelFunc:qF};function XF(e,t,n,r,a,o,i,s,u,c){const l=[r/a,a],h=e.values,d=t.values;if(0===r)return Jh(n,t.dtype);const p=u instanceof kl?u:Jh(l,t.dtype);"string"===typeof u||"number"===typeof u?p.values.fill(u):"boolean"===typeof u&&p.values.fill(+u);for(let f=0;f<o;f++){const e=[];let o=0;for(let t=0;t<i;t++){const n=h[f*i+t];e.push(n),o+=n*s[t]}if(o<0||o>=r/a)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<a;n++)c?p.values[o*a+n]+=d[f*a+n]:p.values[o*a+n]=0===t.rank?d[0]:d[f*a+n]}return p}const YF={kernelName:Hu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:o}=t,{shape:i}=r,{sliceRank:s,numUpdates:u,sliceSize:c,strides:l,outputSize:h}=Rg(0,a,i),d=XF(n.bufferSync(a),n.bufferSync(o),i,h,c,u,s,l,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}};function QF(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function ZF(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}const JF={kernelName:Ku,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:o}=t,{side:i}=r,s=function(e,t,n,r,a,o){const i=$o("int32",n*a);for(let s=0;s<n;++s){const n=e.slice(s*r,(s+1)*r),u=s*a;for(let e=0;e<a;++e)i[u+e]="left"===o?QF(n,t[e+u]):ZF(n,t[e+u])}return i}(n.data.get(a.dataId).values,n.data.get(o.dataId).values,a.shape[0],a.shape[1],o.shape[1],i);return n.makeTensorInfo(o.shape,"int32",s)}};const $F={kernelName:Xu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:o}=t;_E([r,a,o],"select");const i=r.shape.length,s=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values,l=Ol(a.dtype,o.dtype),h=hi(Go(a.shape),l);let d=0;const p=0===i||i>1||1===a.shape.length?1:Go(a.shape.slice(1));for(let f=0;f<s.length;f++)for(let e=0;e<p;e++)1===s[f]?h[d++]=u[f]:h[d++]=c[f];return n.makeTensorInfo(a.shape,l,h)}},e_=Mg,t_=Og,n_=zE(Yu,(e=>e>=0?t_*e:e_*(Math.exp(e)-1))),r_={kernelName:Yu,backendName:"cpu",kernelFunc:n_},a_=zE($u,(e=>e<0?-1:e>0?1:0)),o_={kernelName:$u,backendName:"cpu",kernelFunc:a_},i_=zE(Zu,(e=>Math.sin(e))),s_={kernelName:Zu,backendName:"cpu",kernelFunc:i_},u_=zE(Ju,(e=>Math.sinh(e))),c_={kernelName:Ju,backendName:"cpu",kernelFunc:u_},l_=Math.log(1.1920928955078125e-7)+2,h_=zE(tc,(e=>{const t=e>-l_,n=e<l_,r=Math.exp(e);let a;return a=n?r:t?e:Math.log(1+r),a})),d_={kernelName:tc,backendName:"cpu",kernelFunc:h_};const p_={kernelName:ac,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:o,paddings:i}=r;_E([a],"spaceToBatchND");const s=Go(o),u=[[0,0]];u.push(...i);for(let g=1+o.length;g<a.shape.length;++g)u.push([0,0]);const c=pF.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:u,constantValue:0}}),l=Sg(c.shape,o,s,!1),h=Eg(l.length,o.length,!1),d=Ig(c.shape,o,s,!1),p=gI({inputs:{x:c},backend:n,attrs:{shape:l}}),f=TI({inputs:{x:p},backend:n,attrs:{perm:h}}),m=gI({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function f_(e,t,n,r,a,o,i){const s=t[0],u=o[0],c=new Array(u),l=new Array(s),h=t[1];if(0===u){if(0!==s)throw new Error(sy(s));return[$o(n,0),[0,h],$o(a,0),c,l]}let d=!0,p=0;const f=new Array(u).fill(0);for(let g=0;g<s;++g){const t=e[g*h];if(t<0)throw new Error(uy(g,t));if(t>=u)throw new Error(cy(g,t,u));++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<u;++g){const e=0===f[g];c[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=r;for(let e=0;e<s;++e)l[e]=e;return[t,[s,h],n,c,l]}{const t=f[u-1],o=$o(n,t*h),d=$o(a,t),p=new Array(u).fill(0);for(let n=0;n<s;++n){const t=e[n*h],a=p[t],i=(0===t?0:f[t-1])+a;p[t]++;for(let r=0;r<h;++r)o[i*h+r]=e[n*h+r];d[i]=r[n],l[n]=i}for(let e=0;e<u;++e){if(0===p[e]){const t=0===e?0:f[e-1];o[t*h+0]=e;for(let e=1;e<h;++e)o[t*h+e]=0;d[t]=i}}return[o,[t,h],d,c,l]}}const m_={kernelName:sc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(o.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(a.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const s=n.data.get(r.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values,l=n.data.get(i.dataId).values[0],[h,d,p,f,m]=f_(s,r.shape,r.dtype,u,a.dtype,c,l);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function g_(e,t,n,r,a){const o=Go(r),i=t[0],s=a.length,u=[];let c=1,l=-1;for(let m=0;m<s;++m){const e=a[m];if(-1===e){if(-1!==l)throw new Error(ly(l,m));l=m,u.push(1)}else{if(e<0)throw new Error(hy(m,e));c*=e,u.push(e)}}if(-1!==l){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/c);if(c*e!==o)throw new Error(py(r,u));u[l]=e}if(Go(u)!==o)throw new Error(fy(r,u));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}const p=[];if(s>0){p[s-1]=1;for(let e=s-2;e>=0;--e)p[e]=p[e+1]*u[e+1]}const f=$o(n,i*s);for(let m=0;m<i;++m){let t=0;for(let n=0;n<h;++n)t+=e[m*h+n]*d[n];for(let e=0;e<s;++e)f[m*s+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,s],u]}const y_={kernelName:uc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:o}=t;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(a.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const i=Array.from(n.data.get(a.dataId).values),s=n.data.get(r.dataId).values,u=Array.from(n.data.get(o.dataId).values),[c,l,h]=g_(s,r.shape,r.dtype,i,u);return[n.makeTensorInfo(l,r.dtype,c),n.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}};function b_(e,t,n,r,a){let o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const s=r.length,u=[t[0],e.length/t[0]],c=u[1],l=s>0?a[s-1]+1:0;if(l<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=l;const d=h.reduce(((e,t)=>e*t),1),p=$o(n,d);if(0===s)return l>0&&p.fill(i),[p,h];if(l<=0)throw new Error("segment ids must be >= 0");let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<s){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error("segment ids are not increasing")}if(y<0||y>=l)throw new Error(yy(y,l));y>g&&p.fill(i,g*c,y*c);for(let n=f;n<m;++n){const t=r[n];if(t<0||t>=u[0])throw new Error(by(n,r[n],u[0]));for(let n=0;n<c;n++)p[y*c+n]+=e[t*c+n]}if(o)for(let e=0;e<c;e++)p[y*c+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>s)break}return g<l&&p.fill(i,g*c,l*c),[p,h]}const v_={kernelName:cc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(a.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(o.shape));if(a.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values,[c,l]=b_(i,r.shape,r.dtype,s,u,!0);return n.makeTensorInfo(l,r.dtype,c)}};const x_={kernelName:lc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(a.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(o.shape));if(a.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values,[c,l]=b_(i,r.shape,r.dtype,s,u);return n.makeTensorInfo(l,r.dtype,c)}};const w_={kernelName:hc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:o,defaultValue:i}=t,{outputShape:s}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:h,outputSize:d}=Rg(0,a,s),p=!1,f=n.bufferSync(a);let m;switch(o.dtype){case"bool":m=XF(f,n.bufferSync(o),s,d,l,c,u,h,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=XF(f,n.bufferSync(o),s,d,l,c,u,h,n.data.get(i.dataId).values[0],p);break;case"int32":m=XF(f,n.bufferSync(o),s,d,l,c,u,h,n.data.get(i.dataId).values[0],p);break;case"string":m=XF(f,n.bufferSync(o),s,d,l,c,u,h,hl(n.data.get(i.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(o.dtype))}return n.makeTensorInfo(s,m.dtype,m.values)}};const k_={kernelName:oc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:o,axis:i}=r,s=Qo(i,a.shape)[0],u=iy(a,o,s),c=new Array(a.shape.length).fill(0),l=a.shape.slice();return u.map((e=>{const t=[...l];t[s]=e;const r=tN({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[s]+=e,r}))}},C_=OE((e=>Math.sqrt(e))),D_=zE(nc,(e=>Math.sqrt(e))),S_={kernelName:nc,backendName:"cpu",kernelFunc:D_},E_={kernelName:pc,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,a=n;_E(r,"square");const o=a.data.get(r.dataId).values,i=new Float32Array(o.length);for(let s=0;s<o.length;++s){const e=o[s];i[s]=e*e}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},I_=jE(((e,t)=>{const n=e-t;return n*n})),N_=lI(dc,I_),T_={kernelName:dc,backendName:"cpu",kernelFunc:N_},A_=OE(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),F_=LE(fc,A_),__={kernelName:fc,backendName:"cpu",kernelFunc:F_},R_=zE(Ac,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),M_={kernelName:Ac,backendName:"cpu",kernelFunc:R_};function O_(e,t,n,r){const a=Jh(e,t.dtype);for(let o=0;o<a.size;o++){const e=a.indexToLoc(o),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}const z_={kernelName:mc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:o,end:i,strides:s,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:h,shrinkAxisMask:d}=r;_E(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=rp(a.shape,o,i,s,u,c,l,h,d);let w;if(m)w=gI({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){Wo(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const e=jd(b,v,x),t=tN({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=gI({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=O_(p,n.bufferSync(a),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class L_{constructor(e,t,n,r,a,o){this.separator=ll(e),this.nGramWidths=t,this.leftPad=ll(n),this.rightPad=ll(r),this.padWidth=a,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,o){for(let i=0;i<a;++i){const s=this.getPadWidth(o),u=Math.max(0,s-i),c=Math.max(0,s-(a-(i+1))),l=o-(u+c),h=t+(u>0?0:i-s);let d=0;d+=u*this.leftPad.length;for(let t=0;t<l;++t)d+=e[h+t].length;d+=c*this.rightPad.length;d+=(u+c+l-1)*this.separator.length,n[r+i]=new Uint8Array(d);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<l-1;++t)m(e[h+t]),m(this.separator);if(l>0){m(e[h+l-1]);for(let e=0;e<c;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<c-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error("Invalid split value ".concat(t[a],", must be in [").concat(e,", ").concat(n,"]"));e=t[a]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const a=r-1,o=$o("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=a;++t)o[t]=0;return[e,o]}o[0]=0;for(let s=1;s<=a;++s){const e=t[s]-t[s-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),o[s]=o[s-1]+n}const i=new Array(o[a]);for(let s=0;s<a;++s){const n=t[s];let r=o[s];if(this.nGramWidths.forEach((a=>{const o=t[s+1]-t[s],u=this.getNumNGrams(o,a);this.createNGrams(e,n,i,r,u,a),r+=u})),this.preserveShort&&r===o[s]){const a=t[s+1]-t[s];if(0===a)continue;const o=a+2*this.padWidth,u=1;this.createNGrams(e,n,i,r,u,o)}}return[i,o]}}function B_(e,t,n,r,a,o,i,s){return new L_(n,r,a,o,i,s).compute(e,t)}const P_={kernelName:gc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:o,leftPad:i,rightPad:s,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:h}=t,d=n.data.get(l.dataId).values,p=n.data.get(h.dataId).values,[f,m]=B_(d,p,a,o,i,s,u,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function W_(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const a=t[0];let o=e.indexOf(a);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||r.push(t),o=(e=e.subarray(o+1)).indexOf(a)}return void(n&&0===e.length||r.push(e))}let a=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(a,o);n&&0===t.length||r.push(t),a=o+1}}function U_(e,t,n){const r=e.length,a=[];let o=0,i=0;const s=new Array(r);for(let d=0;d<r;++d){const r=a.length;W_(e[d],t,n,a);const u=a.length-r;s[d]=u,o+=u,i=Math.max(i,u)}const u=$o("int32",2*o),c=new Array(o),l=[r,i];let h=0;for(let d=0;d<r;++d)for(let e=0;e<s[d];++e)u[2*h]=d,u[2*h+1]=e,c[h]=a[h],++h;return[u,c,l]}const V_={kernelName:yc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const s=n.data.get(o.dataId).values,u=n.data.get(i.dataId).values[0],[c,l,h]=U_(s,u,a),d=l.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function G_(e,t){const n=$o("int32",e.length);for(let r=0;r<e.length;++r)n[r]=il(e[r]).modulo(t).getLowBitsUnsigned();return n}const j_={kernelName:bc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=G_(n.data.get(o.dataId).values,a);return n.makeTensorInfo(o.shape,"int32",i)}},H_=zE(xc,(e=>Math.tan(e))),q_={kernelName:xc,backendName:"cpu",kernelFunc:H_},K_=zE(wc,(e=>Math.tanh(e)));const X_={kernelName:qu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:o}=t,{sliceRank:i,numUpdates:s,sliceSize:u,strides:c,outputSize:l}=Rg(0,a,r.shape),h=n.bufferSync(a),d=n.bufferSync(o),p=n.bufferSync(r),f=XF(h,d,r.shape,l,u,s,i,c,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function Y_(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const r=Jh(n,e.dtype);for(let a=0;a<r.values.length;++a){const t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const o=e.locToIndex(n);r.values[a]=e.values[o]}return r}const Q_={kernelName:kc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:o}=r;_E(a,"tile");const i=Y_(n.bufferSync(a),o);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},Z_=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function J_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const a=r-n+1,o=t-n+1,i=Math.log(a),s=.5*Math.exp(2*i/3),u=.5*Math.sqrt(i*s*(a-s)/a)*Math.sign(o-a/2);J_(e,t,Math.max(n,Math.floor(t-o*s/a+u)),Math.min(r,Math.floor(t+(a-o)*s/a+u)))}const a=e[t];let o=n,i=r;for(Po(e,n,t),Z_(e[r],a)>0&&Po(e,n,r);o<i;){for(Po(e,o,i),o++,i--;Z_(e[o],a)<0;)o+=1;for(;Z_(e[i],a)>0;)i-=1}0===Z_(e[n],a)?Po(e,n,i):(i+=1,Po(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function $_(e,t,n,r,a){const o=t[t.length-1],[i,s]=[e.length/o,o],u=Jo(n,i*r),c=Jo("int32",i*r);for(let h=0;h<i;h++){const t=h*s,n=e.subarray(t,t+s);let o=new Array(n.length);n.forEach(((e,t)=>o[t]={value:e,index:t})),r<o.length&&(J_(o,r),o=o.slice(0,r)),a&&o.sort(Z_);const i=h*r,l=u.subarray(i,i+r),d=c.subarray(i,i+r);for(let e=0;e<r;e++)l[e]=o[e].value,d[e]=o[e].index}const l=t.slice();return l[l.length-1]=r,[Jh(l,n,u),Jh(l,"int32",c)]}const eR={kernelName:Cc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:o,sorted:i}=r;_E(a,"topk");const s=n.data.get(a.dataId).values,[u,c]=$_(s,a.shape,a.dtype,o,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}};const tR={kernelName:Dc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:o}=t,{interpolation:i,fillMode:s,fillValue:u,outputShape:c}=n,[l,h,d,p]=a.shape,[f,m]=null!=c?c:[h,d],g=[l,f,m,p],y=si(a.shape),b=y[0],v=y[1],x=y[2],w=si(g),k=w[0],C=w[1],D=w[2],S=Jo(a.dtype,Go(g));S.fill(u);const E=r.data.get(a.dataId).values,I=r.data.get(o.dataId).values;for(let N=0;N<l;++N){const e=1===o.shape[0]?I:I.subarray(8*N,8*N+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let a;const o=e[6]*n+e[7]*t+1;if(0===o)continue;const c=(e[0]*n+e[1]*t+e[2])/o,l=(e[3]*n+e[4]*t+e[5])/o,p=nR(c,d,s),f=nR(l,h,s);switch(i){case"nearest":a=aR(E,h,d,b,v,x,N,f,p,r,u);break;case"bilinear":a=oR(E,h,d,b,v,x,N,f,p,r,u);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(i))}S[N*k+t*C+n*D+r]=a}return r.makeTensorInfo(g,a.dtype,S)}return{dataId:r.write(S,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function nR(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Lo(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return Lo(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Lo(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function rR(e,t,n,r,a,o,i,s,u,c,l){return 0<=s&&s<t&&0<=u&&u<n?e[i*r+s*a+u*o+c]:l}function aR(e,t,n,r,a,o,i,s,u,c,l){return rR(e,t,n,r,a,o,i,Math.round(s),Math.round(u),c,l)}function oR(e,t,n,r,a,o,i,s,u,c,l){const h=Math.floor(s),d=Math.floor(u),p=h+1,f=d+1;return(p-s)*((f-u)*rR(e,t,n,r,a,o,i,h,d,c,l)+(u-d)*rR(e,t,n,r,a,o,i,h,f,c,l))+(s-h)*((f-u)*rR(e,t,n,r,a,o,i,p,d,c,l)+(u-d)*rR(e,t,n,r,a,o,i,p,f,c,l))}function iR(e,t,n,r){const a=Qo(t,n)[0],o=[1,n[0],1];for(let f=0;f<a;f++)o[0]*=n[f];o[1]=n[a];for(let f=a+1;f<n.length;f++)o[2]*=n[f];const i=new Map,s=new Int32Array(n[a]),u=new kl(o,r,e),c=[],l=1===o[0]&&1===o[2];for(let f=0;f<n[a];f++){let t;if(l)t=e[f].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(u.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)s[f]=n;else{const e=i.size;i.set(t,e),s[f]=e,c.push(f)}}const h=o.slice();h[1]=i.size;const d=new kl(h,r);c.forEach(((e,t)=>{for(let n=0;n<o[0];n++)for(let r=0;r<o[2];r++)d.set(u.get(n,e,r),n,t,r)}));const p=n.slice();return p[a]=h[1],{outputValues:d.values,outputShape:p,indices:s}}const sR={kernelName:Ec,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:o}=t;_E(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:s,outputShape:u,indices:c}=iR(i,a,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,s),r.makeTensorInfo([c.length],"int32",c)]}};const uR={kernelName:Ic,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:o}=r;o<0&&(o+=a.shape.length);const i=a.shape.length,s=a.shape[o],u=new Array(i-1);let c=0;for(let p=0;p<i;p++)p!==o&&(u[c++]=a.shape[p]);const l=new Array(i).fill(0),h=a.shape.slice();h[o]=1;const d=new Array(s);for(let p=0;p<d.length;p++){l[o]=p;const e=tN({inputs:{x:a},backend:n,attrs:{begin:l,size:h}});d[p]=gI({inputs:{x:e},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(e)}return d}};const cR={kernelName:Nc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:o}=t,{numSegments:i}=r;_E(a,"unsortedSegmentSum");const s=[],u=[],c=a.shape.length-o.shape.length;let l=o;for(let d=0;d<c;++d){const e=fT({inputs:{input:l},backend:n,attrs:{dim:d+1}});l=e,u.push(e)}for(let d=0;d<i;++d){const e=sl(d,"int32"),t=n.makeTensorInfo([],"int32",e),r=tT({inputs:{a:t,b:l},backend:n}),o=uI({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=XN({inputs:{a:o,b:a},backend:n}),c=QN({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});s.push(c),u.push(t),u.push(r),u.push(o),u.push(i),u.push(c)}const h=hF({inputs:s,backend:n,attrs:{axis:0}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},lR=[xI,kI,DI,EI,mI,II,FI,_I,RI,MI,zI,BI,WI,GI,HI,YI,QI,ZI,JI,vI,$I,rN,iN,uN,cN,cI,dN,fN,rI,mN,xN,kN,CN,DN,SN,EN,IN,TN,FN,_N,RN,MN,ON,zN,BN,PN,WN,UN,VN,GN,jN,HN,JN,PE,$N,nT,lT,pT,mT,bT,TT,FT,_T,OT,BT,PT,WT,VT,jT,KT,QT,UE,ZT,bN,$T,tA,rA,GE,iA,cA,hA,fA,gA,vA,wA,DA,SA,EA,TA,_A,RA,MA,OA,zA,LA,BA,PA,VA,GA,qA,YA,YN,ZA,$A,tF,rF,iF,sF,lF,dF,pF,gF,KE,bF,CF,EF,_F,MF,iI,wT,zF,YE,ZE,yI,LF,BF,PF,WF,UF,VF,jF,KF,YF,JF,$F,r_,eI,o_,s_,c_,nN,XA,d_,p_,m_,y_,v_,x_,w_,k_,S_,E_,T_,__,M_,z_,P_,V_,j_,ST,ZN,q_,{kernelName:wc,backendName:"cpu",kernelFunc:K_},X_,Q_,eR,tR,AI,sR,uR,cR,cF];for(const eG of lR)Gc(eG);const hR={},dR={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function pR(e,t){if(!(e in hR)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(xi().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete hR[e]}),!1),xi().getBool("SOFTWARE_WEBGL_ENABLED")&&(dR.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",dR)||n.getContext("experimental-webgl",dR);return n.getContext("webgl2",dR)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;hR[e]=n}const n=hR[e];return null==n||n.isContextLost()?(delete hR[e],pR(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),hR[e])}var fR,mR,gR;function yR(e,t){return[t,e]}function bR(e){const t=Go(e);return qo(Math.ceil(t/4))}function vR(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function xR(e,t){const n=e;let r,a,o,i,s,u,c,l,h,d;return 2===xi().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,o=n.RGBA16F,i=n.RGBA32F,s=n.RED,c=4,l=1,h=n.HALF_FLOAT,d=n.FLOAT,u=n.RGBA8):(r=e.RGBA,a=e.RGBA,o=e.RGBA,i=n.RGBA,s=e.RGBA,c=4,l=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,u=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:s,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:l,textureTypeHalfFloat:h,textureTypeFloat:d}}function wR(e,t){const n=t();return xi().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(fR||(fR={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(mR||(mR={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(gR||(gR={}));function kR(e){return!!(xi().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function CR(e,t){return _R(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const DR=/ERROR: [0-9]+:([0-9]+):/g;function SR(e,t){const n=DR.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const r=+n[1],a=e.split("\n"),o=a.length.toString().length+2,i=a.map(((e,t)=>Ko((t+1).toString(),o)+e));let s=0;for(let h=0;h<i.length;h++)s=Math.max(i[h].length,s);const u=i.slice(0,r-1),c=i.slice(r-1,r),l=i.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(Ko(c[0],s)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join("\n"))}function ER(e,t){if(wR(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function IR(e,t,n,r,a,o,i){const s=e.getAttribLocation(t,n);return-1!==s&&(wR(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),wR(e,(()=>e.vertexAttribPointer(s,a,e.FLOAT,!1,o,i))),wR(e,(()=>e.enableVertexAttribArray(s))),!0)}function NR(e,t,n,r){wR(e,(()=>function(e,t,n){RR(e,n),wR(e,(()=>e.activeTexture(e.TEXTURE0+n))),wR(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),wR(e,(()=>e.uniform1i(n,r)))}function TR(e,t,n){wR(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),wR(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function AR(e,t){wR(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),wR(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function FR(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function _R(e,t,n){const r=wR(e,(()=>t()));if(null==r)throw new Error(n);return r}function RR(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function MR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Go(e.slice(0,e.length-t))}function OR(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function zR(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[MR(e),...OR(e)]),t}function LR(e){return e%2===0}function BR(e,t){if(jo(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(LR(n)&&LR(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&LR(e[0])&&LR(t[0])}let PR,WR;function UR(e,t){return null!=e.getExtension(t)}function VR(e){try{if(null!=pR(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function GR(e){if(0===e)return!1;const t=pR(e);if(1!==e){if(UR(t,"EXT_color_buffer_float"))return jR(t);const e="EXT_color_buffer_half_float";if(UR(t,e)){const n=t.getExtension(e);return function(e,t){const n=xR(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const a=1,o=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),s}(t,n)}return!1}if(!UR(t,"OES_texture_float"))return!1;if(!UR(t,"WEBGL_color_buffer_float"))return!1;return jR(t)}function jR(e){const t=xR(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function HR(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Wo("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend."))}))}const qR=xi();function KR(){let e,t,n,r,a,o,i,s,u,c;return 2===xi().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",o="outputColor",i="out vec4 outputColor;",s=xi().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",o="gl_FragColor",i="",s="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:o,defineOutput:i,defineSpecialNaN:s,defineSpecialInf:u,defineRound:c}}function XR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=si(t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / ").concat(t),i=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * ").concat(t):"index -= ".concat(e[a]," * ").concat(t);return"".concat(o,"; ").concat(i,";")})).join("")}function YR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=si(t);return r.map(((t,a)=>{const o="int ".concat(e[a]," = ").concat(n," / outShapeStrides[").concat(a,"]"),i=a===r.length-1?"int ".concat(e[a+1]," = ").concat(n," - ").concat(e[a]," * outShapeStrides[").concat(a,"]"):"index -= ".concat(e[a]," * outShapeStrides[").concat(a,"]");return"".concat(o,"; ").concat(i,";")})).join("")}function QR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=e.map(((e,t)=>t)),a=function(e,t){const n=e.length,r=e.map((e=>"".concat(t,"[").concat(e,"]"))),a=new Array(n-1);a[n-2]=r[n-1];for(let o=n-3;o>=0;--o)a[o]="(".concat(a[o+1]," * ").concat(r[o+1],")");return a}(r,t);return a.map(((t,r)=>{const o="int ".concat(e[r]," = ").concat(n," / ").concat(a[r]),i=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(a[r]):"index -= ".concat(e[r]," * ").concat(a[r]);return"".concat(o,"; ").concat(i,";")})).join("")}function ZR(e){const t=si(e).map((e=>e.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}qR.registerFlag("HAS_WEBGL",(()=>qR.getNumber("WEBGL_VERSION")>0)),qR.registerFlag("WEBGL_VERSION",(()=>VR(2)?2:VR(1)?1:0)),qR.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),qR.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===qR.get("WEBGL_VERSION"))),qR.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),qR.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),qR.registerFlag("WEBGL_PACK",(()=>qR.getBool("HAS_WEBGL"))),qR.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_PACK_CLIP",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_PACK_REDUCE",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_LAZILY_UNPACK",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_CONV_IM2COL",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>qR.getBool("WEBGL_PACK"))),qR.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==PR){const t=pR(e);PR=t.getParameter(t.MAX_TEXTURE_SIZE)}return PR}(qR.getNumber("WEBGL_VERSION")))),qR.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==WR){const t=pR(e);WR=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,WR)}(qR.getNumber("WEBGL_VERSION")))),qR.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=qR.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=pR(e);return t=UR(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:UR(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),qR.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>qR.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ql())),qR.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=pR(e);if(1===e){if(!UR(t,"OES_texture_float"))return!1}else if(!UR(t,"EXT_color_buffer_float"))return!1;return jR(t)}(qR.getNumber("WEBGL_VERSION")))),qR.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!qR.getBool("WEBGL_FORCE_F16_TEXTURES")&&qR.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),qR.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>GR(qR.getNumber("WEBGL_VERSION")))),qR.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=qR.getNumber("WEBGL_VERSION"))&&null!=pR(e).fenceSync;var e})),qR.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>qR.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),qR.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))})),qR.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Ql()?1:-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))})),qR.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),qR.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),qR.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),qR.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),qR.registerFlag("WEBGL_EXP_CONV",(()=>!1)),qR.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>qR.getBool("IS_TEST"))),qR.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),qR.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),qR.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),qR.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const JR="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:$R}=n;function eM(e,t,n){const r=[];if(e.forEach((e=>{const t=Go(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(r.push("uniform sampler2D ".concat(e.name,";")),r.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=lM(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push("uniform int ".concat(e.name,"Shape;"));break;case 2:r.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:r.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:r.push("uniform ivec4 ".concat(e.name,"Shape;"))}r.push("uniform ivec2 ".concat(e.name,"TexShape;"))}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))}));const a=r.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?nM(e,r):tM(e,r);const o=e.shapeInfo.logicalShape,i=t.logicalShape;o.length<=i.length&&(a+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,s=$R(e.shapeInfo.logicalShape,t.logicalShape),u=cM(i),c=i-o;let l;const h=["x","y","z","w","u","v"];l=0===o?"":i<2&&s.length>=1?"coords = 0;":s.map((e=>"coords.".concat(h[e+c]," = 0;"))).join("\n");let d="";d=i<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(h[t+c]))).join(", ");let p="return outputValue;";const f=1===Go(e.shapeInfo.logicalShape),m=Go(t.logicalShape),g=1===m;if(1!==o||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(s.length){const e=o-2,t=o-1;s.indexOf(e)>-1&&s.indexOf(t)>-1?p="return vec4(outputValue.x);":s.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":s.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(a,"() {\n      ").concat(u," coords = getOutputCoords();\n      ").concat(l,"\n      vec4 outputValue = get").concat(r,"(").concat(d,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",o=t.texShape,i=e.shapeInfo.texShape,s=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&s===u&&null==e.shapeInfo.flatOffset&&jo(i,o))return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const c=cM(u),l=$R(e.shapeInfo.logicalShape,t.logicalShape),h=u-s;let d;const p=["x","y","z","w","u","v"];d=0===s?"":u<2&&l.length>=1?"coords = 0;":l.map((e=>"coords.".concat(p[e+h]," = 0;"))).join("\n");let f="";f=u<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(p[t+h]))).join(", ");return"\n    float ".concat(a,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(d,"\n      return get").concat(r,"(").concat(f,");\n    }\n  ")}(e,t));return a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,s=KR(),u=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(s);let c,l,h=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(rM,"\n    ").concat(aM,"\n    ").concat(oM,"\n  ");return t}(s);t.isPacked?(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(r[1],".0);\n      }\n    ");if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(r[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      return 2 * (resTexRC.x * ").concat(r[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(jo(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(r[0],", ").concat(r[1],"));\n      }\n    ");const a=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),o=a*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),o=a*Math.ceil(e[e.length-2]/2);let i=o,s="",u="b, r, c";for(let c=2;c<e.length-1;c++)i*=e[e.length-c-1],s="\n      int b".concat(c," = index / ").concat(i,";\n      index -= b").concat(c," * ").concat(i,";\n    ")+s,u="b".concat(c,", ")+u;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(r[0],", ").concat(r[1],"));\n      int index = resTexRC.x * ").concat(r[1]," + resTexRC.y;\n\n      ").concat(s,"\n\n      int b = index / ").concat(o,";\n      index -= b * ").concat(o,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec").concat(e.length,"(").concat(u,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),l=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(s)):(c=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(jo(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=YR(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const r=XR(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=YR(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const r=XR(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(r,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=XR(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=XR(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,i,n.enableShapeUniforms),l=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(s)),n.packedInputs&&(h+=iM);return[h,u,l,a,c,o,n.userCode].join("\n")}function tM(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(r,"() {return ").concat(n,";}");const[a,o]=e.shapeInfo.texShape;if(1===a&&1===o)return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=sM(n);if(t)return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[s,u]=e.shapeInfo.texShape;return"\n    float ".concat(r,"() {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(u,", ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int index) {\n        ").concat(uM(e),"\n      }\n    ");const a=e.shapeInfo.texShape,o=a[0],i=a[1];if(1===i&&1===o)return"\n      float ".concat(r,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const s=sM(n);if(1===i)return t?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(s,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(s,") + 0.5) / ").concat(o,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===o)return t?"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(s,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(r,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(s,") + 0.5) / ").concat(i,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int index) {\n      vec2 uv = uvFromFlat(").concat(o,", ").concat(i,", index + ").concat(s,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape;if(null!=o&&jo(n,o)){if(t)return"\n      float ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const e=o[0],n=o[1];return"\n    float ".concat(a,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}const{newShape:i,keptDims:s}=Zo(n),u=i;if(u.length<n.length){const n=hM(e,u),r=["row","col"];return"\n      ".concat(tM(n,t),"\n      float ").concat(a,"(int row, int col) {\n        return ").concat(a,"(").concat(dM(r,s),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(uM(e),"\n      }\n    ");const c=o[0],l=o[1],h=sM(r);if(1===l)return t?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(r,"TexShape[0]));\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(c,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(1===c)return t?"\n      float ".concat(a,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(r,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(r,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(l,".0, 0.5);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");if(t)return"\n      float ".concat(a,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");return"\n  float ".concat(a,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(c,", ").concat(l,", index);\n    return sampleTexture(").concat(r,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[1]*n[2],i=n[2],{newShape:s,keptDims:u}=Zo(n),c=s;if(c.length<n.length){const n=hM(e,c),r=["row","col","depth"];return"\n        ".concat(tM(n,t),"\n        float ").concat(a,"(int row, int col, int depth) {\n          return ").concat(a,"(").concat(dM(r,u),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(o,", ").concat(i,", 1)));\n        ").concat(uM(e),"\n      }\n    ");const l=e.shapeInfo.texShape,h=l[0],d=l[1],p=e.shapeInfo.flatOffset;if(d===o&&null==p)return t?"\n      float ".concat(a,"(int row, int col, int depth) {\n        int stride1 = ").concat(r,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n        float ".concat(a,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(i,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d,".0, ").concat(h,".0);\n          return sampleTexture(").concat(r,", uv);\n        }\n      ");if(d===i&&null==p)return t?"\n      float ".concat(a,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(r,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n    float ".concat(a,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d,".0, ").concat(h,".0);\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");const f=sM(r);if(t)return"\n    float ".concat(a,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(r,"Shape[1] * ").concat(r,"Shape[2];\n      int stride1 = ").concat(r,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index);\n      return sampleTexture(").concat(r,", uv);\n    }\n    ");return"\n      float ".concat(a,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(o," + col * ").concat(i," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(d,", index);\n        return sampleTexture(").concat(r,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n[3],i=n[2]*o,s=n[1]*i,{newShape:u,keptDims:c}=Zo(n);if(u.length<n.length){const n=hM(e,u),r=["row","col","depth","depth2"];return"\n      ".concat(tM(n,t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2) {\n        return ").concat(a,"(").concat(dM(r,c),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(s,", ").concat(i,", ").concat(o,", 1)));\n        ").concat(uM(e),"\n      }\n    ");const l=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f="int stride2 = ".concat(r,"Shape[3];"),m="int stride1 = ".concat(r,"Shape[2] * stride2;"),g="int stride0 = ".concat(r,"Shape[1] * stride1;");if(p===s&&null==l)return t?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(i,", ").concat(o,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");if(p===o&&null==l)return t?"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(r,"Shape[1] * ").concat(r,"Shape[2], ").concat(r,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n        return sampleTexture(").concat(r,", uv);\n      }\n    "):"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(r,", uv);\n      }\n    ");const y=sM(r);if(t)return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(r,"TexShape[0], ").concat(r,"TexShape[1], index + ").concat(y,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(s," + col * ").concat(i," +\n          depth * ").concat(o," + depth2;\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index + ").concat(y,");\n      return sampleTexture(").concat(r,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],o=t[3]*a,i=t[2]*o,s=t[1]*i,{newShape:u,keptDims:c}=Zo(t);if(u.length<t.length){const t=hM(e,u),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(tM(t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(r,"(").concat(dM(n,c),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(s,", ").concat(i,", ").concat(o,", ").concat(a,")) +\n          depth3;\n        ").concat(uM(e),"\n      }\n    ");const l=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===s&&null==l)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(i,", ").concat(o,", ").concat(a,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===a&&null==l)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=sM(n);return"\n    float ".concat(r,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(s," + col * ").concat(i," + depth * ").concat(o," +\n          depth2 * ").concat(a," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:o}=Zo(t);if(a.length<t.length){const t=hM(e,a),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(tM(t),"\n      float ").concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(r,"(").concat(dM(n,o),");\n      }\n    ")}const i=t[5],s=t[4]*i,u=t[3]*s,c=t[2]*u,l=t[1]*c;if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(l,", ").concat(c,", ").concat(u,", ").concat(s,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(i,", 1)));\n        ").concat(uM(e),"\n      }\n    ");const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===l&&null==h)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(c,", ").concat(u,", ").concat(s,", ").concat(i,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===i&&null==h)return"\n      float ".concat(r,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=sM(n);return"\n    float ".concat(r,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(l," + col * ").concat(c," + depth * ").concat(u," +\n          depth2 * ").concat(s," + depth3 * ").concat(i," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function nM(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=KR();return"\n    vec4 ".concat(n,"() {\n      return ").concat(r.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,o=KR();if(t)return"\n    vec4 ".concat(r,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ");const i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return"\n    vec4 ".concat(r,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(i[0],", ").concat(i[1],", index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,i=o[0],s=o[1],u=KR();if(null!=o&&jo(n,o))return t?"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r,"TexShape[1], ").concat(r,"TexShape[0]);\n\n        return ").concat(u.texture2D,"(").concat(r,", uv);\n      }\n    "):"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s,".0, ").concat(i,".0);\n\n        return ").concat(u.texture2D,"(").concat(r,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(a,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(u.texture2D,"(").concat(r,", uv);\n    }\n  ");const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(l,", ").concat(c[0],", ").concat(c[1],", row, col);\n      return ").concat(u.texture2D,"(").concat(r,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===n[0]){const r=[1,2],o=hM(e,n.slice(1)),i=["b","row","col"];return"\n        ".concat(nM(o,t),"\n        vec4 ").concat(a,"(int b, int row, int col) {\n          return ").concat(a,"(").concat(dM(i,r),");\n        }\n      ")}const s=KR();if(t)return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r,"TexShape[0]) / 2.0), ceil(float(").concat(r,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(r,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(s.texture2D,"(").concat(r,", uv);\n    }\n  ");const u=i[0],c=i[1],l=Math.ceil(n[2]/2),h=l*Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(u,", ").concat(c,", ").concat(h,", ").concat(l,", b, row, col);\n      return ").concat(s.texture2D,"(").concat(r,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=KR();if(t)return"\n    vec4 ".concat(r,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=e.shapeInfo.logicalShape,i=o.length,s=e.shapeInfo.texShape,u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=u[0],l=u[1],h=Math.ceil(o[i-1]/2);let d=h*Math.ceil(o[i-2]/2),p="int b, int row, int col",f="b * ".concat(d," + (row / 2) * ").concat(h," + (col / 2)");for(let m=2;m<i-1;m++)p="int b".concat(m,", ")+p,d*=o[i-m-1],f="b".concat(m," * ").concat(d," + ")+f;return"\n    vec4 ".concat(r,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(l,";\n      int texC = index - texR * ").concat(l,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(l,", ").concat(c,");\n      return ").concat(a.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const rM="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",aM="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",oM="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",iM="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function sM(e){return"offset".concat(e)}function uM(e){const t=e.name,n=Go(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function cM(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function lM(e,t,n){const{newShape:r,keptDims:a}=Zo(t),o=t.length,i=e&&3===o&&1===t[0],s=i?t.slice(1):r,u=!e&&o>1&&!jo(t,n)&&r.length<o||i;return{useSqueezeShape:u,uniformShape:u?s:t,keptDims:a}}function hM(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function dM(e,t){return t.map((t=>e[t])).join(", ")}function pM(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),o=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},s=eM(a,i,t),u=function(e,t){const n=_R(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(wR(e,(()=>e.shaderSource(n,t))),wR(e,(()=>e.compileShader(n))),xi().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw SR(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,s),c=e.createProgram(u);return xi().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:s,webGLProgram:c,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:u,source:s,webGLProgram:c,inShapeInfos:o,outShapeInfo:i},fM(e,t,c)))}function fM(e,t,n){const r=[],a=[];let o,i,s,u=null,c=null;c=e.getUniformLocation(n,"NAN",!1),1===xi().getNumber("WEBGL_VERSION")&&(u=e.getUniformLocation(n,"INFINITY",!1));const l=!1;for(const h of t.variableNames){const a={name:h,uniform:e.getUniformLocation(n,h,l),offset:e.getUniformLocation(n,"offset".concat(h),l)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,"".concat(h,"Shape"),l),a.texShape=e.getUniformLocation(n,"".concat(h,"TexShape"),l)),r.push(a)}if(t.enableShapeUniforms&&(o=e.getUniformLocation(n,"outShape",l),s=e.getUniformLocation(n,"outShapeStrides",l),i=e.getUniformLocation(n,"outTexShape",l)),t.customUniforms)for(const h of t.customUniforms)a.push(e.getUniformLocation(n,h.name,l));return{variablesLocations:r,customUniformLocations:a,infLoc:u,nanLoc:c,outShapeLocation:o,outShapeStridesLocation:s,outTexShapeLocation:i}}function mM(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach(((e,n)=>{const r=e.logicalShape,a=t[n],o=a.shape;if(!jo(r,o))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(r," and ").concat(o," must match"));if(e.isUniform&&a.isUniform)return;const i=e.texShape,s=a.isUniform?null:a.texData.texShape;if(!jo(i,s))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(i," and ").concat(s," must match"))}))}function gM(e){return xi().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class yM{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=fR.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=KR();this.outputShape=e,this.enableShapeUniforms=gM(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?YR(["r","c","d"],e):XR(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class bM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=fR.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=KR();this.outputShape=e,this.enableShapeUniforms=gM(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?YR(["r","c","d"],e):XR(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class vM{constructor(e){this.variableNames=["A"],this.outTexUsage=mR.DOWNLOAD;const t=KR();this.outputShape=e,this.userCode="\n      ".concat(JR,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class xM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=mR.DOWNLOAD;const t=KR();this.outputShape=e,this.userCode="\n      ".concat(JR,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const wM={R:0,G:1,B:2,A:3};class kM{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=KR();this.outputShape=e,this.enableShapeUniforms=gM(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let o="";for(let i=0;i<n.length;i++){const e=n[i];o+="\n          if(offset == ".concat(i,") {\n            result = values[").concat(wM[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":ZR(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(r.texture2D,"(A, uv);\n          ").concat(o,"\n        }\n        ").concat(r.output," = vec4(").concat(a,", 0., 0., 0.);\n      }\n    ")}}class CM{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=KR();this.outputShape=e,this.enableShapeUniforms=gM(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let t=0;t<=1;t++){const a=2*o+t;r+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(o," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(o,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(a,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(a,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(a,"] = values[2];\n            } else {\n              result[").concat(a,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":ZR(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(r,"\n\n          ").concat(n.output," = ").concat(a,";\n        }\n    ")}}function DM(e){const t=KR();return function(e,t){const n=_R(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(wR(e,(()=>e.shaderSource(n,t))),wR(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function SM(e){return function(e,t){const n=_R(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wR(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),wR(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function EM(e){return function(e,t){const n=_R(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return wR(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),wR(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function IM(e,t,n,r,a,o){!function(e,t){const n=xi().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const r="[".concat(e,"x").concat(t,"]"),a="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}(t,n);const i=function(e){return _R(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),s=e.TEXTURE_2D;return wR(e,(()=>e.bindTexture(s,i))),wR(e,(()=>e.texParameteri(s,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),wR(e,(()=>e.texParameteri(s,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),wR(e,(()=>e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST))),wR(e,(()=>e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===xi().getNumber("WEBGL_VERSION")?wR(e,(()=>e.texImage2D(s,0,r,t,n,0,a,o,null))):wR(e,(()=>e.texStorage2D(s,1,r,t,n))),wR(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function NM(e){return e.internalFormatFloat}function TM(e){return e.internalFormatHalfFloat}function AM(e){return e.downloadTextureFormat}function FM(e){return e.internalFormatPackedFloat}function _M(e){return e.internalFormatPackedHalfFloat}function RM(e,t,n,r,a,o,i,s){const u=e,c=new Float32Array(function(e,t){const[n,r]=vR(e,t);return n*r*4}(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}class MM{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=xi().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){hR[e]=t}(t,e)):this.gl=pR(t),e=this.gl,2===xi().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>wR(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>wR(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>wR(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>wR(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>wR(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>wR(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>wR(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>wR(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===xi().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=CR(this.gl,e),UR(this.gl,t))this.textureHalfFloatExtension=CR(this.gl,t);else if(xi().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),UR(this.gl,r))this.colorBufferHalfFloatExtension=CR(this.gl,r);else if(xi().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",UR(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!UR(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=SM(this.gl),this.indexBuffer=EM(this.gl),this.framebuffer=function(e){return _R(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=xR(this.gl,this.textureHalfFloatExtension)}get debug(){return xi().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;wR(e,(()=>e.finish())),wR(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),wR(e,(()=>e.deleteFramebuffer(this.framebuffer))),wR(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),wR(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),wR(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=yR(t,n);return IM(e,a,o,NM(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=yR(t,n);return IM(e,a,o,TM(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=yR(t,n);return IM(e,a,o,AM(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){wR(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===xi().getNumber("WEBGL_VERSION")?wR(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):wR(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===xi().getNumber("WEBGL_VERSION")?wR(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):wR(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),wR(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,a,o){let i,s,u;wR(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),s=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*r*4),s=e.FLOAT,u=o.internalFormatPackedFloat),i.set(a),2===xi().getNumber("WEBGL_VERSION")?wR(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,s,i))):wR(e,(()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,s,i))),wR(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=vR(t,n);return IM(e,a,o,_M(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,o]=vR(t,n);return IM(e,a,o,FM(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(AR(this.gl,this.framebuffer),this.outputTexture=null),wR(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[a,o]=yR(t,n),i=new Uint8Array(t*n*4);return wR(e,(()=>e.readPixels(0,0,a,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,o){return RM(this.gl,e,0,0,0,a,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();wR(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const a=16*t*n;return wR(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ))),wR(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),wR(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(xi().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return wR(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=DM(t));const n=function(e){return _R(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);wR(t,(()=>t.attachShader(n,this.vertexShader))),wR(t,(()=>t.attachShader(n,e))),function(e,t){if(wR(e,(()=>e.linkProgram(t))),!xi().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&ER(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;wR(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){wR(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),IR(e,t,"clipSpacePos",n,3,20,0)&&IR(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(wR(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&ER(this.gl,this.program),wR(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return _R(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),wR(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),NR(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=vR(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&ER(this.gl,this.program),FR(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}wR(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),wR(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=CR(this.gl,2===xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Xo((()=>this.disposed||this.isQueryAvailable(e,xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in xi().platform&&(n=xi().platform.setTimeoutCustom.bind(xi().platform)),Xo((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),TR(this.gl,e,this.framebuffer),this.debug&&FR(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(TR(this.gl,this.outputTexture,this.framebuffer),this.debug&&FR(this.gl)):AR(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;TR(r,e,this.framebuffer),this.debug&&FR(r),this.outputTexture=e,wR(r,(()=>r.viewport(0,0,t,n))),wR(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),wR(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:OM,XI:zM,Nk:LM,f6:BM,ct:PM,YG:WM,hH:UM,z3:VM,sG:GM,uM:jM,vS:HM,qB:qM,GG:KM,rq:XM,lg:YM,WR:QM,cu:ZM,GE:JM,px:$M,jC:eO,He:tO,hE:nO,BF:rO,Dk:aO,cl:oO,_B:iO,ub:sO,_f:uO,Ku:cO,qy:lO,Zy:hO,bu:dO,zv:pO,dH:fO,HS:mO,yH:gO,l3:yO,z9:bO,x6:vO,_m:xO,eW:wO,GK:kO,SP:CO,yr:DO,dl:SO,Dw:EO,xT:IO,_X:NO,wz:TO}=r;function AO(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>"".concat(e,".").concat(t)))}function FO(e,t){return 1===t?[e]:AO(e,t)}class _O{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=gM(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=FO("rc",this.rank),t=cM(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(r,"\n\n            setOutput(vec4(").concat(a,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a="".concat(0===n?"r":"rp1",", ").concat(0===r?"c":"cp1");for(let t=2;t<this.rank;t++)a="".concat(e[e.length-1-t],",")+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],r=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(r,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class RO{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=gM(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(r,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(r>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?QR(["r","c","d"],"inputShape"):XR(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":ZR(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class MO{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=zO(t,n),a=LO(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const o=OO(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}let i;return r===gR.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===gR.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===gR.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===gR.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===gR.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=zO(n,r),o=LO(t,a,r);o in this.freeTextures||(this.freeTextures[o]=[]);const i=OO(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),s=xi().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==s&&this._numBytesAllocated>s?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[o],c=u&&u.indexOf(e);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function OO(e,t,n,r,a){const o=function(e,t){switch(e){case gR.PACKED_2X2_FLOAT32:return FM(t);case gR.PACKED_2X2_FLOAT16:return _M(t);case gR.UNPACKED_FLOAT32:return NM(t);case gR.UNPACKED_FLOAT16:return TM(t);case gR.PACKED_4X1_UNSIGNED_BYTE:return AM(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,r);let i;if(a){const[t,n]=vR(e[0],e[1]);i=t*n}else{const[t,n]=yR(e[0],e[1]);i=t*n}const s=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,o);return i*s}function zO(e,t){if(e===mR.UPLOAD)return gR.PACKED_2X2_FLOAT32;if(e===mR.RENDER||null==e)return function(e){return xi().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?gR.PACKED_2X2_FLOAT32:gR.UNPACKED_FLOAT32:e?gR.PACKED_2X2_FLOAT16:gR.UNPACKED_FLOAT16}(t);if(e===mR.DOWNLOAD||e===mR.PIXELS)return gR.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function LO(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class BO{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=gM(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const PO="if (isnan(x)) return x;",WO="return abs(x);";const UO=PO+"\n  return (x < 0.0) ? 0.0 : x;\n",VO=PO+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",GO="return x;";class jO{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=gM(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class HO{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=gM(this.outputShape.length);const t=e.length,n=FO("rc",t),r=cM(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),i=t<=1?"rc":"vec2(".concat(o.join(","),")");this.userCode="\n      void main() {\n        ".concat(r," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(a,");\n\n        setOutput(getChannel(packedInput, ").concat(i,"));\n      }\n    ")}}const qO=Dy,KO={};const XO=xi().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class YO extends Mo{nextDataId(){return YO.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!xi().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof MM)t=e;else{const n=pR(xi().getNumber("WEBGL_VERSION"),e);t=new MM(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=pR(xi().getNumber("WEBGL_VERSION"));t=new MM(e),this.binaryCache=((n=xi().getNumber("WEBGL_VERSION"))in KO||(KO[n]={}),KO[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new MO(this.gpgpu),this.numMBBeforeWarning=null==xi().global.screen?1024:xi().global.screen.height*xi().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Ro(this,ch())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,o){const i=this.makeTensorInfo(t,n),s=this.texData.get(i.dataId);s.isPacked=!1,s.texture={texture:e,texShape:[r,a]},s.texShape=[r,a];const u=zR(t),c=new kM(u,!1,o),l=this.runWebGLProgram(c,[i],n,[[r,a]]);return l.shape=t,s.texture=null,this.disposeIntermediateTensorInfo(i),l.dataId}write(e,t,n){if((xi().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||xi().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:mR.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(xi().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:mR.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:o,shape:i,isPacked:s}=t;if(null!=o){let t;t=s?new jO(i,GO):new BO(i,GO);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let c,l;if(u&&(c=cl()),"complex64"===r){l=Vg(this.readSync(a.real.dataId),this.readSync(a.imag.dataId))}else l=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=cl()-c),this.convertAndCacheOnCPU(e,l)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:o,complexTensorInfos:i,isPacked:s}=t;if(null!=a){let t;t=s?new jO(r,GO):new BO(r,GO);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:o}],o),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(xi().getBool("DEBUG")&&!xi().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===xi().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,c,l=null;if("complex64"!==o&&xi().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);l=this.gpgpu.createBufferFromTexture(t.texture.texture,...bR(r))}if(this.pendingRead.set(e,[]),"complex64"!==o&&await this.gpgpu.createAndWaitForFence(),"complex64"===o){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);c=Vg(e[0],e[1])}else if(null==l)c=this.getValuesFromTexture(e);else{const e=Go(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(l,e)}if(null!=u&&this.disposeIntermediateTensorInfo(u),null!=l){const e=this.gpgpu.gl;wR(e,(()=>e.deleteBuffer(l)))}const h=this.convertAndCacheOnCPU(e,c),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ch().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:r,shape:a,slice:o,dtype:i,isPacked:s,texture:u}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let n;n=s?new jO(a,GO):new BO(a,GO);const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),o=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),o}if(null==u)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),l=ch().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:l},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>hl(e)));return Jh(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Jh(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!kR(n)){if(xi().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=Go(t);if(xi().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...bR(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),o}const o=xi().getBool("WEBGL_PACK")&&!0===r,i=o?zR(t):t,s=o?new xM(i):new vM(i),u=this.runWebGLProgram(s,[{shape:i,dtype:n,dataId:e}],"float32"),c=this.texData.get(u.dataId),l=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(u),l}timerAvailable(){return xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=pl(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),o=pl(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:o[t],ms:e}))).map((e=>"".concat(e.name,": ").concat(e.ms))).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:cl(),endMs:null}}endTimer(e){return xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=cl(),e)}async getQueryTime(e){if(xi().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:o,slice:i}=this.texData.get(e),s=i&&i.origDataId||e,u=this.dataRefCount.get(s);u>1?this.dataRefCount.set(s,u-1):(this.dataRefCount.delete(s),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,o)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:XO;return xi().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Go(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){zc("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return qO(e.shape,t)}packedUnaryOp(e,t,n){const r=new jO(e.shape,t),a=this.compileAndRun(r,[e],n);return ch().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=fO(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(xi().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,WO,e.dtype);const t=new BO(e.shape,WO),n=this.compileAndRun(t,[e]);return ch().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ni(n[0])){const a=n.map((e=>ll(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return ch().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new HO(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new _O(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[MR(e.shape),...OR(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[MR(t),...OR(t)],o=new RO(a,n),i=[n],s=this.runWebGLProgram(o,[r],e.dtype,i,!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:o}=n;if(null!=t){Wo(Go(a)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=zR(a);let s;s=r?new bM(i):new yM(i);const u=[null!=t?t:bR(i)];return{dtype:o,shape:a,dataId:this.runWebGLProgram(s,[{shape:i,dtype:o,dataId:e}],o,u,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),s=this.texData.get(i.dataId);if(e.packedOutput&&(s.isPacked=!0),e.outPackingScheme===fR.DENSE){const t=null!=o?o:bR(e.outputShape);s.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(s.usage=e.outTexUsage),0===Go(i.shape))return s.values=Jo(i.dtype,0),i;const u=[],c=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Go(t.shape)<=xi().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!BR(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),u.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const l={shape:i.shape,texData:s,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:i,uniformShape:s,keptDims:u}=lM(e.packedInputs,t.shape,o);let c="",l="",h="";if(1===s.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];c="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==s.length||e.packedInputs){if(s.length>2&&!e.packedInputs){const e=si(s);h="".concat(e[0]===o[1],"_").concat(e[e.length-1]===o[1])}}else l="".concat(s[0]>1,"_").concat(s[1]>1);const d=t.shape.length,p=2===s.length&&jo(t.shape,o),f=1===Go(t.shape),m=Cd(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&jo(o,n.texData.texShape),y=e.packedInputs||s.length>2?"":"".concat(o[0]>1,"_").concat(o[1]>1);r+="".concat(d,"_").concat(g,"_").concat(i?u:"","_").concat(s.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(c,"_").concat(l,"_").concat(h,"_").concat(y,"_").concat(a)}else{const e=t.isUniform?"uniform":t.texData.texShape;r+="".concat(t.shape,"_").concat(e,"_").concat(a)}}));const a=e.userCode;let o=e.constructor.name;return o+="_"+r+"_"+a+"".concat(xi().getNumber("WEBGL_VERSION")),o}(e,c,l),d=this.getAndSaveBinary(h,(()=>pM(this.gpgpu,e,c,l))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),xi().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(mM(t.inShapeInfos,n),mM([t.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):e.setOutputMatrixTexture(o.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===xi().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<n.length;++u){const r=n[u],{uniform:a,offset:o,shape:i,texShape:s}=t.variablesLocations[u];if(i){const{uniformShape:n}=lM(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(s&&e.gl.uniform2i(s,r.texData.texShape[0],r.texData.texShape[1]),null!=a)if(r.isUniform)if(Go(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=r.texData.slice&&null!=o&&e.gl.uniform1i(o,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,u)}const s=t.outShapeLocation;if(s)switch(r.shape.length){case 1:e.gl.uniform1iv(s,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(s,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(s,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(s,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=si(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let u=0;u<t.program.customUniforms.length;++u){const n=t.program.customUniforms[u],r=t.customUniformLocations[u],o=a[u];if("float"===n.type)e.gl.uniform1fv(r,o);else if("vec2"===n.type)e.gl.uniform2fv(r,o);else if("vec3"===n.type)e.gl.uniform3fv(r,o);else if("vec4"===n.type)e.gl.uniform4fv(r,o);else if("int"===n.type)e.gl.uniform1iv(r,o);else if("ivec2"===n.type)e.gl.uniform2iv(r,o);else if("ivec3"===n.type)e.gl.uniform3iv(r,o);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(r,o)}}e.executeProgram()}(this.gpgpu,d,c,l,r),u.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=xi().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=cl();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!xi().getBool("WEBGL_LAZILY_UNPACK")&&s.isPacked&&!1===a){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!xi().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=hh((()=>{if(!xi().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=xi().getBool("DEBUG");xi().set("DEBUG",!1);const t=this.abs(cd(1e-8)).dataSync()[0];if(xi().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:o,usage:i,isPacked:s}=t;if(null!=o)return;const u=null!=this.activeTimers;let c;u&&(c=cl());let l=t.texShape;if(null==l&&(l=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=xi().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=xi().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&xi().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,e=e.map(((t,n)=>n>=e.length-2?Bo(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length){const t=Zo(e);e=t.newShape}let a=Go(e),o=null;e.length<=1&&a<=n?o=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?o=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?o=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?o=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?o=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(o=[e[0],e[1]*e[2]*e[3]]);const i=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||i)if(t){const t=MR(e);let n=2,r=2;e.length&&([n,r]=OR(e)),a=t*(n/2)*(r/2),o=qo(a).map((e=>2*e))}else o=qo(a);return o}(n,s),t.texShape=l),null!=a){const e=zR(n);let o,i=l[1],h=l[0];const d=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!s&&d||([i,h]=vR(l[0],l[1])),o=s?new CM(e,d):new kM(e,d);const p=d?[h,i]:l,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=d?mR.PIXELS:mR.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,h,a);const g=[[h,i]],y=!0,b=this.runWebGLProgram(o,[f],r,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,xi().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=cl()-c)}else{const e=this.acquireTexture(l,i,r,s);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*ti(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await fg(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw SR(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:s}=fM(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=o,e.outShapeStridesLocation=i,e.outTexShapeLocation=s}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:o,channels:i}=e,s=ch().backend;if(!s.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=s.writeTexture(r,t,n,a,o,i);return ch().makeTensorFromDataId(u,t,n,s)}}YO.nextDataId=0;Zl()&&fh("webgl",(()=>new YO),2);const QO="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class ZO{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Sd(t,n),this.enableShapeUniforms=gM(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const JO="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class $O{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Sd(t,n);const a=this.outputShape.length;this.enableShapeUniforms=gM(a);let o="";if(r)if(0===a||1===Go(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=cM(a);if(o="\n          ".concat(e," coords = getOutputCoords();\n        "),1===a)this.enableShapeUniforms?o+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":o+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=FO("coords",a);this.enableShapeUniforms?o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[a-2]," + 1) >= outShape[").concat(a," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[a-1]," + 1) >= outShape[").concat(a," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):o+="\n            bool nextRowOutOfBounds =\n              (".concat(e[a-2]," + 1) >= ").concat(this.outputShape[a-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[a-1]," + 1) >= ").concat(this.outputShape[a-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o,"\n\n        setOutput(result);\n      }\n    ")}}function ez(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const tz={kernelName:Ws,backendName:"webgl",kernelFunc:ez};function nz(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,o=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(o.dataId),s=ez({inputs:{x:r},backend:n}),u=ez({inputs:{x:a},backend:n});return i.complexTensorInfos={real:s,imag:u},o}const rz={kernelName:Zi,backendName:"webgl",kernelFunc:nz},az="return (a < 0.) ? b * a : a;",oz="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const iz={kernelName:qs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:o}=r,i=n.makeTensorInfo([],"float32",sl(o,"float32")),s=xi().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $O(oz,a.shape,i.shape):new ZO(az,a.shape,i.shape),u=n.runWebGLProgram(s,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),u}},sz="return (a < 0.) ? b * a : a;",uz="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const cz={kernelName:Iu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,o=xi().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $O(uz,r.shape,a.shape):new ZO(sz,r.shape,a.shape);return n.runWebGLProgram(o,[r,a],"float32")}},lz="if (isnan(x)) return x;";function hz(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let{inputs:o,backend:i}=e;const{x:s}=o,u=i,c=a||s.dtype;if(u.shouldExecuteOnCPU([s])&&null!=r){const e=u.texData.get(s.dataId),t=r(e.values,c);return u.makeTensorInfo(s.shape,c,t)}let l;return l=xi().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new jO(s.shape,n):new BO(s.shape,t),u.runWebGLProgram(l,[s],c)}}function dz(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:o,dtype:i}=e;return e=>{let{inputs:s,backend:u}=e;const{a:c,b:l}=s,h=u;if(a&&"complex64"===c.dtype){const e=h.texData.get(c.dataId),n=h.texData.get(l.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:c.shape},o={dataId:r.dataId,dtype:r.dtype,shape:l.shape},i=new ZO(t,c.shape,l.shape);return h.runWebGLProgram(i,[a,o],Ol(n.dtype,r.dtype))})),o=nz({inputs:{real:r,imag:a},backend:h});return h.disposeIntermediateTensorInfo(r),h.disposeIntermediateTensorInfo(a),o}const d=i||Ol(c.dtype,l.dtype);if(("string"===c.dtype||"string"===l.dtype||h.shouldExecuteOnCPU([c,l]))&&null!=o){const e=h.texData.get(c.dataId).values,t=h.texData.get(l.dataId).values,n="string"===c.dtype?ky(e):e,r="string"===c.dtype?ky(t):t,[a,i]=o(c.shape,l.shape,n,r,d),s=h.makeTensorInfo(i,d);return h.texData.get(s.dataId).values=a,s}let p;return p=xi().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new $O(n,c.shape,l.shape,r):new ZO(t,c.shape,l.shape),h.runWebGLProgram(p,[c,l],d)}}function pz(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":UO;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":VO;if("prelu"===e)return t?uz:sz;if("leakyrelu"===e)return t?oz:az;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class fz{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],o=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,s=arguments.length>7&&void 0!==arguments[7]&&arguments[7],u=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=gM(this.outputShape.length);const c=r?e[1]:e[2],l=Math.ceil(c/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=s?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(i,"\n        }"):u?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(i,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(i,"\n        }"),g="result = activation(result);");const y=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(v="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(l,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(b,";\n        int batchB = ").concat(v,";\n        for (int i = 0; i < ").concat(l,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(y,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const mz="return areal * breal - aimag * bimag;",gz="return areal * bimag + aimag * breal;";class yz{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Sd(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const bz="return a * b;";function vz(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,o=Ol(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),o=new yz(mz,r.shape,a.shape),i=new yz(gz,r.shape,a.shape),s=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],u=n.runWebGLProgram(o,s,"float32"),c=n.runWebGLProgram(i,s,"float32"),l=nz({inputs:{real:u,imag:c},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),l}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[i,s]=rO(r.shape,a.shape,e.values,t.values,o),u=n.makeTensorInfo(s,o);return n.texData.get(u.dataId).values=i,u}let i;return i=xi().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $O(bz,r.shape,a.shape):new ZO(bz,r.shape,a.shape),n.runWebGLProgram(i,[r,a],o)}const xz={kernelName:gu,backendName:"webgl",kernelFunc:vz};function wz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:o}=r,i=n,s=Go(a.shape),u=Yo(o,s),c=Go(u);Wo(s===c,(()=>"The new shape (".concat(u,") has ").concat(c," elements and the old ")+"shape (".concat(a.shape,") has ").concat(s," elements. The new shape and old ")+"shape must have the same number of elements."));const l=i.texData.get(a.dataId);return!l.isPacked||BR(a.shape,u)||null!==l.texture&&BR(l.shape,u)?(i.incRef(a.dataId),{dataId:a.dataId,shape:u,dtype:a.dtype}):function(e,t,n){const r=[MR(e.shape),...OR(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},o=[MR(t),...OR(t)],i=new RO(o,r),s=[r],u=n.runWebGLProgram(i,[a],e.dtype,s,!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(a,u,i)}const kz={kernelName:zu,backendName:"webgl",kernelFunc:wz};class Cz{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:o}=e;this.outputShape=[r,o];const i=4*Math.floor(n/4),s=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u="sumValue += dot(values * ".concat(Ho(e)?e.toPrecision(2):e,", ones);")}let c="";a%n>0&&(c="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(c,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(u,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===s,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(u,"\n        } else if (").concat(2===s,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(u,"\n        } else if (").concat(3===s,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(u,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class Dz{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:o}=e;this.outputShape=[r,o];let i="0.0",s="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",s="min"):"max"===t&&(i="-1.0 / 1e-20",s="max");let u="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const c=4*Math.floor(n/4),l=n%4;let h="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(s,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(s,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";a%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(i,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(i,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(c,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(c,";\n        if (").concat(1===l,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===l,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===l,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(u,");\n      }\n    ")}}function Sz(e,t,n,r){const a=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Cg(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let o=e;for(let i=0;i<a.length;i++){const{inSize:s,windowSize:u,outSize:c}=a[i];let l,h;l="mean"===n?0===i?new Cz({windowSize:u,inSize:s,batchSize:e.shape[0],outSize:c},s):new Cz({windowSize:u,inSize:s,batchSize:e.shape[0],outSize:c}):new Dz({windowSize:u,inSize:s,batchSize:e.shape[0],outSize:c},n),h=o,o=r.runWebGLProgram(l,[o],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return o}class Ez{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const r=cM(this.rank),a=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode="\n    void main() {\n      ".concat(r," resRC = getOutputCoords();\n      setOutput(getA(").concat(a,"));\n    }\n    ")}}class Iz{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let c=0;c<n.length;c++)n[c]=e[t[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const r=cM(this.rank),a=AO("rc",this.rank),o=new Array(this.rank);for(let c=0;c<t.length;c++)o[t[c]]=a[c];const i="vec2(".concat(o.slice(-2).join(),")"),s="++".concat(a[this.rank-1]," < ").concat(n[this.rank-1]),u="getChannel(getA(".concat(o.join(),"), ").concat(i,")");this.userCode="\n    void main() {\n      ".concat(r," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(u,";\n      if(").concat(s,") {\n        result[1] = ").concat(u,";\n      }\n      --").concat(a[this.rank-1],";\n      if(++").concat(a[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(u,";\n        if(").concat(s,") {\n          result[3] = ").concat(u,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function Nz(e,t,n){const r=xi().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Iz(e.shape,t):new Ez(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function Tz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r;return function(e,t,n,r){const a=t,o=e.shape.length,i=Qo(a,e.shape);let s=i;const u=mf(s,o),c=null!=u;let l=e;c&&(l=Nz(e,u,r),s=yf(s.length,o)),ff("sum",s,o);const[h,d]=df(l.shape,s);let p=h;n&&(p=pf(h,i));const f=Go(d),m=wz({inputs:{x:l},attrs:{shape:[Go(e.shape)/f,f]},backend:r}),g=Sz(m,zl(e.dtype),"sum",r),y=wz({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),c&&r.disposeIntermediateTensorInfo(l),y}(a,o,i,n)}const Az={kernelName:rc,backendName:"webgl",kernelFunc:Tz};function Fz(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:o}=r,i=n,s=a.shape.length,u=new Array(s);for(let l=0;l<u.length;l++)u[l]=a.shape[o[l]];let c;if(i.shouldExecuteOnCPU([a])){const e=i.texData.get(a.dataId).values,t=NO(e,a.shape,a.dtype,o,u);c=i.makeTensorInfo(u,a.dtype);i.texData.get(c.dataId).values=t}else c=Nz(a,o,i);return c}const _z={kernelName:Sc,backendName:"webgl",kernelFunc:Fz};function Rz(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:o,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:u=0,activation:c=null}=e;const l=t.shape.length,h=n.shape.length,d=r?t.shape[l-2]:t.shape[l-1],p=a?n.shape[h-1]:n.shape[h-2],f=r?t.shape[l-1]:t.shape[l-2],m=a?n.shape[h-2]:n.shape[h-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=Go(g),v=Go(y),x=Sd(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);Wo(d===p,(()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(r)+" and transposeB=".concat(a," must match.")));const w=r?[b,d,f]:[b,f,d],k=a?[v,m,p]:[v,p,m],C=wz({inputs:{x:t},backend:o,attrs:{shape:w}}),D=wz({inputs:{x:n},backend:o,attrs:{shape:k}}),S=[C,D],E=Math.max(b,v),I=r?C.shape[1]:C.shape[2],N=null!=i,T=null!=s,A="leakyrelu"===c,F=null!=c?pz(c,!0):null;let _;if((1===f||1===m)&&I>1e3&&!1===(N||T||A||null!=F)){let e=C,t=D;r&&(e=Fz({inputs:{x:C},backend:o,attrs:{perm:[0,2,1]}}),S.push(e)),a&&(t=Fz({inputs:{x:D},backend:o,attrs:{perm:[0,2,1]}}),S.push(t));const n=1===m;let i=e;1!==m&&(i=wz({inputs:{x:e},backend:o,attrs:{shape:[E,I,1]}}),S.push(i));const s=1===m?2:1;let u=t;n&&(u=wz({inputs:{x:t},backend:o,attrs:{shape:[E,1,I]}}),S.push(u));const c=vz({inputs:{a:i,b:u},backend:o});_=Tz({inputs:{x:c},backend:o,attrs:{axis:s,keepDims:!0}}),S.push(c)}else{const e=Ol(t.dtype,n.dtype),c=new fz(w,k,[E,f,m],r,a,N,F,T,A),l=[C,D];if(null!=i&&l.push(i),T&&l.push(s),A){const e=o.makeTensorInfo([],"float32",sl(u,"float32"));l.push(e),S.push(e)}_=o.runWebGLProgram(c,l,e)}const R=wz({inputs:{x:_},backend:o,attrs:{shape:x}});S.push(_);for(const M of S)o.disposeIntermediateTensorInfo(M);return R}const Mz={kernelName:Rc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o,bias:i,preluActivationWeights:s}=t,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:h}=r;return Rz({a:a,b:o,transposeA:u,transposeB:c,backend:n,bias:i,preluActivationWeights:s,leakyreluAlpha:h,activation:l})}},Oz="return abs(x);";const zz={kernelName:Si,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=fO(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=xi().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new jO(r.shape,Oz):new BO(r.shape,Oz),n.runWebGLProgram(a,[r],r.dtype)}},Lz=hz({opSnippet:PO+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Bz={kernelName:Ei,backendName:"webgl",kernelFunc:Lz},Pz=hz({opSnippet:PO+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Wz={kernelName:Ii,backendName:"webgl",kernelFunc:Pz},Uz="return a + b;",Vz=dz({opSnippet:Uz,packedOpSnippet:Uz,supportsComplex:!0,cpuKernelImpl:OM}),Gz={kernelName:Ni,backendName:"webgl",kernelFunc:Vz};class jz{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));const r=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}class Hz{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));const r=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(r,";\n        setOutput(result);\n      }\n    ")}}const qz={kernelName:Ti,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,a=n;if(1===a.length)return ez({inputs:{x:a[0]},backend:r});if(a.length>xi().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),o=e({inputs:a.slice(t),backend:r});return e({inputs:[n,o],backend:r})}const o=a.map((e=>e.dtype)).reduce(((e,t)=>Ol(e,t))),i=a.map((e=>e.shape)),s=xi().getBool("WEBGL_PACK")?new Hz(a[0].shape,i):new jz(a[0].shape,i);return r.runWebGLProgram(s,a,o)}};const Kz={kernelName:Ai,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=a.shape.length,u=Qo(o,a.shape);let c=u;const l=mf(c,s);let h=a;null!=l&&(h=Fz({inputs:{x:a},backend:n,attrs:{perm:l}}),c=yf(c.length,s)),ff("all",c,s);const[d,p]=df(h.shape,c),f=wz({inputs:{x:h},backend:n,attrs:{shape:[-1,Go(p)]}}),m=Sz(f,f.dtype,"all",n);let g;if(i){g=wz({inputs:{x:m},backend:n,attrs:{shape:pf(d,u)}})}else g=wz({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=l&&n.disposeIntermediateTensorInfo(h),g}};const Xz={kernelName:Fi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=a.shape.length,u=Qo(o,a.shape);let c=u;const l=mf(c,s);let h=a;null!=l&&(h=Fz({inputs:{x:a},backend:n,attrs:{perm:l}}),c=yf(c.length,s)),ff("any",c,s);const[d,p]=df(h.shape,c),f=wz({inputs:{x:h},backend:n,attrs:{shape:[-1,Go(p)]}}),m=Sz(f,f.dtype,"any",n);let g;if(i){g=wz({inputs:{x:m},backend:n,attrs:{shape:pf(d,u)}})}else g=wz({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=l&&n.disposeIntermediateTensorInfo(h),g}};class Yz{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,o];const i="max"===t?">":"<",s=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(r,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          int inIdx = ").concat(s,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(i," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class Qz{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Wo(e.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const a=e[e.length-1],o=Math.ceil(a/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,s=i.length,u=cM(s),c=FO("coords",s);let l,h;if(1===o){h=s+1;const e=cM(h);l="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(c.join(),", 0);\n        ++").concat(c[s-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(c.join(),", 0);\n        ++").concat(c[s-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(c.join(),", 0);\n        --").concat(c[s-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(c.join(),", 0);\n        --").concat(c[s-2],";")}else h=s,l="\n        ".concat(u," sourceLocR = coords;\n        ++").concat(c[s-1],";\n        ").concat(u," sourceLocG = coords;\n        ++").concat(c[s-2],";\n        ").concat(u," sourceLocA = coords;\n        --").concat(c[s-1],";\n        ").concat(u," sourceLocB = coords;\n        --").concat(c[s-2],";");const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((e=>"int "+e)),m=FO("sourceLocR",h-1).concat("inIdx.r"),g=FO("sourceLocG",h-1).concat("inIdx.g"),y=FO("sourceLocB",h-1).concat("inIdx.b"),b=FO("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(y.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(b.join(),") : 0.)"),k=r?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(d.join(),"),\n                                          vec2(").concat(d.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(d.join(),"),\n                               vec2(").concat(d.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(u," coords = getOutputCoords();\n        bool hasNextCol = ").concat(c[s-1]," < ").concat(i[s-1]-1,";\n        bool hasNextRow = ").concat(c[s-2]," < ").concat(i[s-2]-1,";\n        ").concat(l,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(x,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(v,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function Zz(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],o=t.shape[1];null!=r&&(a=r.shape[0],o=r.shape[1]);const i=Cg(o),s={windowSize:i,inSize:o,batchSize:a,outSize:Math.ceil(o/i)},u=new Yz(s,n,null==r),c=[t];null!=r&&c.push(r);const l=e.runWebGLProgram(u,c,"int32");if(1===l.shape[1])return l;const h=Zz(e,t,n,l);return e.disposeIntermediateTensorInfo(l),h}function Jz(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=null!=r?r.shape:t.shape,o=Cg(a[a.length-1]),i=new Qz(a,o,n,null==r),s=null==r?[t]:[t,r],u=e.runWebGLProgram(i,s,"int32");if(u.shape.length===t.shape.length){const r=Jz(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function $z(e,t,n,r){const a=[n];if(ff("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!xi().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],o=e.texData.get(t.dataId);let i=t;null!==o&&o.isPacked&&(i=e.unpackTensor(t),n.push(i));const[s,u]=df(i.shape,a),c=Go(u),l=wz({inputs:{x:i},backend:e,attrs:{shape:[-1,c]}});n.push(l);const h=Zz(e,l,r);n.push(h);const d=wz({inputs:{x:h},backend:e,attrs:{shape:s}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return Jz(e,t,r)}const eL={kernelName:_i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o}=r;let i=Qo(o,a.shape);const s=mf(i,a.shape.length);let u=a;const c=[];null!=s&&(u=Fz({inputs:{x:a},backend:n,attrs:{perm:s}}),c.push(u),i=yf(i.length,u.shape.length)),ff("argMax",[i[0]],u.shape.length);const l=$z(n,u,i[0],"max");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};const tL={kernelName:Ri,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o}=r;let i=Qo(o,a.shape);const s=mf(i,a.shape.length);let u=a;const c=[];null!=s&&(u=Fz({inputs:{x:a},backend:n,attrs:{perm:s}}),c.push(u),i=yf(i.length,u.shape.length)),ff("argMin",[i[0]],u.shape.length);const l=$z(n,u,i[0],"min");return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}},nL=hz({opSnippet:PO+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),rL={kernelName:Mi,backendName:"webgl",kernelFunc:nL},aL=hz({opSnippet:PO+"return log(x + sqrt(x * x + 1.0));"}),oL={kernelName:Oi,backendName:"webgl",kernelFunc:aL},iL=hz({opSnippet:PO+"\n  return atan(x);\n"}),sL={kernelName:zi,backendName:"webgl",kernelFunc:iL},uL=dz({opSnippet:QO+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+JO+"\n  return result;\n"}),cL={kernelName:Bi,backendName:"webgl",kernelFunc:uL},lL=hz({opSnippet:PO+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),hL={kernelName:Li,backendName:"webgl",kernelFunc:lL};class dL{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideHeight,s=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(i,", ").concat(s,");\n        const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(l,";\n              wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(c,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(r?a?m:g:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let b="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(o/4),x=o%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(i,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n      const float initializationValue = ").concat(y,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(y,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(l,";\n            wR += ").concat(u,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(v,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(c,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              getValue(batch, xR, xC + 3 * ").concat(c,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(v,";\n          if (").concat(1===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(c,", d),\n              getValue(batch, xR, xC + 2 * ").concat(c,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(b,");\n      }\n    ")}}class pL{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideDepth,s=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(i,", ").concat(s,", ").concat(u,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d,";\n              wD += ").concat(c,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(l,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(r?a?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let x="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(o/4),k=o%4,C="\n      if (".concat(b,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(i,", ").concat(s,", ").concat(u,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(c,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(l,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(C,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(C,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(C,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(C,"\n            }\n          }\n        }\n        setOutput(").concat(x,");\n      }\n    ")}}const fL={kernelName:Pi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;HR(a,"avgPool");const{filterSize:o,strides:i,pad:s,dimRoundingMode:u}=r;Wo(vp(i,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")));const c=cp(a.shape,o,i,1,s,u);if(1===c.filterWidth&&1===c.filterHeight&&jo(c.inShape,c.outShape))return ez({inputs:{x:a},backend:n});const l=new dL(c,"avg",!1);return n.runWebGLProgram(l,[a],"float32")}};const mL={kernelName:Ui,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:o,strides:i,pad:s,dimRoundingMode:u,dataFormat:c}=r,l=lp(a.shape,o,i,[1,1,1],s,u,c),h=new pL(l,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}};class gL{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=s-1-e.padInfo.top,l=u-1-e.padInfo.left,h=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(c,", ").concat(l,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(s,";\n            wR += ").concat(o,") {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(u,";\n            wC+= ").concat(i,") {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class yL{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=l-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(l,";\n            wD += ").concat(s,") {\n          float dyD = float(dyDCorner + wD) / ").concat(a,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(u,") {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(c,") {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const bL={kernelName:Vi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,i=o,{filterSize:s,strides:u,pad:c,dimRoundingMode:l}=r,h=lp(i.shape,s,u,[1,1,1],c,l),d=new yL(h);return n.runWebGLProgram(d,[a],i.dtype)}};const vL={kernelName:Wi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,i=o;HR([a,o],"avgPoolGrad");const{filterSize:s,strides:u,pad:c}=r,l=cp(i.shape,s,u,1,c),h=new gL(l);return n.runWebGLProgram(h,[a],i.dtype)}};const xL={kernelName:Gi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:o}=t,{transposeA:i,transposeB:s}=r;return Rz({a:a,b:o,transposeA:i,transposeB:s,backend:n})}};class wL{constructor(e,t,n,r,a,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Sd(e,t),Sd(e,n);let i="0.0";null!=r&&(Sd(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let s="1.0";null!=a&&(Sd(e,a),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(i,";\n        float scale = ").concat(s,";\n        float inv = scale * inversesqrt(variance + float(").concat(o,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class kL{constructor(e,t,n,r,a,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Sd(e,t),Sd(e,n);let i="vec4(0.0)";null!=r&&(Sd(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let s="vec4(1.0)";null!=a&&(Sd(e,a),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(i,";\n        vec4 scale = ").concat(s,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const CL={kernelName:Os,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,mean:o,variance:i,offset:s,scale:u}=t;Wo(o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Wo(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Wo(null==u||o.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:c}=r;null==c&&(c=.001);const l=[a,o,i];let h=null;null!=s&&(h=s.shape,l.push(s));let d=null;null!=u&&(d=u.shape,l.push(u));const p=xi().getBool("WEBGL_PACK_NORMALIZATION")?new kL(a.shape,o.shape,i.shape,h,d,c):new wL(a.shape,o.shape,i.shape,h,d,c);return n.runWebGLProgram(p,l,l[0].dtype)}};class DL{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=cM(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return SL.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let r;const a=e.map(((e,t)=>"sourceLoc.".concat(SL[t]," = start[").concat(t,"] + coords.").concat(SL[t],";")));r="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(a.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(r,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const SL=["x","y","z","w","u","v"];class EL{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=cM(this.rank),n=FO("coords",this.rank),r=FO("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":"vec2(".concat(r.slice(-2).join(),")"),o="getChannel(getSource(".concat(r.join(),"), ").concat(a,")"),i="\n      result.x = ".concat(o,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(r[this.rank-1],";\n        result.y = ").concat(o,";\n        --").concat(r[this.rank-1],";\n      }\n    "),s=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(r[this.rank-2],";\n        result.z = ").concat(o,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(r[this.rank-1],";\n          result.w = ").concat(o,";\n        }\n      }\n    "),u=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map(((e,t)=>"start[".concat(t,"]"))).join(),");"):e.map(((e,t)=>"".concat(r[t]," = ").concat(n[t]," + start[").concat(t,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(u,"\n        vec4 result = vec4(0.);\n        ").concat(i,"\n        ").concat(s,"\n        setOutput(result);\n      }\n    ")}}function IL(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:o,size:i}=r,[s,u]=np(a,o,i);if(Vd(a,s,u),0===Go(u))return n.makeTensorInfo(u,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=mO(e.values,s,u,a.shape,a.dtype);return n.makeTensorInfo(u,a.dtype,t)}const{isPacked:c}=n.texData.get(a.dataId),l=ep(a.shape,s,u);if(c||!l){const e=xi().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new EL(u):new DL(u),t=[s];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){const a=r.texData.get(e.dataId),o=r.makeTensorInfo(n,e.dtype),i=r.texData.get(o.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let s=tp(t,si(e.shape));a.slice&&(s+=a.slice.flatOffset),i.slice={flatOffset:s,origDataId:a.slice&&a.slice.origDataId||e.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),o}(a,s,u,n)}const NL={kernelName:Qu,backendName:"webgl",kernelFunc:IL},TL={kernelName:ji,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:o,crops:i}=r;Wo(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const s=o.reduce(((e,t)=>e*t)),u=Sg(a.shape,o,s),c=Eg(u.length,o.length),l=Ig(a.shape,o,s),h=Ng(i,o.length),d=Tg(l,i,o.length),p=[],f=wz({inputs:{x:a},backend:n,attrs:{shape:u}}),m=Fz({inputs:{x:f},backend:n,attrs:{perm:c}}),g=wz({inputs:{x:m},backend:n,attrs:{shape:l}}),y=IL({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const AL={kernelName:Hi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:i}=r,s=n.readSync(a.dataId),u=n.readSync(o.dataId),c=zM(s,u,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,c)}};const FL={kernelName:qi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,o=xi().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=xi().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(a.dataId).values,[o,i]=BM(r.shape,a.shape,e,t,r.dtype),s=n.makeTensorInfo(i,r.dtype);return n.texData.get(s.dataId).values=o,s}let s;return s=o?new $O("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new ZO("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(s,[r,a],r.dtype)}};const _L={kernelName:Ki,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,o=n.readSync(r.dataId),i=n.readSync(a.dataId),s=Sd(Array.from(o),Array.from(i));return n.makeTensorInfo([s.length],"int32",Int32Array.from(s))}},RL=dz({opSnippet:"return float(a != b);",cpuKernelImpl:oO,dtype:"bool"}),ML={kernelName:bu,backendName:"webgl",kernelFunc:RL};function OL(e){const{inputs:t,backend:n}=e,{input:r}=t;return ez({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const zL={kernelName:Ru,backendName:"webgl",kernelFunc:OL};const LL={kernelName:Xi,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:o}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===o.dtype)return ez({inputs:{x:o},backend:r});const t=Af(o.shape),n=e({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),a=nz({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===o.dtype){const t=OL({inputs:{input:o},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!ei(o.dtype,i)){const e=ez({inputs:{x:o},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([o])){const e=r.texData.get(o.dataId).values,[t,n,a]=PM(e,o.shape,o.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){const n=new BO(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(o,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",Jo("bool",1)),t=RL({inputs:{a:o,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(o.dtype," to ").concat(i))}},BL="return ceil(x);",PL=hz({opSnippet:BL,packedOpSnippet:BL,cpuKernelImpl:WM}),WL={kernelName:Yi,backendName:"webgl",kernelFunc:PL};class UL{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class VL{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const GL={kernelName:Qi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:o,clipValueMax:i}=r;let s;s=xi().getBool("WEBGL_PACK_CLIP")?new VL(a.shape):new UL(a.shape);const u=[[o],[i]];return n.runWebGLProgram(s,[a],a.dtype,u)}};class jL{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function HL(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const qL={kernelName:Ji,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),o=new jL(r.shape),i=[HL(r,a.complexTensorInfos.real),HL(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}};class KL{constructor(e){this.outputShape=[],this.outputShape=gg(e,1),this.variableNames=e.map(((e,t)=>"T".concat(t)));const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let o=1;o<t.length;o++){const e=t[o-1];n.push("else if (yC < ".concat(t[o],") ")+"setOutput(getT".concat(o,"(yR, yC-").concat(e,"));"))}const r=t.length,a=t[t.length-1];n.push("else setOutput(getT".concat(r,"(yR, yC-").concat(a,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class XL{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=gg(e,t);const n=this.outputShape,r=n.length,a=cM(r),o=FO("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>"T".concat(t)));const s=new Array(e.length-1);s[0]=e[0][t];for(let f=1;f<s.length;f++)s[f]=s[f-1]+e[f][t];const u=i[t],c=i.slice(-2),l=i.join();let h="if (".concat(u," < ").concat(s[0],") {\n        return getChannel(\n            getT0(").concat(l,"), vec2(").concat(c.join(),"));\n        }");for(let f=1;f<s.length;f++){const e=s[f-1];h+="\n        if (".concat(u," < ").concat(s[f],"  && ").concat(u," >= ").concat(s[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(YL(i,u,e),"),\n            vec2(").concat(YL(c,u,e),"));\n        }")}const d=s.length,p=s[s.length-1];h+="\n        return getChannel(\n          getT".concat(d,"(").concat(YL(i,u,p),"),\n          vec2(").concat(YL(c,u,p),"));"),this.userCode="\n      float getValue(".concat(i.map((e=>"int "+e)),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(a," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o,"), 0., 0., 0.);\n\n        ").concat(o[r-1]," = ").concat(o[r-1]," + 1;\n        if (").concat(o[r-1]," < ").concat(n[r-1],") {\n          result.g = getValue(").concat(o,");\n        }\n\n        ").concat(o[r-2]," = ").concat(o[r-2]," + 1;\n        if (").concat(o[r-2]," < ").concat(n[r-2],") {\n          result.a = getValue(").concat(o,");\n        }\n\n        ").concat(o[r-1]," = ").concat(o[r-1]," - 1;\n        if (").concat(o[r-2]," < ").concat(n[r-2]," &&\n            ").concat(o[r-1]," < ").concat(n[r-1],") {\n          result.b = getValue(").concat(o,");\n        }\n        setOutput(result);\n      }\n    ")}}function YL(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?"".concat(e," - ").concat(n):e)).join()}function QL(e){const{inputs:t,backend:n}=e,{input:r}=t;return ez({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const ZL={kernelName:Vs,backendName:"webgl",kernelFunc:QL};function JL(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>OL({inputs:{input:e},backend:n}))),a=e.map((e=>QL({inputs:{input:e},backend:n}))),o=JL(r,t,n),i=JL(a,t,n),s=nz({inputs:{real:o,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),s}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=Go(e.shape.slice(t));return wz({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),o=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=gg(a.map((e=>e.shape)),1),s=1===a[0].shape[0],u=UM(o,i,r,s),c=gg(e.map((e=>e.shape)),t),l=n.makeTensorInfo(c,r,u);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const o=e.filter((e=>Go(e.shape)>0)),i=xi().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const t=i?new BO(e[0].shape,GO):new jO(e[0].shape,GO);return n.runWebGLProgram(t,e,r)}const s=xi().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>s){const e=[];for(let a=0;a<o.length;a+=s){const r=o.slice(a,a+s);e.push(JL(r,t,n))}const r=JL(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new XL(o.map((e=>e.shape)),t);return n.runWebGLProgram(e,o,r)}const{tensors2D:u,outShape:c}=function(e,t,n){const r=gg(e.map((e=>e.shape)),t),a=e.map((e=>wz({inputs:{x:e},attrs:{shape:[-1,Go(e.shape.slice(t))]},backend:n})));return{tensors2D:a,outShape:r}}(o,t,n),l=new KL(u.map((e=>e.shape))),h=n.runWebGLProgram(l,u,r);u.forEach((e=>n.disposeIntermediateTensorInfo(e)));const d=wz({inputs:{x:h},attrs:{shape:c},backend:n});return n.disposeIntermediateTensorInfo(h),d}function $L(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,o=Qo(a,t[0].shape)[0];mg(t.map((e=>e.shape)),o);const i=gg(t.map((e=>e.shape)),o);if(0===Go(i))return n.makeTensorInfo(i,t[0].dtype,[]);const s=t.filter((e=>Go(e.shape)>0));return 1===s.length?ez({inputs:{x:s[0]},backend:n}):JL(s,o,n)}const eB={kernelName:$i,backendName:"webgl",kernelFunc:$L};class tB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,i=e.padInfo.left,s=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(v,"\n\n      const ivec2 strides = ivec2(").concat(s,", ").concat(u,");\n      const ivec2 pads = ivec2(").concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(b,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(y,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(c,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d,"; wC++) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(x,"\n        setOutput(result);\n      }\n    ")}}class nB{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,l=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(a,", ").concat(o,", ").concat(i,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(r,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(l,"; wF++) {\n          int xF = xFCorner + wF * ").concat(s,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(u,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,"; wC++) {\n              int xC = xCCorner + wC * ").concat(c,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class rB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=gM(this.outputShape.length);const o=e.padInfo.left,i=e.strideWidth,s=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,l=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<c;m++)h+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");h+="\n     for (int r = 0; r < ".concat(u,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<c;m++)h+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(l+1)/2;m++){const t=2*m;if(h+="\n           xC = xCCorner + ".concat(t*s,";\n           "),1===i){if(t<c&&(o%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),h+=1===s&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<c)){const e=o%2===0?Bo(s):s;s%2===0&&o%2===1||s%2!==0&&o%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),h+=s>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):h+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<c&&(o%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<c&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<c&&(h+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<c&&(h+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<c&&(h+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):a?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(d,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class aB{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=gM(this.outputShape.length);const{dataFormat:n}=t,r=KR(),a="channelsLast"===n,o=a?1:2,i=a?2:3,s=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let u="";for(let c=0;c<=1;c++)for(let e=0;e<=1;e++)u+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(c,";\n\n          ").concat(s,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(i,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(a,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*c+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*c+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(u,"\n\n        ").concat(r.output," = result;\n      }\n    ")}}function oB(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function iB(e){let{x:t,filter:n,convInfo:r,backend:a,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:u=null}=e;const c=t.shape,l=a.texData.get(t.dataId),h=r.inChannels,d=c[0]*c[1]*c[2],p=r.outChannels,f="channelsLast"===r.dataFormat,m=!1;let g;const y=[];if(null!=i){const e=oB(i.shape,f);null!=e&&(i=wz({inputs:{x:i},backend:a,attrs:{shape:e}}),y.push(i))}if(null!=o){const e=oB(o.shape,f);null!=e&&(o=wz({inputs:{x:o},backend:a,attrs:{shape:e}}),y.push(o))}if(!((1===d||1===p)&&h>1e3)&&l.isPacked&&f&&null!=l.texture&&c[2]%2!==0&&jo(l.shape.slice(-3),c.slice(-3))){const e=c[0]*c[1]*(c[2]+1),h={dataId:t.dataId,shape:[1,e,r.inChannels],dtype:t.dtype},d=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Wo(BR(l.shape,h.shape),(()=>"packed reshape ".concat(l.shape," to ").concat(h.shape," isn't free")));const p=wz({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}});y.push(p);const f=Rz({a:h,b:p,backend:a,transposeA:false,transposeB:m,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:s}),b=a.texData.get(f.dataId);Wo(b.isPacked,(()=>"batchMatMul result is expected to be packed")),l.shape=d,b.shape=r.outShape,g=ez({inputs:{x:f},backend:a}),g.shape=r.outShape,y.push(f)}else{const e=r.outHeight*r.outWidth,c=wz({inputs:{x:t},backend:a,attrs:{shape:f?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),l=wz({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}}),h=Rz({a:f?c:l,b:f?l:c,transposeA:!f,transposeB:m,backend:a,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:s});g=wz({inputs:{x:h},backend:a,attrs:{shape:r.outShape}}),y.push(c),y.push(l),y.push(h)}for(const b of y)a.disposeIntermediateTensorInfo(b);return g}function sB(e){let{x:t,filter:n,convInfo:r,backend:a,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:u=null}=e;const{filterWidth:c,filterHeight:l,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=c*l*h,y=p*d,b=[r.batchSize,g,y],v=[];if(null!=i){const e=oB(i.shape,m);null!=e&&(i=wz({inputs:{x:i},backend:a,attrs:{shape:e}}),v.push(i))}if(null!=o){const e=oB(o.shape,m);null!=e&&(o=wz({inputs:{x:o},backend:a,attrs:{shape:e}}),v.push(o))}const x=wz({inputs:{x:n},backend:a,attrs:{shape:[1,g,Go(n.shape)/g]}});v.push(x);const w=new aB(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],C=a.runWebGLProgram(w,[t],"float32",k),D=wz({inputs:{x:C},backend:a,attrs:{shape:b}});v.push(C),v.push(D);const S=null!=o,E=null!=i,I="leakyrelu"===u,N=u?pz(u,!0):null,T=new fz(m?D.shape:x.shape,m?x.shape:D.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,S,N,E,I),A=m?[D,x]:[x,D];if(o&&A.push(o),E&&A.push(i),I){const e=a.makeTensorInfo([],"float32",sl(s,"float32"));A.push(e),v.push(e)}const F=a.runWebGLProgram(T,A,"float32"),_=wz({inputs:{x:F},backend:a,attrs:{shape:r.outShape}});v.push(F);for(const R of v)a.disposeIntermediateTensorInfo(R);return _}const uB={kernelName:es,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dataFormat:u,dilations:c,dimRoundingMode:l}=r,h=wp(u),d=hp(a.shape,o.shape,i,c,s,l,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&xi().getBool("WEBGL_EXP_CONV")){const e=new rB(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[a,o],"float32",t)}else if(xi().getBool("WEBGL_CONV_IM2COL"))p=sB({x:a,filter:o,convInfo:d,backend:n});else{const e=new tB(d);p=n.runWebGLProgram(e,[a,o],"float32")}else p=iB({x:a,filter:o,convInfo:d,backend:n});const f=wz({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class cB{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(o?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class lB{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,s=n-1-e.padInfo.left,u=o?1:2,c=o?2:3,l=o?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(l,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(u,"], coords[").concat(c,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(o,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class hB{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,o=e.padInfo.top,i=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(a,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(o,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(r," - ").concat(i,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class dB{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,s=t-1-e.padInfo.front,u=n-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(s,", ").concat(u,", ").concat(c,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(a,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(r,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(i,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(r," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const pB={kernelName:ts,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,pad:s,dataFormat:u,dimRoundingMode:c,filterShape:l}=r,h=wp(u),d=hp(a.shape,l,i,1,s,c,!1,h),p=new cB(d);return n.runWebGLProgram(p,[a,o],"float32")}};class fB{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=gM(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(r,", ").concat(a,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const mB={kernelName:ns,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{inputShape:i,strides:s,pad:u,dataFormat:c,dimRoundingMode:l}=r,h=wp(c),d=hp(i,o.shape,s,1,u,l,!1,h);if(xi().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new fB(d);return n.runWebGLProgram(t,[a,o],"float32",e)}{const e=new lB(d);return n.runWebGLProgram(e,[a,o],"float32")}}};const gB={kernelName:rs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:u}=r,c=dp(a.shape,o.shape,i,u,s),l=new nB(c);return n.runWebGLProgram(l,[a,o],"float32")}};const yB={kernelName:as,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,pad:s,filterShape:u}=r,c=dp(a.shape,u,i,1,s),l=new hB(c);return n.runWebGLProgram(l,[a,o],"float32")}};const bB={kernelName:os,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{pad:i,strides:s,inputShape:u}=r,c=dp(u,o.shape,s,1,i),l=new dB(c);return n.runWebGLProgram(l,[a,o],"float32")}},vB=hz({opSnippet:lz+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(JO,"\n  return result;\n")}),xB={kernelName:is,backendName:"webgl",kernelFunc:vB},wB=hz({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),kB={kernelName:ss,backendName:"webgl",kernelFunc:wB};class CB{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,s,u]=e,[c]=t,[l,h]=n;this.outputShape=[c,l,h,u];const d="bilinear"===r?1:0,[p,f]=["".concat(i-1,".0"),"".concat(s-1,".0")],[m,g,y]=l>1?["".concat((i-1)/(l-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[b,v,x]=h>1?["".concat((s-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(b,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(o,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(v,";\n\n        float in_y = ").concat(y,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n        float in_x = ").concat(x,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(a,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const DB={kernelName:ls,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:o,boxInd:i}=t,{cropSize:s,method:u,extrapolationValue:c}=r,l=new CB(a.shape,o.shape,s,u,c);return n.runWebGLProgram(l,[a,o,i],"float32")}};var SB;!function(e){e.Prod="*",e.Sum="+"}(SB||(SB={}));class EB{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,o=this.op===SB.Prod?"1.0":"0.0",i=n?o:"getX(".concat(IB(a,"coords",this.op),")"),s=this.outputShape[this.outputShape.length-1];let u="",c="";n?(u=r?"end != ".concat(s-1):"end != 0",c=r?"end + 1":"end - 1"):(u=r?"end + pow2 < ".concat(s):"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(cM(a)," coords = getOutputCoords();\n        int end = ").concat(NB(a,"coords",this.op),";\n        float val = ").concat(i,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(u,") {\n          int idx = ").concat(c,";\n          ").concat(NB(a,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(IB(a,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function IB(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function NB(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function TB(e,t,n,r,a,o){const i=t.shape.length,s=mf([r],i);let u=t;null!=s&&(u=Fz({inputs:{x:t},backend:n,attrs:{perm:s}}));const c=yf(1,i)[0];if(c!==i-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(r));const l=u.shape[c];let h=ez({inputs:{x:u},backend:n});for(let d=0;d<=Math.ceil(Math.log2(l))-1;d++){const t=new EB(e,u.shape,!1,o),r=[[d]],a=h;h=n.runWebGLProgram(t,[h],h.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){const t=new EB(e,u.shape,a,o),r=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=s){const e=Fz({inputs:{x:h},backend:n,attrs:{perm:gf(s)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),e}return h}const AB={kernelName:us,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,exclusive:i,reverse:s}=r;return TB(SB.Prod,a,n,o,i,s)}};const FB={kernelName:cs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,exclusive:i,reverse:s}=r;return TB(SB.Sum,a,n,o,i,s)}};const _B={kernelName:hs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:o}=t,{size:i,binaryOutput:s}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(o.dataId),r=zM(e,t,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(o),r=LM(e,t,i,s);return n.makeTensorInfo(r.shape,o.dtype,r.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(a.shape.length,"."))}};class RB{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const MB={kernelName:ds,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:o,dataFormat:i}=r,s=a.shape[0],u=("NHWC"===i?a.shape[1]:a.shape[2])*o,c=("NHWC"===i?a.shape[2]:a.shape[3])*o,l=("NHWC"===i?a.shape[3]:a.shape[1])/(o*o),h=new RB("NHWC"===i?[s,u,c,l]:[s,l,u,c],o,i);return n.runWebGLProgram(h,[a],a.dtype)}};class OB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=gM(this.outputShape.length);const o=e.filterHeight,i=e.filterWidth,s=e.outChannels/e.inChannels;let u="",c="";n&&(u=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),c="result = activation(result);");const l=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(u,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(s,";\n        int q = d2 - d1 * ").concat(s,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(i,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(l,"\n        ").concat(c,"\n        setOutput(result);\n      }\n    ")}}class zB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=gM(this.outputShape.length);const o=e.outChannels/e.inChannels,i=e.padInfo.left,s=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,h=l;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<l;g++)d+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");d+="\n    for (int r = 0; r < ".concat(c,"; r++) {\n      ");for(let g=0;g<l;g++)d+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(h+1)/2;g++){const e=2*g;if(d+="\n          xC = xCCorner + ".concat(e*u,";\n          "),1===s){if(e<l&&(i%2===1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),d+=1===u&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<l)){const t=i%2===0?Bo(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),d+=u>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):d+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<l&&(i%2===1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<l&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<l&&(d+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<l&&(d+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<l&&(d+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):a?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o,";\n        int q = d2 - d1 * ").concat(o,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const LB={kernelName:ps,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:u,dimRoundingMode:c}=r;let l=u;null==l&&(l=[1,1]),Wo(vp(i,l),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(i," and dilations '").concat(l,"'")));const h=hp(a.shape,o.shape,i,l,s,c,!0);let d;d=xi().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new zB(h):new OB(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,o],"float32",p)}};class BB{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(a,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class PB{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(s,"; dm++) {\n              int d2 = d1 * ").concat(s," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const WB={kernelName:fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:o}=t,{strides:i,dilations:s,pad:u,dimRoundingMode:c,filterShape:l}=r,h=hp(a.shape,l,i,s,u,c,!0),d=new BB(h);return n.runWebGLProgram(d,[a,o],"float32")}};const UB={kernelName:ms,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:o}=t,{strides:i,dilations:s,pad:u,dimRoundingMode:c,inputShape:l}=r,h=hp(l,o.shape,i,s,u,c,!0),d=new PB(h);return n.runWebGLProgram(d,[a,o],"float32")}};class VB{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const GB={kernelName:gs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],o=Go(r.shape),i=wz({inputs:{x:r},backend:n,attrs:{shape:[o]}}),s=new VB(o),u=n.runWebGLProgram(s,[i],i.dtype),c=wz({inputs:{x:u},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),c}};class jB{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:o,filterHeight:i,filterWidth:s,dilationHeight:u,dilationWidth:c}=e,{top:l,left:h}=r;this.userCode="\n      const ivec2 strides = ivec2(".concat(a,", ").concat(o,");\n      const ivec2 pads = ivec2(").concat(l,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(i,"; h++) {\n          int hIn = hBeg + h * ").concat(u,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(s,"; w++) {\n              int wIn = wBeg + w * ").concat(c,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const HB={kernelName:ys,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o}=t,{strides:i,pad:s,dilations:u}=r,c=up(a.shape,o.shape,i,s,"NHWC",u);let l;const h=new jB(c);l=n.runWebGLProgram(h,[a,o],"float32");const d=wz({inputs:{x:l},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(l),d}};const qB={kernelName:ks,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,o=t,{allDims:i,summedDims:s,idDims:u}=ey(a,o.length);ny(i.length,u,o);const{path:c,steps:l}=ry(s,u),h=l.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of l[m]){const{permutationIndices:t,expandDims:r}=ty(p,u[e]);let a;ay(t)?a=o[e]:(a=Fz({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);jo(a.shape,i)||(a=wz({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===d?d=a:(d=vz({inputs:{a:a,b:d},backend:n}),f.push(d))}m<h-1&&(c[m]>=0&&(d=Tz({inputs:{x:d},backend:n,attrs:{axis:c[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},KB=hz({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),XB={kernelName:Cs,backendName:"webgl",kernelFunc:KB},YB={kernelName:Ds,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,o=xi().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $O("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new ZO("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(o,[r,a],r.dtype)}},QB=dz({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:VM}),ZB={kernelName:Es,backendName:"webgl",kernelFunc:QB},JB=hz({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(zg,";\n  float a1 = ").concat(Lg,";\n  float a2 = ").concat(Bg,";\n  float a3 = ").concat(Pg,";\n  float a4 = ").concat(Wg,";\n  float a5 = ").concat(Ug,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),$B={kernelName:Ss,backendName:"webgl",kernelFunc:JB},eP=hz({opSnippet:lz+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:GM,dtype:"float32"}),tP={kernelName:Is,backendName:"webgl",kernelFunc:eP};function nP(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:o}=t,i=o.shape.length,s=o.shape.slice();let u=a;return a<0&&(Wo(-(i+1)<=a,(()=>"Axis must be in the interval [".concat(-(i+1),", ").concat(i,"]"))),u=i+a+1),s.splice(u,0,1),wz({inputs:{x:o},backend:r,attrs:{shape:s}})}const rP={kernelName:Ns,backendName:"webgl",kernelFunc:nP},aP="return exp(x) - 1.0;",oP=hz({opSnippet:aP,packedOpSnippet:aP,cpuKernelImpl:jM}),iP={kernelName:Ts,backendName:"webgl",kernelFunc:oP};class sP{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),o=n?"".concat(r,".0"):"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));i="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(a,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(r,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(o,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function uP(e,t,n){const r=n.texData.get(e.dataId),a=Go(e.shape),o=e.shape[e.shape.length-1],i=wz({inputs:{x:e},backend:n,attrs:{shape:[a/o,o]}}),s=i.shape,u=new sP("real",s,t),c=new sP("imag",s,t),l=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:s},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:s}],h=n.runWebGLProgram(u,l,"float32"),d=n.runWebGLProgram(c,l,"float32"),p=nz({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=wz({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const cP={kernelName:As,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return uP(r,!1,n)}};class lP{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function hP(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:o}=n;if(o=o||ai(a),"string"===o){const e=$o(o,Go(r));return e.fill(a),t.makeTensorInfo(r,o,e)}{const e=new lP(r,a),n=[[a]];return t.runWebGLProgram(e,[],o,n)}}const dP={kernelName:Fs,backendName:"webgl",kernelFunc:hP};class pP{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const fP={kernelName:_s,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,a=n,o=new pP(r.shape);return a.runWebGLProgram(o,[r],r.dtype)}},mP="return floor(x);",gP=hz({opSnippet:mP,packedOpSnippet:mP,cpuKernelImpl:HM}),yP={kernelName:Rs,backendName:"webgl",kernelFunc:gP},bP=dz({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),vP={kernelName:Ms,backendName:"webgl",kernelFunc:bP};class xP{constructor(e){this.variableNames=["A"];const t=KR(),[n,r]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(r,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class wP{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=KR(),[n,r]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(r,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const kP={kernelName:Fc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:o}=r,i="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,s="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[u,c]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],l=[c,u],h=[c,u,o];if(s||i){const e=xi().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=CP&&e===DP||(DP=e,CP=document.createElement("canvas").getContext("2d",{willReadFrequently:DP})),CP.canvas.width=u,CP.canvas.height=c,CP.drawImage(a,0,0,u,c),a=CP.canvas}const d=n.makeTensorInfo(l,"int32");n.texData.get(d.dataId).usage=mR.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);const p=xi().getBool("WEBGL_PACK")?new wP(h):new xP(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let CP,DP=xi().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const SP={kernelName:Mc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o,bias:i,preluActivationWeights:s}=t,{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=wp(l),g=hp(a.shape,o.shape,u,h,c,d,!1,m);let y;const b=[],v=null!=i,x=null!=s,w="leakyrelu"===p,k=()=>{const e=[a,o],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=wz({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(i,l)),x&&e.push(t(s,l)),w){const t=n.makeTensorInfo([],"float32",sl(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&xi().getBool("WEBGL_EXP_CONV")){const e=p?pz(p,!0):null,t=new rB(g,v,e,x,w),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],a=k();y=n.runWebGLProgram(t,a,"float32",r)}else if(xi().getBool("WEBGL_CONV_IM2COL"))y=sB({x:a,filter:o,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:s,leakyreluAlpha:f});else{const e=p?pz(p,!1):null,t=new tB(g,v,e,x,w),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=iB({x:a,filter:o,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:s,leakyreluAlpha:f});const C=wz({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}};const EP={kernelName:Oc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:o,bias:i,preluActivationWeights:s}=t,{strides:u,pad:c,dilations:l,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=l;null==m&&(m=[1,1]),Wo(vp(u,m),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(u," and dilations '").concat(m,"'")));const g=hp(a.shape,o.shape,u,m,c,h,!0),y=xi().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?pz(d,y):null,v=[a,o],x=null!=i,w=null!=s,k="leakyrelu"===d;if(x&&v.push(i),w&&v.push(s),k){const e=n.makeTensorInfo([],"float32",sl(p,"float32"));v.push(e),f.push(e)}let C;C=y?new zB(g,x,b,w,k):new OB(g,x,b,w,k);const D=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],S=n.runWebGLProgram(C,v,"float32",D);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};class IP{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=cM(n.length);let o="\n    int index;";for(let i=0;i<this.sliceDim;i++)o+="\n          index = round(getIndices(coords[0], ".concat(i,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[i],";\n          flattenIndex += index * ").concat(this.strides[i],";");this.userCode="\n         void main() {\n          ".concat(a," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const NP={kernelName:Ls,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,o=a.shape,i=o[o.length-1],s=Go(r.shape),[u,c,l,h]=Ag(r,a),d=wz({inputs:{x:a},backend:n,attrs:{shape:[c,i]}}),p=wz({inputs:{x:r},backend:n,attrs:{shape:[Go(r.shape)/l,l]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),o=qM(e,t,r.dtype,c,i,l,h,r.shape,s);return n.makeTensorInfo(u,r.dtype,o.values)}const f=new IP(i,h,[c,l],r.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=wz({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class TP{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=cM(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push("".concat(t[r]));return n.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(r,"));\n      }\n    ")}}function AP(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:o}=t,{axis:i,batchDims:s}=r,u=Qo(i,a.shape)[0];if(xi().get("DEBUG")){const e=n.readSync(o.dataId),t=a.shape[u];for(let n=0;n<e.length;++n){const r=e[n];Wo(r<=t-1&&r>=0,(()=>"GatherV2: the index value ".concat(r," is not in [0, ").concat(t-1,"]")))}}const c=wy(a,o,u,s),l=Go(o.shape),h=[],d=wz({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=wz({inputs:{x:o},backend:n,attrs:{shape:[c.batchSize,l/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([a,o])||"string"===a.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),r=KM(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c.outputShape,r.dtype,r.values)}const m=new TP(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=wz({inputs:{x:g},backend:n,attrs:{shape:c.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const FP={kernelName:zs,backendName:"webgl",kernelFunc:AP},_P=dz({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:XM,dtype:"bool"}),RP={kernelName:Bs,backendName:"webgl",kernelFunc:_P},MP=dz({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:YM}),OP={kernelName:Ps,backendName:"webgl",kernelFunc:MP};const zP={kernelName:Us,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return uP(r,!0,n)}},LP=hz({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),BP={kernelName:Gs,backendName:"webgl",kernelFunc:LP},PP=hz({opSnippet:"return float(isinf(x));",dtype:"bool"}),WP={kernelName:js,backendName:"webgl",kernelFunc:PP},UP=hz({opSnippet:"return float(isnan(x));",dtype:"bool"}),VP={kernelName:Hs,backendName:"webgl",kernelFunc:UP},GP=dz({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:QM,dtype:"bool"}),jP={kernelName:Ks,backendName:"webgl",kernelFunc:GP},HP=dz({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:ZM,dtype:"bool"}),qP={kernelName:Xs,backendName:"webgl",kernelFunc:HP};const KP={kernelName:Ys,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:o}=n,i=JM(r,a,o);return t.makeTensorInfo([i.length],"float32",i)}},XP=hz({opSnippet:lz+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:$M}),YP={kernelName:Qs,backendName:"webgl",kernelFunc:XP},QP=hz({opSnippet:lz+"\n  return log(1.0 + x);\n"}),ZP={kernelName:Zs,backendName:"webgl",kernelFunc:QP},JP=dz({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),$P={kernelName:Js,backendName:"webgl",kernelFunc:JP},eW=hz({opSnippet:"return float(!(x >= 1.0));"}),tW={kernelName:$s,backendName:"webgl",kernelFunc:eW},nW=dz({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),rW={kernelName:eu,backendName:"webgl",kernelFunc:nW};class aW{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const o=t,i=e[3]-1;let s;this.outputShape=e;const u="float(".concat(n,") + float(").concat(r,") * sum");s=.5===a?"inversesqrt(".concat(u,")"):1===a?"1.0/(".concat(u,")"):"exp(log(".concat(u,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(o,"; j <= ").concat(o,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(i,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(s,";\n        setOutput(val);\n      }\n    ")}}class oW{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,i=e[3]-1;let s;this.outputShape=e;const u="float(".concat(n,") + float(").concat(r,") * sum");s=.5===a?"inversesqrt(".concat(u,")"):1===a?"1.0/(".concat(u,")"):"exp(log(".concat(u,") * float(-").concat(a,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(o,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(o,"; j <= ").concat(o,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(i,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(s,";\n        setOutput(result);\n      }\n    ")}}const iW={kernelName:tu,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:o,bias:i,alpha:s,beta:u}=r,c=xi().getBool("WEBGL_PACK_NORMALIZATION")?new oW(a.shape,o,i,s,u):new aW(a.shape,o,i,s,u);return n.runWebGLProgram(c,[a],a.dtype)}};class sW{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(r,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(r,")\n                * float(").concat(a,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(a,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const uW={kernelName:nu,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:o,dy:i}=t,{depthRadius:s,bias:u,alpha:c,beta:l}=r,h=new sW(a.shape,s,u,c,l);return n.runWebGLProgram(h,[a,o,i],a.dtype)}};function cW(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:o,keepDims:i}=r,s=a.shape.length,u=Qo(o,a.shape);let c=u;const l=mf(c,s),h=null!=l,d=n.shouldExecuteOnCPU([a]);let p=a;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(s);for(let n=0;n<t.length;n++)t[n]=a.shape[l[n]];const r=NO(e,a.shape,a.dtype,l,t);p=n.makeTensorInfo(t,a.dtype);n.texData.get(p.dataId).values=r}else p=Nz(a,l,n);c=yf(c.length,s)}ff("max",c,s);const[f,m]=df(p.shape,c);let g,y=f;if(i&&(y=pf(f,u)),d){const e=n.texData.get(p.dataId).values,t=eO(e,Go(m),y,a.dtype);g=n.makeTensorInfo(y,a.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const a=Go(t),o=wz({inputs:{x:e},attrs:{shape:[Go(e.shape)/a,a]},backend:r}),i=Sz(o,e.dtype,"max",r),s=wz({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),s}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const lW={kernelName:ru,backendName:"webgl",kernelFunc:cW},hW=dz({opSnippet:QO+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+JO+"\n  return result;\n",cpuKernelImpl:tO}),dW={kernelName:au,backendName:"webgl",kernelFunc:hW};const pW={kernelName:ou,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;HR(a,"maxPool");const{filterSize:o,strides:i,pad:s,dimRoundingMode:u}=r;Wo(vp(i,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(1,"'")));const c=cp(a.shape,o,i,1,s,u);if(1===c.filterWidth&&1===c.filterHeight&&jo(c.inShape,c.outShape))return ez({inputs:{x:a},backend:n});const l=new dL(c,"max",!1);return n.runWebGLProgram(l,[a],a.dtype)}};const fW={kernelName:su,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:o,strides:i,pad:s,dataFormat:u,dimRoundingMode:c}=r,l=lp(a.shape,o,i,[1,1,1],s,c,u),h=new pL(l,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}};class mW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,o=e.effectiveFilterWidth,i=a-1-e.padInfo.top,s=o-1-e.padInfo.left,u=a*o-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(a,";\n          wR += ").concat(r,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(u," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class gW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,i=e.dilationWidth,s=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=s-1-e.padInfo.front,h=u-1-e.padInfo.top,d=c-1-e.padInfo.left,p=s*u*c-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(l,", ").concat(h,", ").concat(d,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(s,";\n           wD += ").concat(a,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(o,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(c,";\n                wC += ").concat(i,") {\n              float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(u," * ").concat(c," +\n                  wR * ").concat(c," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const yW={kernelName:uu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o}=t,i=o,{filterSize:s,strides:u,pad:c,dimRoundingMode:l}=r,h=lp(i.shape,s,u,[1,1,1],c,l),d=new pL(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new gW(h),m=n.runWebGLProgram(f,[a,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const bW={kernelName:iu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:o,output:i}=t,s=o;HR([o,i],"maxPoolGrad");const{filterSize:u,strides:c,pad:l,dimRoundingMode:h}=r,d=cp(s.shape,u,c,1,l,h),p=new dL(d,"max",!0),f=n.runWebGLProgram(p,[s],s.dtype),m=new mW(d),g=n.runWebGLProgram(m,[a,f],s.dtype);return n.disposeIntermediateTensorInfo(f),g}};const vW={kernelName:cu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:o,strides:i,pad:s,includeBatchInIndex:u}=n,c=r;Wo(4===a.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(a.shape.length,".")));const l=[1,1];Wo(vp(i,l),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(i," and dilations '").concat(l,"'")));const h=cp(a.shape,o,i,l,s),[d,p]=function(e,t,n,r){let a=new dL(n,"max",!1);const o=r.runWebGLProgram(a,[e],"float32");return a=new dL(n,"max",!0,!0,t),[o,r.runWebGLProgram(a,[e],"float32")]}(a,u,h,c);return[d,p]}};const xW={kernelName:lu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{keepDims:o,axis:i}=n,s=r,u=a.shape.length,c=Qo(i,a.shape);let l=c;const h=mf(l,u),d=null!=h,p=s.shouldExecuteOnCPU([a]),f=[];let m=a;if(d){if(p){const e=s.texData.get(m.dataId).values,t=new Array(u);for(let r=0;r<t.length;r++)t[r]=a.shape[h[r]];const n=NO(e,a.shape,a.dtype,h,t);m=s.makeTensorInfo(t,a.dtype);s.texData.get(m.dataId).values=n}else m=Nz(a,h,s);f.push(m),l=yf(l.length,u)}ff("sum",l,u);const[g,y]=df(m.shape,l);let b=g;o&&(b=pf(g,c));const v=function(e,t,n,r){const a=Go(t),o=wz({inputs:{x:e},attrs:{shape:[Go(e.shape)/a,a]},backend:r}),i=Sz(o,"float32","mean",r),s=wz({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),s}(m,y,b,s);for(const x of f)s.disposeIntermediateTensorInfo(x);return v}};const wW={kernelName:hu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=a.shape.length,u=Qo(o,a.shape);let c=u;const l=mf(c,s);let h=a;null!=l&&(h=Fz({inputs:{x:a},backend:n,attrs:{perm:l}}),c=yf(c.length,a.shape.length)),ff("min",c,s);const[d,p]=df(h.shape,c),f=wz({inputs:{x:h},backend:n,attrs:{shape:[-1,Go(p)]}}),m=Sz(f,f.dtype,"min",n);let g;if(i){g=wz({inputs:{x:m},backend:n,attrs:{shape:pf(d,u)}})}else g=wz({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=l&&n.disposeIntermediateTensorInfo(h),g}},kW=dz({opSnippet:QO+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+JO+"\n  return result;\n",cpuKernelImpl:nO}),CW={kernelName:du,backendName:"webgl",kernelFunc:kW};class DW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=cM(r),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(o,");\n      ").concat(a," end = ").concat(a,"(").concat(i,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(r,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(u,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(u,";\n          }\n        }\n        ").concat(a," coords = outC - start;\n        setOutput(getX(").concat(s,"));\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(u,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(u,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class SW{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=cM(r),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=FO("rc",r),u=FO("source",r),c="".concat(s[r-1]," < ").concat(this.outputShape[r-1]),l=1===r?"source":"vec2(".concat(u.slice(-2).join(),")"),h="reflect"===n?0:1;let d="";if(1===r){const e="\n        ".concat(a," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");d="\n        ".concat(a," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(u.join(),"), ").concat(l,");\n        ").concat(s[r-1]," += 1;\n        if(").concat(c,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(u.join(),"), ").concat(l,");\n        }\n      ")}else{const e="\n        ".concat(a," source = rc;\n        ").concat(a," lt = ").concat(a,"(lessThan(source, start));\n        ").concat(a," gte = ").concat(a,"(greaterThanEqual(source, end));\n        ").concat(a," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");d="\n        ".concat(a," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(u.join(),"), ").concat(l,");\n        ").concat(s[r-1]," += 1;\n        if(").concat(c,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(u.join(),"), ").concat(l,");\n        }\n        rc = outputLoc;\n        ").concat(s[r-2]," += 1;\n        if(").concat(s[r-2]," < ").concat(this.outputShape[r-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(u.join(),"), ").concat(l,");\n          ").concat(s[r-1]," += 1;\n          if(").concat(c,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(u.join(),"), ").concat(l,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(o,");\n      const ").concat(a," end = ").concat(a,"(").concat(i,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d,"\n        setOutput(result);\n      }\n    ")}}const EW={kernelName:pu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a}=t,{paddings:o,mode:i}=r,s=xi().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SW(a.shape,o,i):new DW(a.shape,o,i);return n.runWebGLProgram(s,[a],a.dtype)}},IW=dz({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+JO+"\n  return result;\n"}),NW={kernelName:fu,backendName:"webgl",kernelFunc:IW};class TW{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const AW=dz({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),FW={kernelName:ws,backendName:"webgl",kernelFunc:AW},_W="return a - b;",RW=dz({opSnippet:_W,packedOpSnippet:_W,supportsComplex:!0,cpuKernelImpl:SO}),MW={kernelName:vc,backendName:"webgl",kernelFunc:RW};function OW(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:o}=r,i=Qo([o],a.shape),s=cW({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=pf(s.shape,i),c=wz({inputs:{x:s},backend:n,attrs:{shape:u}}),l=RW({inputs:{a:a,b:c},backend:n}),h=eP({inputs:{x:l},backend:n}),d=Tz({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=wz({inputs:{x:d},backend:n,attrs:{shape:u}}),f=AW({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const zW={kernelName:ic,backendName:"webgl",kernelFunc:OW};const LW={kernelName:mu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:o,seed:i,normalized:s}=r,u=s?a:OW({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),c=u.shape[0],l=u.shape[1],h=new TW(c,l,o),d=[[i]],p=n.runWebGLProgram(h,[u],"int32",d);return s||n.disposeIntermediateTensorInfo(u),p}},BW=PO+"\n  return -x;\n";const PW={kernelName:yu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,a]=aO(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}let a;return a=xi().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new jO(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new BO(r.shape,BW),n.runWebGLProgram(a,[r],r.dtype)}},WW=zm;const UW={kernelName:vu,backendName:"webgl",kernelFunc:function(e){zc("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:u}=r,c=n.readSync(a.dataId),l=n.readSync(o.dataId),{selectedIndices:h}=WW(c,l,i,s,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},VW=Lm;const GW={kernelName:xu,backendName:"webgl",kernelFunc:function(e){zc("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:u,padToMaxOutputSize:c}=r,l=n.readSync(a.dataId),h=n.readSync(o.dataId),{selectedIndices:d,validOutputs:p}=VW(l,h,i,s,u,c);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},jW=Bm;const HW={kernelName:wu,backendName:"webgl",kernelFunc:function(e){zc("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:o}=t,{maxOutputSize:i,iouThreshold:s,scoreThreshold:u,softNmsSigma:c}=r,l=n.readSync(a.dataId),h=n.readSync(o.dataId),d=i,p=s,f=u,m=c,{selectedIndices:g,selectedScores:y}=jW(l,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class qW{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(r,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const KW={kernelName:Cu,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:o,depth:i,onValue:s,offValue:u}=r,c=Go(a.shape),l=new qW(c,i,s,u),h=wz({inputs:{x:a},backend:n,attrs:{shape:[c]}}),d=n.runWebGLProgram(l,[h],o);n.disposeIntermediateTensorInfo(h);const p=wz({inputs:{x:d},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(d),p}};function XW(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=OL({inputs:{input:r},backend:n}),t=XW({inputs:{x:e},backend:n}),a=QL({inputs:{input:r},backend:n}),o=XW({inputs:{x:a},backend:n}),i=nz({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),i}return hP({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const YW={kernelName:Tc,backendName:"webgl",kernelFunc:XW};const QW={kernelName:ku,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=OL({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),o=QL({inputs:{input:a},backend:r}),i=XW({inputs:{x:o},backend:r}),s=nz({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),s}return hP({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const ZW={kernelName:Du,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return nP({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const o=t[0].shape,i=t[0].dtype;t.forEach((e=>{Uo(o,e.shape,"All tensors passed to stack must have matching shapes"),Wo(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const s=[],u=$L({inputs:t.map((e=>{const t=nP({inputs:{input:e},backend:n,attrs:{dim:a}});return s.push(t),t})),backend:n,attrs:{axis:a}});return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};class JW{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=cM(r),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      ".concat(a," start = ").concat(a,"(").concat(o,");\n      ").concat(a," end = ").concat(a,"(").concat(i,");\n\n      void main() {\n        ").concat(a," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(a," coords = outC - start;\n          setOutput(getX(").concat(s,"));\n        }\n      }\n    "):"\n        int start = ".concat(o,";\n        int end = ").concat(i,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class $W{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=cM(r),o=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),s=FO("rc",r),u=FO("source",r),c="".concat(s[r-1]," < ").concat(this.outputShape[r-1]),l=1===r?"source":"vec2(".concat(u.slice(-2).join(),")"),h=["".concat(a," rc = outputLoc;"),"".concat(s[r-1]," += 1;\n       if(").concat(c,") {\n      "),1===r?"":"}\n       rc = outputLoc;\n       ".concat(s[r-2]," += 1;\n       if(").concat(s[r-2]," < ").concat(this.outputShape[r-2],") {"),1===r?"":"  ".concat(s[r-1]," += 1;\n         if(").concat(c,") {")],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+="\n        ".concat(h[f],"\n        if (").concat(d,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(a," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(u.join(),"), ").concat(l,");\n        }\n      ");p+=1===r?"} ":"}}",this.userCode="\n      const ".concat(a," start = ").concat(a,"(").concat(o,");\n      const ").concat(a," end = ").concat(a,"(").concat(i,");\n\n      void main() {\n        ").concat(a," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const eU=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:o,constantValue:i}=r;if(0===Go(a.shape)){const e=o.map(((e,t)=>e[0]+a.shape[t]+e[1]));return hP({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}const s=xi().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $W(a.shape,o,i):new JW(a.shape,o,i),u=[[i]];return n.runWebGLProgram(s,[a],a.dtype,u)},tU={kernelName:Su,backendName:"webgl",kernelFunc:eU},nU=dz({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+JO+"\n  return result;\n"}),rU={kernelName:Eu,backendName:"webgl",kernelFunc:nU};const aU={kernelName:Nu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:o,keepDims:i}=r,s=a.shape.length,u=[],c=Qo(o,a.shape);let l=c;const h=mf(l,s);let d,p=a;if(null!=h&&(p=Fz({inputs:{x:a},backend:n,attrs:{perm:h}}),l=yf(l.length,s),u.push(p)),ff("prod",l,s),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:a}=iO(p.shape,p.dtype,e,l);d=n.makeTensorInfo(r,a,t)}else{const[e,t]=df(p.shape,l),r=Go(t),o=wz({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=Sz(o,zl(a.dtype),"prod",n);d=wz({inputs:{x:i},backend:n,attrs:{shape:e}}),u.push(o),u.push(i)}if(i){u.push(d);const e=pf(d.shape,c);d=wz({inputs:{x:d},backend:n,attrs:{shape:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const oU={kernelName:Tu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:o,indices:i}=t,{outputRaggedRank:s}=r,u=a.map((e=>n.readSync(e.dataId))),c=a.map((e=>e.shape)),l=n.readSync(o.dataId),h=n.readSync(i.dataId),[d,p,f]=sO(u,c,l,o.shape,o.dtype,h,i.shape,s),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,o.dtype,p);return m.concat([g])}};const iU={kernelName:Au,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:o}=t,i=n.readSync(r.dataId),s=n.readSync(a.dataId),u=n.readSync(o.dataId),[c,l]=uO(i,r.shape,r.dtype,s,a.shape,u,o.shape);return[n.makeTensorInfo([c.length],"int32",c),n.makeTensorInfo([l.length],r.dtype,l)]}};const sU={kernelName:Fu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:o,defaultValue:i,rowPartitionTensors:s}=t,{rowPartitionTypes:u}=r,c=n.readSync(a.dataId),l=n.readSync(o.dataId),h=n.readSync(i.dataId),d=s.map((e=>n.readSync(e.dataId))),p=s.map((e=>e.shape)),[f,m]=cO(c,a.shape,l,o.shape,o.dtype,h,i.shape,d,p,u);return n.makeTensorInfo(f,o.dtype,m)}},uU=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:o,dtype:i}=n,s=lO(r,a,o,i);return t.makeTensorInfo([s.length],i,s)},cU={kernelName:_u,backendName:"webgl",kernelFunc:uU},lU=hz({opSnippet:"return 1.0 / x;"}),hU={kernelName:Mu,backendName:"webgl",kernelFunc:lU},dU=hz({opSnippet:PO+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),pU={kernelName:Ou,backendName:"webgl",kernelFunc:dU},fU=hz({opSnippet:PO+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),mU={kernelName:Uu,backendName:"webgl",kernelFunc:fU};class gU{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,s,u]=e;this.outputShape=[o,t,n,u];const c=[r&&t>1?i-1:i,r&&n>1?s-1:s],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/l[0],",\n          ").concat(c[1]/l[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(s,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class yU{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,s,u]=e;this.outputShape=[o,t,n,u];const c=[r&&t>1?i-1:i,r&&n>1?s-1:s],l=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/l[0],",\n          ").concat(c[1]/l[1],",\n          ").concat(c[1]/l[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(s,".0,\n                                     ").concat(s,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(u-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const bU={kernelName:Pu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:o,halfPixelCenters:i,size:s}=r,[u,c]=s,l=xi().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new yU(a.shape,u,c,o,i):new gU(a.shape,u,c,o,i);return n.runWebGLProgram(l,[a],"float32")}};class vU{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,i]=e,s=[n&&o>1?r-1:r,n&&i>1?a-1:a],u=[n&&o>1?o-1:o,n&&i>1?i-1:i],c=s[0]/u[0],l=s[1]/u[1],h=1/c,d=1/l,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(l,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(r-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(a-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const xU={kernelName:Wu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:i}=r,s=new vU(o.shape,a.shape,i);return n.runWebGLProgram(s,[o],o.dtype)}};class wU{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,s,u]=e;this.outputShape=[o,t,n,u];const c=[r&&t>1?i-1:i,r&&n>1?s-1:s],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(c[0]/l[0],",\n          ").concat(c[1]/l[1],");\n      const vec2 inputShapeRC = vec2(").concat(i,".0, ").concat(s,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class kU{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,s,u]=e;this.outputShape=[o,t,n,u];const c=[r&&t>1?i-1:i,r&&n>1?s-1:s],l=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(c[0]/l[0],",\n          ").concat(c[1]/l[1],",\n          ").concat(c[1]/l[1],");\n      const vec3 inputShapeRC = vec3(").concat(i,".0, ").concat(s,".0,\n                                     ").concat(s,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(u-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const CU={kernelName:Lu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:o,halfPixelCenters:i,size:s}=r,[u,c]=s,l=xi().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new kU(a.shape,u,c,o,i):new wU(a.shape,u,c,o,i);return n.runWebGLProgram(l,[a],a.dtype)}};class DU{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,i]=e,s=[n&&o>1?r-1:r,n&&i>1?a-1:a],u=[n&&o>1?o-1:o,n&&i>1?i-1:i],c=s[0]/u[0],l=s[1]/u[1],h=1/c,d=1/l,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(c,");\n        const float widthScale = float(").concat(l,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(o,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(i,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(s[0],") *\n                (float(dyR) / float(").concat(u[0],"));\n\n            float sourceFracCol =\n                float(").concat(s[1],") *\n                  (float(dyC) / float(").concat(u[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const SU={kernelName:Bu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:o}=t,{alignCorners:i}=r,s=new DU(o.shape,a.shape,i);return n.runWebGLProgram(s,[o],o.dtype)}};class EU{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(r))).join(","),a=cM(n);this.userCode="\n      void main() {\n        ".concat(a," coords = getOutputCoords();\n        setOutput(getX(").concat(r,"));\n      }\n    ")}}class IU{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const r=FO("rc",n),a="".concat(r[n-1]," + 1 < ").concat(this.outputShape[n-1]),o="".concat(r[n-2]," + 1 < ").concat(this.outputShape[n-2]),i=cM(n);function s(n){const r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(r[n]," - 1"):"".concat(r[n])}(a,n))),a=r.join(","),o=r.slice(-2).join(",");return"getChannel(getX(".concat(a,"), vec2(").concat(o,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(a,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(i," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return s(e)}(r.slice()),";\n          if(").concat(a,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",s(e)}(r.slice()),";\n          }\n          if(").concat(o,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",s(e)}(r.slice()),";\n            if(").concat(a,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",s(e)}(r.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const NU={kernelName:Vu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:o}=r,i=a.shape.length,s=Qo(o,a.shape);if(0===i)return ez({inputs:{x:a},backend:n});const u=xi().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new IU(a.shape,s):new EU(a.shape,s);return n.runWebGLProgram(u,[a],a.dtype)}};class TU{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(a,"\n          if(coordX >= 0 && coordX < ").concat(r," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const AU={kernelName:_c,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:o,fillValue:i,center:s}=n,u=r,c=new TU(a.shape,i),[l,h]=Dg(s,a.shape[1],a.shape[2]),d=[[l,h,Math.sin(o),Math.cos(o)]];return u.runWebGLProgram(c,[a],a.dtype,d)}},FU=hz({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),_U={kernelName:Gu,backendName:"webgl",kernelFunc:FU},RU=hz({opSnippet:"return inversesqrt(x);",cpuKernelImpl:hO}),MU={kernelName:ju,backendName:"webgl",kernelFunc:RU};class OU{constructor(e,t,n,r,a,o){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const s=cM(a.length),u=cM(o.length);let c="";1===n?c="i":2===n&&(c="i, j");const l="getIndices(".concat(c,")");let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";i&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(s," strides = ").concat(s,"(").concat(a,");\n\n        void main() {\n          ").concat(u," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(l,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class zU{constructor(e,t,n,r,a,o){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const s=cM(a.length),u=cM(o.length);let c="";1===n?c="i":2===n&&(c="i, j");const l="getIndices(".concat(c,")");let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";i&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(s," strides = ").concat(s,"(").concat(a,");\n\n        void main() {\n          ").concat(u," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(l,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const LU={kernelName:Hu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:o}=t,{shape:i}=r,{sliceRank:s,numUpdates:u,sliceSize:c,strides:l,outputSize:h}=Rg(0,a,i),d=[h/c,c];if(0===h)return n.makeTensorInfo(i,a.dtype);const p=wz({inputs:{x:a},backend:n,attrs:{shape:[u,s]}}),f=wz({inputs:{x:o},backend:n,attrs:{shape:[u,c]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=xi().getBool("WEBGL_PACK")?new zU(u,s,p.shape.length,f.shape.length,l,d):new OU(u,s,p.shape.length,f.shape.length,l,d);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=wz({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class BU{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),o=2===xi().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(i," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const PU={kernelName:Ku,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:o}=t,{side:i}=r,s=new BU(a.shape[0],a.shape[1],o.shape[1],i),u=[[a.shape[1]]];return n.runWebGLProgram(s,[a,o],"int32",u)}};class WU{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let r=0;r<t.length;r++)i.push("".concat(n[r])),r<e&&o.push("".concat(n[r]));r=o.join(),a=i.join()}const o=cM(n);this.userCode="\n      void main() {\n        ".concat(o," resRC = getOutputCoords();\n        float cVal = getC(").concat(r,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(a,"));\n        } else {\n          setOutput(getB(").concat(a,"));\n        }\n      }\n    ")}}const UU={kernelName:Xu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:o}=t,i=new WU(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,o],Ol(a.dtype,o.dtype))}},VU=hz({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(Mg,";\n  float scale = ").concat(Og,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),GU={kernelName:Yu,backendName:"webgl",kernelFunc:VU},jU=hz({opSnippet:lz+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:pO}),HU={kernelName:ec,backendName:"webgl",kernelFunc:jU},qU=hz({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),KU={kernelName:$u,backendName:"webgl",kernelFunc:qU},XU=hz({opSnippet:lz+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(JO,"\n  return result;\n")}),YU={kernelName:Zu,backendName:"webgl",kernelFunc:XU},QU=hz({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),ZU={kernelName:Ju,backendName:"webgl",kernelFunc:QU},JU=hz({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),$U={kernelName:tc,backendName:"webgl",kernelFunc:JU},eV={kernelName:ac,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:o,paddings:i}=r;Wo(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const s=o.reduce(((e,t)=>e*t)),u=[[0,0]];u.push(...i);for(let y=1+o.length;y<a.shape.length;++y)u.push([0,0]);const c=[],l=eU({inputs:{x:a},backend:n,attrs:{paddings:u,constantValue:0}}),h=Sg(l.shape,o,s,!1),d=Eg(h.length,o.length,!1),p=Ig(l.shape,o,s,!1),f=wz({inputs:{x:l},backend:n,attrs:{shape:h}}),m=Fz({inputs:{x:f},backend:n,attrs:{perm:d}}),g=wz({inputs:{x:m},backend:n,attrs:{shape:p}});return c.push(l),c.push(f),c.push(m),c.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const tV={kernelName:sc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(o.shape));if(2!==r.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(r.shape));if(1!==a.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(a.shape));if(0!==i.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(i.shape));const s=n.readSync(r.dataId),u=n.readSync(a.dataId),c=n.readSync(o.dataId),l=n.readSync(i.dataId)[0],[h,d,p,f,m]=gO(s,r.shape,r.dtype,u,a.dtype,c,l);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};const nV={kernelName:uc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:o}=t;if(2!==r.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(r.shape));if(1!==a.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(a.shape));if(1!==o.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(o.shape));const i=Array.from(n.readSync(a.dataId)),s=n.readSync(r.dataId),u=Array.from(n.readSync(o.dataId)),[c,l,h]=yO(s,r.shape,r.dtype,i,u);return[n.makeTensorInfo(l,r.dtype,c),n.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}};const rV={kernelName:cc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(a.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(o.shape));const i=n.readSync(r.dataId),s=n.readSync(a.dataId),u=n.readSync(o.dataId),[c,l]=bO(i,r.shape,r.dtype,s,u,!0);return n.makeTensorInfo(l,r.dtype,c)}};const aV={kernelName:lc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(a.shape));if(1!==o.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(o.shape));const i=n.readSync(r.dataId),s=n.readSync(a.dataId),u=n.readSync(o.dataId),[c,l]=bO(i,r.shape,r.dtype,s,u);return n.makeTensorInfo(l,r.dtype,c)}};const oV={kernelName:hc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:o,defaultValue:i}=t,{outputShape:s}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:h,outputSize:d}=Rg(0,a,s),p=!1;if("string"===o.dtype){const e=n.bufferSync(a),t=n.bufferSync(o),r=hl(n.readSync(i.dataId)[0]),f=dO(e,t,s,d,l,c,u,h,r,p);return n.makeTensorInfo(s,f.dtype,f.values)}const f=new OU(c,u,a.shape.length,o.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[o,a,i],o.dtype),g=wz({inputs:{x:m},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(m),g}};const iV={kernelName:oc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:o,axis:i}=r,s=Qo(i,a.shape)[0],u=iy(a,o,s),c=a.shape.length,l=new Array(c).fill(0),h=a.shape.slice();return u.map((e=>{const t=[...h];t[s]=e;const r=IL({inputs:{x:a},backend:n,attrs:{begin:l,size:t}});return l[s]+=e,r}))}},sV="return sqrt(x);",uV=hz({opSnippet:sV,packedOpSnippet:sV,cpuKernelImpl:vO}),cV={kernelName:nc,backendName:"webgl",kernelFunc:uV},lV={kernelName:pc,backendName:"webgl",kernelFunc:hz({opSnippet:"return x * x;"})},hV="return (a - b) * (a - b);",dV=dz({opSnippet:hV,packedOpSnippet:hV}),pV={kernelName:dc,backendName:"webgl",kernelFunc:dV};const fV={kernelName:fc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const o=ky(n.readSync(a.dataId)),i=xO(o,"string",r);return n.makeTensorInfo(a.shape,"string",i)}};const mV={kernelName:Ac,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,o=PO+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),i=new BO(a.shape,o);return r.runWebGLProgram(i,[a],a.dtype)}};class gV{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=cM(n.length),o=cM(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?"coords * strides[".concat(r,"] + begin[").concat(r,"]"):"coords[".concat(e-1,"] * strides[").concat(r,"] + begin[").concat(r,"]")))).join(",")}this.userCode="\n      ".concat(a," begin = ").concat(a,"(").concat(e,");\n      ").concat(a," strides = ").concat(a,"(").concat(t,");\n\n      void main() {\n        ").concat(o," coords = getOutputCoords();\n        setOutput(getX(").concat(i,"));\n      }\n    ")}}const yV={kernelName:mc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:o,end:i,strides:s,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=rp(a.shape,o,i,s,u,c,l,h,d);let w;if(m)w=wz({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){Wo(a.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(a.shape.length)));const e=jd(b,v,x),t=IL({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=wz({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=Jh(a.shape,a.dtype,e),r=wO(p,t,x,b);w=n.makeTensorInfo(f,a.dtype,r.values)}else{const e=new gV(b,x,p);w=n.runWebGLProgram(e,[a],a.dtype)}}const k=wz({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const bV={kernelName:gc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:o,leftPad:i,rightPad:s,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:h}=t,d=n.readSync(l.dataId),p=n.readSync(h.dataId),[f,m]=kO(d,p,a,o,i,s,u,c);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};const vV={kernelName:yc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error("Input must be a vector, got shape: ".concat(o.shape));if(0!==i.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));const s=n.readSync(o.dataId),u=n.readSync(i.dataId)[0],[c,l,h]=CO(s,u,a),d=l.length;return[n.makeTensorInfo([d,2],"int32",c),n.makeTensorInfo([d],"string",l),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const xV={kernelName:bc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),s=DO(i,a);return n.makeTensorInfo(o.shape,"int32",s)}},wV=hz({opSnippet:"return tan(x);"}),kV={kernelName:xc,backendName:"webgl",kernelFunc:wV},CV=hz({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),DV={kernelName:wc,backendName:"webgl",kernelFunc:CV};const SV={kernelName:qu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:o,updates:i}=t,{}=r,{sliceRank:s,numUpdates:u,sliceSize:c,strides:l,outputSize:h}=Rg(0,o,a.shape),d=[h/c,c];if(0===h)return n.makeTensorInfo(a.shape,o.dtype);const p=wz({inputs:{x:o},backend:n,attrs:{shape:[u,s]}}),f=wz({inputs:{x:i},backend:n,attrs:{shape:[u,c]}}),m=wz({inputs:{x:a},backend:n,attrs:{shape:d}}),g=new OU(u,s,p.shape.length,f.shape.length,l,d,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=wz({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class EV{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const r=cM(this.rank),a=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push("imod(".concat(n[a],", ").concat(e[a],")"));return r.join()}(e);this.userCode="\n      void main() {\n        ".concat(r," resRC = getOutputCoords();\n        setOutput(getA(").concat(a,"));\n      }\n    ")}}function IV(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:o}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>hl(e))):e,r=Jh(a.shape,a.dtype,t),i=EO(r,o);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new EV(a.shape,o);return n.runWebGLProgram(i,[a],a.dtype)}const NV={kernelName:kc,backendName:"webgl",kernelFunc:IV};class TV{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class AV{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function FV(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function _V(e){let t=1;for(;t<e;)t*=2;return t}const RV={kernelName:Cc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:o,sorted:i}=r,s=xi().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=xi().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=a.shape,l=c[c.length-1];if(n.shouldExecuteOnCPU([a])||l<s||o>u){const e=n.readSync(a.dataId),[t,r]=IO(e,c,a.dtype,o,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===o)return c[c.length-1]=0,[n.makeTensorInfo(c,a.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(1===l)return[a,hP({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const h=n.texData.get(a.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(a):a,f=Go(c)/l,m=wz({inputs:{x:p},attrs:{shape:[f,l]},backend:n});d&&FV(n,p);const g=_V(o),y=_V(l);let b=null;const v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{const a=v(),o=new TV(r),i=[[l],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],s=b;b=n.runWebGLProgram(o,a,"int32",i),FV(n,s)};for(let S=1;S<g;S*=2){const e=2*S;for(let t=S;t>=1;t/=2)x(e,t,[f,y])}for(let S=y;S>g;S/=2){const e=v(),t=new AV([f,S/2]),r=[[l],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),FV(n,a);const o=g/2,i=2*o;for(let n=o;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=IL({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,o]}}),FV(n,w);let k=AP({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});FV(n,m);const C=c.slice(0,-1);C.push(o),w=b,b=wz({inputs:{x:b},attrs:{shape:C},backend:n}),FV(n,w);const D=k;return k=wz({inputs:{x:k},attrs:{shape:C},backend:n}),FV(n,D),[k,b]}};class MV{constructor(e,t,n,r,a,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i="nearest"===n?1:2;let s;switch(r){case"constant":default:s=1;break;case"reflect":s=2;break;case"wrap":s=3;break;case"nearest":s=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(s," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(s," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(s," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(a,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(a,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(i," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const OV={kernelName:Dc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:o}=t,{interpolation:i,fillMode:s,fillValue:u,outputShape:c}=r,[l,h,d,p]=a.shape,[f,m]=null!=c?c:[h,d],g=new MV(h,d,i,s,u,[l,f,m,p]);return n.runWebGLProgram(g,[a,o],"float32")}};const zV={kernelName:Ec,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:o}=t;HR(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:s,outputShape:u,indices:c}=TO(i,a,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,s),r.makeTensorInfo([c.length],"int32",c)]}};const LV={kernelName:Ic,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:o}=r;o<0&&(o+=a.shape.length);const i=a,s=i.shape.length,u=a.shape[o],c=new Array(s-1);let l=0;for(let m=0;m<s;m++)m!==o&&(c[l++]=i.shape[m]);const h=[],d=new Array(s).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(u);for(let m=0;m<f.length;m++){d[o]=m;const e=IL({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=wz({inputs:{x:e},backend:n,attrs:{shape:c}});f[m]=t,h.push(e)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class BV{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,o=e.numSegments,i=o*Math.ceil(a/n);this.outputShape=[r,i];const s=4*Math.floor(n/4),u=n%4,c="\n        sumValue += dot(values, segFilter);\n    ";let l="";a%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return initializationValue;\n        }\n      "));let h="";a%n>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(a,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(s,";\n        if (").concat(1===u,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(c,"\n        } else if (").concat(2===u,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(c,"\n        } else if (").concat(3===u,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(c,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const PV={kernelName:Nc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:o}=t,{numSegments:i}=r,s=a.shape.length,u=[];let c=0;const l=mf([c],s);let h=a;null!=l&&(h=Fz({inputs:{x:a},backend:n,attrs:{perm:l}}),u.push(h),c=yf(1,s)[0]);const d=xy(h.shape,c,i),p=Go([h.shape[c]]),f=wz({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});u.push(f);const m=zl(a.dtype),g=(e,t,r,a,o)=>{const i=e.shape[0],s=e.shape[1],c=vy(s,o),l=new BV({windowSize:c,inSize:s,batchSize:i,numSegments:o},t),h=n.compileAndRun(l,[e,r],a);if(u.push(h),h.shape[1]===o)return h;const d=uU({backend:n,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),p=IV({inputs:{x:d},backend:n,attrs:{reps:[s/c]}});u.push(d),u.push(p);return g(h,t,p,a,o)},y=wz({inputs:{x:g(f,"unsortedSegmentSum",o,m,i)},backend:n,attrs:{shape:d}});let b=y;if(null!=l){u.push(y);const e=gf(l);b=Fz({inputs:{x:b},backend:n,attrs:{perm:e}})}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},WV=[Mz,zz,Bz,Wz,Gz,qz,Kz,Xz,eL,tL,rL,oL,sL,cL,hL,fL,mL,bL,vL,xL,CL,TL,AL,FL,_L,LL,WL,GL,rz,qL,eB,uB,pB,mB,gB,yB,bB,xB,kB,DB,AB,FB,_B,MB,LB,WB,UB,GB,HB,qB,XB,YB,ZB,$B,tP,rP,iP,cP,dP,fP,yP,vP,kP,SP,EP,NP,FP,RP,OP,tz,zP,ZL,BP,WP,VP,iz,jP,qP,KP,YP,ZP,$P,tW,rW,iW,uW,lW,dW,pW,fW,yW,bW,vW,xW,wW,CW,EW,NW,LW,xz,PW,UW,GW,HW,ML,KW,QW,ZW,tU,rU,cz,aU,oU,iU,sU,cU,zL,FW,hU,pU,mU,kz,bU,xU,CU,SU,NU,AU,_U,MU,LU,PU,UU,GU,HU,KU,YU,ZU,NL,zW,$U,eV,tV,nV,rV,aV,oV,iV,cV,lV,pV,fV,mV,yV,bV,vV,xV,MW,Az,kV,DV,SV,NV,RV,OV,_z,zV,LV,PV,YW];for(const eG of WV)Gc(eG);var UV=__webpack_require__(447),VV=__webpack_require__.n(UV),GV=__webpack_require__(579);const jV=e=>Array.from({length:e},(()=>Array.from({length:e},(()=>Math.floor(100*Math.random()))))),HV=(e,t)=>{const n=e.length,r=Array.from({length:n},(()=>Array(n).fill(0)));for(let a=0;a<n;a++)for(let o=0;o<n;o++)for(let i=0;i<n;i++)r[a][o]+=e[a][i]*t[i][o];return r},qV=(e,t)=>Ao(e,t),KV=(e,t)=>_o().dot(e,t),XV=async(e,t)=>{try{await(n="webgl",Kl.setBackend(n));const r=rm(e),a=rm(t),o=await xf(r,a).array();return r.dispose(),a.dispose(),o}catch(r){return console.error("TensorFlow.js error:",r),null}var n},YV=(e,t)=>{const n=new(VV())(e),r=new(VV())(t);return n.mul(r)},QV=()=>{const[e,t]=(0,a.useState)(""),[n,r]=(0,a.useState)([]),[o,i]=(0,a.useState)([]),[s,u]=(0,a.useState)(100),[c,l]=(0,a.useState)(null),[h,d]=(0,a.useState)(!1);return(0,GV.jsxs)("div",{children:[(0,GV.jsxs)("div",{style:{padding:"20px"},children:[(0,GV.jsx)("h1",{children:"Matrix Multiplier Performance Comparison"}),(0,GV.jsxs)("label",{children:["Repetitions:",(0,GV.jsx)("input",{type:"number",value:s,onChange:e=>u(parseInt(e.target.value,10))})]})]}),(0,GV.jsxs)("div",{style:{padding:"20px"},children:[(0,GV.jsxs)("label",{children:["Matrix Size:",(0,GV.jsx)("input",{type:"number",value:e,onChange:e=>{const n=parseInt(e.target.value,10);t(n),r(jV(n)),i(jV(n)),l(null)},placeholder:"Enter the matrix size"})]}),(0,GV.jsx)("button",{onClick:async()=>{d(!0);const e=[{name:"Vanilla JS",func:HV},{name:"Math.js",func:qV},{name:"Numeric.js",func:KV},{name:"TensorFlow.js",func:XV},{name:"Matrix.js",func:YV}],t={};for(const r of e){let e,a,i=0;if("TensorFlow.js"===r.name)for(let t=0;t<10;t++)await XV(n,o);for(let t=0;t<s;t++)e=performance.now(),await r.func(n,o),a=performance.now(),i+=a-e;i=(i/s).toFixed(4),t[r.name]=i}l(t),d(!1)},children:"Compare Performance"})]}),h&&(0,GV.jsxs)("div",{style:{textAlign:"center",marginTop:"20px"},children:[(0,GV.jsx)("div",{className:"spinner",style:{display:"inline-block",border:"8px solid #f3f3f3",borderTop:"8px solid #3498db",borderRadius:"50%",width:"50px",height:"50px",animation:"spin 1s linear infinite"}}),(0,GV.jsx)("p",{children:"Calculating..."})]}),c&&!h&&(0,GV.jsxs)("div",{style:{padding:"20px"},children:[(0,GV.jsx)("h2",{children:"Performance Results (ms)"}),(0,GV.jsx)("ul",{style:{listStyleType:"none"},children:Object.entries(c).map((e=>{let[t,n]=e;return(0,GV.jsxs)("li",{children:[t,": ",n," ms"]},t)}))})]})]})};const ZV=function(){return(0,GV.jsxs)("div",{className:"App",children:[(0,GV.jsx)("header",{className:"App-header",children:(0,GV.jsx)("h1",{children:"Matrix Multiplication with React"})}),(0,GV.jsx)("main",{children:(0,GV.jsx)(QV,{})})]})},JV=e=>{e&&e instanceof Function&&__webpack_require__.e(453).then(__webpack_require__.bind(__webpack_require__,453)).then((t=>{let{getCLS:n,getFID:r,getFCP:a,getLCP:o,getTTFB:i}=t;n(e),r(e),a(e),o(e),i(e)}))};o.createRoot(document.getElementById("root")).render((0,GV.jsx)(a.StrictMode,{children:(0,GV.jsx)(ZV,{})})),JV()})()})();
//# sourceMappingURL=main.3dc6d0f8.js.map